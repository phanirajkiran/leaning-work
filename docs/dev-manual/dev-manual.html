<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><link rel="stylesheet" href="dev-style.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /></head><body><div xml:lang="en" class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="dev-manual"></a></h1></div><div><div class="authorgroup">
            <div class="author"><h3 class="author"><span class="firstname">Scott</span> <span class="surname">Rifenbark</span></h3><div class="affiliation">
                    <span class="orgname">Intel Corporation<br /></span>
                </div><code class="email">&lt;<a class="email" href="mailto:scott.m.rifenbark@intel.com">scott.m.rifenbark@intel.com</a>&gt;</code></div>
        </div></div><div><p class="copyright">Copyright © 2010-2013 Linux Foundation</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idp17384"></a>
      <p>
          Permission is granted to copy, distribute and/or modify this document under
          the terms of the <a class="ulink" href="http://creativecommons.org/licenses/by-sa/2.0/uk/" target="_top">
          Creative Commons Attribution-Share Alike 2.0 UK: England &amp; Wales</a> as published by
          Creative Commons.
      </p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
          Due to production processes, there could be differences between the Yocto Project
          documentation bundled in the release tarball and the
          <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/dev-manual/dev-manual.html" target="_top">Yocto Project Development Manual</a> on
          the <a class="ulink" href="http://www.yoctoproject.org" target="_top">Yocto Project</a> website.
          For the latest version of this manual, see the manual on the website.
      </div>
    </div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr>
            <tr><td align="left">Revision 1.1</td><td align="left">6 October 2011</td></tr><tr><td align="left" colspan="2">The initial document released with the Yocto Project 1.1 Release.</td></tr>
            <tr><td align="left">Revision 1.2</td><td align="left">April 2012</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.2 Release.</td></tr>
            <tr><td align="left">Revision 1.3</td><td align="left">October 2012</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.3 Release.</td></tr>
            <tr><td align="left">Revision 1.4</td><td align="left">Sometime in 2013</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.4 Release.</td></tr>
        </table></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#dev-manual-intro">1. The Yocto Project Development Manual</a></span></dt><dd><dl><dt><span class="section"><a href="#intro">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#what-this-manual-provides">1.2. What this Manual Provides</a></span></dt><dt><span class="section"><a href="#what-this-manual-does-not-provide">1.3. What this Manual Does Not Provide</a></span></dt><dt><span class="section"><a href="#other-information">1.4. Other Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dev-manual-start">2. Getting Started with the Yocto Project</a></span></dt><dd><dl><dt><span class="section"><a href="#introducing-the-yocto-project">2.1. Introducing the Yocto Project</a></span></dt><dt><span class="section"><a href="#getting-setup">2.2. Getting Set Up</a></span></dt><dt><span class="section"><a href="#building-images">2.3. Building Images</a></span></dt><dt><span class="section"><a href="#using-pre-built-binaries-and-qemu">2.4. Using Pre-Built Binaries and QEMU</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dev-manual-newbie">3. The Yocto Project Open Source Development Environment</a></span></dt><dd><dl><dt><span class="section"><a href="#open-source-philosophy">3.1. Open Source Philosophy</a></span></dt><dt><span class="section"><a href="#usingpoky-changes-collaborate">3.2. Using the Yocto Project in a Team Environment</a></span></dt><dt><span class="section"><a href="#yocto-project-repositories">3.3. Yocto Project Source Repositories</a></span></dt><dt><span class="section"><a href="#yocto-project-terms">3.4. Yocto Project Terms</a></span></dt><dt><span class="section"><a href="#licensing">3.5. Licensing</a></span></dt><dt><span class="section"><a href="#git">3.6. Git</a></span></dt><dd><dl><dt><span class="section"><a href="#repositories-tags-and-branches">3.6.1. Repositories, Tags, and Branches</a></span></dt><dt><span class="section"><a href="#basic-commands">3.6.2. Basic Commands</a></span></dt></dl></dd><dt><span class="section"><a href="#workflows">3.7. Workflows</a></span></dt><dt><span class="section"><a href="#tracking-bugs">3.8. Tracking Bugs</a></span></dt><dt><span class="section"><a href="#how-to-submit-a-change">3.9. How to Submit a Change</a></span></dt><dd><dl><dt><span class="section"><a href="#pushing-a-change-upstream">3.9.1. Using Scripts to Push a Change Upstream and Request a Pull</a></span></dt><dt><span class="section"><a href="#submitting-a-patch">3.9.2. Using Email to Submit a Patch</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#dev-manual-model">4. Common Development Models</a></span></dt><dd><dl><dt><span class="section"><a href="#system-development-model">4.1. System Development Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#developing-a-board-support-package-bsp">4.1.1. Developing a Board Support Package (BSP)</a></span></dt><dt><span class="section"><a href="#modifying-the-kernel">4.1.2. Modifying the Kernel</a></span></dt></dl></dd><dt><span class="section"><a href="#application-development-workflow">4.2. Application Development Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#workflow-using-the-adt-and-eclipse">4.2.1. Workflow Using the ADT and <span class="trademark">Eclipse</span>™</a></span></dt><dt><span class="section"><a href="#adt-eclipse">4.2.2. Working Within Eclipse</a></span></dt><dt><span class="section"><a href="#workflow-using-stand-alone-cross-development-toolchains">4.2.3. Workflow Using Stand-alone Cross-development Toolchains</a></span></dt></dl></dd><dt><span class="section"><a href="#modifying-temporary-source-code">4.3. Modifying Temporary Source Code</a></span></dt><dd><dl><dt><span class="section"><a href="#finding-the-temporary-source-code">4.3.1. Finding the Temporary Source Code</a></span></dt><dt><span class="section"><a href="#using-a-quilt-workflow">4.3.2. Using a Quilt Workflow</a></span></dt><dt><span class="section"><a href="#using-a-git-workflow">4.3.3. Using a Git Workflow</a></span></dt></dl></dd><dt><span class="section"><a href="#image-development-using-hob">4.4. Image Development Using Hob</a></span></dt><dt><span class="section"><a href="#platdev-appdev-devshell">4.5. Using a Development Shell</a></span></dt></dl></dd><dt><span class="chapter"><a href="#extendpoky">5. Common Tasks</a></span></dt><dd><dl><dt><span class="section"><a href="#understanding-and-creating-layers">5.1. Understanding and Creating Layers</a></span></dt><dd><dl><dt><span class="section"><a href="#yocto-project-layers">5.1.1. Layers</a></span></dt><dt><span class="section"><a href="#creating-your-own-layer">5.1.2. Creating Your Own Layer</a></span></dt><dt><span class="section"><a href="#enabling-your-layer">5.1.3. Enabling Your Layer</a></span></dt><dt><span class="section"><a href="#using-bbappend-files">5.1.4. Using .bbappend Files</a></span></dt><dt><span class="section"><a href="#prioritizing-your-layer">5.1.5. Prioritizing Your Layer</a></span></dt><dt><span class="section"><a href="#managing-layers">5.1.6. Managing Layers</a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-extend-customimage">5.2. Customizing Images</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-extend-customimage-custombb">5.2.1. Customizing Images Using Custom .bb Files</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-customtasks">5.2.2. Customizing Images Using Custom Package Groups</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-imagefeatures">5.2.3. Customizing Images Using Custom <code class="filename">IMAGE_FEATURES</code> and
                <code class="filename">EXTRA_IMAGE_FEATURES</code></a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-localconf">5.2.4. Customizing Images Using <code class="filename">local.conf</code></a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-extend-addpkg">5.3. Adding a Package</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-extend-addpkg-singlec">5.3.1. Single .c File Package (Hello World!)</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-autotools">5.3.2. Autotooled Package</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-makefile">5.3.3. Makefile-Based Package</a></span></dt><dt><span class="section"><a href="#splitting-an-application-into-multiple-packages">5.3.4. Splitting an Application into Multiple Packages</a></span></dt><dt><span class="section"><a href="#including-static-library-files">5.3.5. Including Static Library Files</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-postinstalls">5.3.6. Post Install Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#platdev-newmachine">5.4. Adding a New Machine</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-newmachine-conffile">5.4.1. Adding the Machine Configuration File</a></span></dt><dt><span class="section"><a href="#platdev-newmachine-kernel">5.4.2. Adding a Kernel for the Machine</a></span></dt><dt><span class="section"><a href="#platdev-newmachine-formfactor">5.4.3. Adding a Formfactor Configuration File</a></span></dt></dl></dd><dt><span class="section"><a href="#building-multiple-architecture-libraries-into-one-image">5.5. Combining Multiple Versions of Library Files into One Image</a></span></dt><dd><dl><dt><span class="section"><a href="#preparing-to-use-multilib">5.5.1. Preparing to use Multilib</a></span></dt><dt><span class="section"><a href="#using-multilib">5.5.2. Using Multilib</a></span></dt><dt><span class="section"><a href="#additional-implementation-details">5.5.3. Additional Implementation Details</a></span></dt></dl></dd><dt><span class="section"><a href="#configuring-the-kernel">5.6. Configuring the Kernel</a></span></dt><dd><dl><dt><span class="section"><a href="#using-menuconfig">5.6.1. Using  <code class="filename">menuconfig</code></a></span></dt><dt><span class="section"><a href="#creating-config-fragments">5.6.2. Creating Configuration Fragments</a></span></dt><dt><span class="section"><a href="#fine-tuning-the-kernel-configuration-file">5.6.3. Fine-tuning the Kernel Configuration File</a></span></dt></dl></dd><dt><span class="section"><a href="#patching-the-kernel">5.7. Patching the Kernel</a></span></dt><dd><dl><dt><span class="section"><a href="#create-a-layer-for-your-changes">5.7.1. Create a Layer for your Changes</a></span></dt><dt><span class="section"><a href="#finding-the-kernel-source-code">5.7.2. Finding the Kernel Source Code</a></span></dt><dt><span class="section"><a href="#creating-the-patch">5.7.3. Creating the Patch</a></span></dt><dt><span class="section"><a href="#get-your-layer-setup-for-the-build">5.7.4. Get Your Layer Setup for the Build</a></span></dt><dt><span class="section"><a href="#set-up-for-the-build">5.7.5. Set Up for the Build</a></span></dt><dt><span class="section"><a href="#build-and-booting-the-modified-qemu-kernel-image">5.7.6. Build and Booting the Modified QEMU Kernel Image</a></span></dt><dt><span class="section"><a href="#verify-your-changes">5.7.7. Verify Your Changes</a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-changes-updatingimages">5.8. Updating Existing Images</a></span></dt><dt><span class="section"><a href="#working-with-packages">5.9. Working with Packages</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-changes-prbump">5.9.1. Incrementing a Package Revision Number</a></span></dt><dt><span class="section"><a href="#usingpoky-configuring-DISTRO_PN_ALIAS">5.9.2. Handling a Package Name Alias</a></span></dt><dt><span class="section"><a href="#handling-optional-module-packaging">5.9.3. Handling Optional Module Packaging</a></span></dt></dl></dd><dt><span class="section"><a href="#building-software-from-an-external-source">5.10. Building Software from an External Source</a></span></dt><dt><span class="section"><a href="#excluding-recipes-from-the-build">5.11. Excluding Recipes From the Build</a></span></dt><dt><span class="section"><a href="#platdev-appdev-srcrev">5.12. Using an External SCM</a></span></dt><dt><span class="section"><a href="#platdev-gdb-remotedebug">5.13. Debugging With the GNU Project Debugger (GDB) Remotely</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-gdb-remotedebug-launch-gdbserver">5.13.1. Launching Gdbserver on the Target</a></span></dt><dt><span class="section"><a href="#platdev-gdb-remotedebug-launch-gdb">5.13.2. Launching GDB on the Host Computer</a></span></dt></dl></dd><dt><span class="section"><a href="#platdev-oprofile">5.14. Profiling with OProfile</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-oprofile-target">5.14.1. Profiling on the Target</a></span></dt><dt><span class="section"><a href="#platdev-oprofile-oprofileui">5.14.2. Using OProfileUI</a></span></dt></dl></dd><dt><span class="section"><a href="#maintaining-open-source-license-compliance-during-your-products-lifecycle">5.15. Maintaining Open Source License Compliance During Your Product's Lifecycle</a></span></dt><dd><dl><dt><span class="section"><a href="#providing-the-source-code">5.15.1. Providing the Source Code</a></span></dt><dt><span class="section"><a href="#providing-license-text">5.15.2. Providing License Text</a></span></dt><dt><span class="section"><a href="#providing-compilation-scripts-and-source-code-modifications">5.15.3. Providing Compilation Scripts and Source Code Modifications</a></span></dt></dl></dd></dl></dd></dl></div>
    

    <div class="chapter" title="Chapter 1. The Yocto Project Development Manual"><div class="titlepage"><div><div><h2 class="title"><a id="dev-manual-intro"></a>Chapter 1. The Yocto Project Development Manual</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#intro">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#what-this-manual-provides">1.2. What this Manual Provides</a></span></dt><dt><span class="section"><a href="#what-this-manual-does-not-provide">1.3. What this Manual Does Not Provide</a></span></dt><dt><span class="section"><a href="#other-information">1.4. Other Information</a></span></dt></dl></div><div class="section" title="1.1. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="intro"></a>1.1. Introduction</h2></div></div></div><p>
            Welcome to the Yocto Project Development Manual!
            This manual gives you an idea of how to use the Yocto Project to develop embedded Linux
            images and user-space applications to run on targeted devices.
            Reading this manual gives you an overview of image, kernel, and user-space application development
            using the Yocto Project.
            Because much of the information in this manual is general, it contains many references to other
            sources where you can find more detail.
            For example, detailed information on Git, repositories and open source in general
            can be found in many places.
            Another example is how to get set up to use the Yocto Project, which our Yocto Project
            Quick Start covers.
        </p><p>
            The Yocto Project Development Manual, however, does provide detailed examples
            on how to change the kernel source code, reconfigure the kernel, and develop
            an application using the popular <span class="trademark">Eclipse</span>™ IDE.
        </p></div><div class="section" title="1.2. What this Manual Provides"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="what-this-manual-provides"></a>1.2. What this Manual Provides</h2></div></div></div><p>
            The following list describes what you can get from this guide:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Information that lets you get set
                    up to develop using the Yocto Project.</p></li><li class="listitem"><p>Information to help developers who are new to the open source environment
                    and to the distributed revision control system Git, which the Yocto Project
                    uses.</p></li><li class="listitem"><p>An understanding of common end-to-end development models and tasks.</p></li><li class="listitem"><p>Development case overviews for both system development and user-space
                    applications.</p></li><li class="listitem"><p>An overview and understanding of the emulation environment used with
                    the Yocto Project - the Quick EMUlator (QEMU).</p></li><li class="listitem"><p>An understanding of basic kernel architecture and concepts.</p></li><li class="listitem"><p>Many references to other sources of related information.</p></li></ul></div><p>
        </p></div><div class="section" title="1.3. What this Manual Does Not Provide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="what-this-manual-does-not-provide"></a>1.3. What this Manual Does Not Provide</h2></div></div></div><p>
            This manual will not give you the following:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Step-by-step instructions if those instructions exist in other Yocto
                    Project documentation.
                    For example, the Yocto Project Application Developer's Guide contains detailed
                    instruction on how to run the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#installing-the-adt" target="_top">Installing the ADT and Toolchains</a>,
                    which is used to set up a cross-development environment.</p></li><li class="listitem"><p>Reference material.
                    This type of material resides in an appropriate reference manual.
                    For example, system variables are documented in the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html" target="_top">Yocto Project Reference Manual</a>.</p></li><li class="listitem"><p>Detailed public information that is not specific to the Yocto Project.
                    For example, exhaustive information on how to use Git is covered better through the
                    Internet than in this manual.</p></li></ul></div><p>
        </p></div><div class="section" title="1.4. Other Information"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="other-information"></a>1.4. Other Information</h2></div></div></div><p>
            Because this manual presents overview information for many different topics, you will
            need to supplement it with other information.
            The following list presents other sources of information you might find helpful:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>The <a class="ulink" href="http://www.yoctoproject.org" target="_top">Yocto Project Website</a>:
                    </em></span> The home page for the Yocto Project provides lots of information on the project
                    as well as links to software and documentation.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html" target="_top">Yocto Project Quick Start</a>:</em></span> This short document lets you get started
                    with the Yocto Project quickly and start building an image.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html" target="_top">Yocto Project Reference Manual</a>:</em></span> This manual is a reference
                    guide to the OpenEmbedded build system known as "Poky."
                    The manual also contains a reference chapter on Board Support Package (BSP)
                    layout.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html" target="_top">Yocto Project Application Developer's Guide</a>:</em></span>
                    This guide provides information that lets you get going with the Application
                    Development Toolkit (ADT) and stand-alone cross-development toolchains to
                    develop projects using the Yocto Project.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html" target="_top">Yocto Project Board Support Package (BSP) Developer's Guide</a>:</em></span>
                    This guide defines the structure for BSP components.
                    Having a commonly understood structure encourages standardization.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/kernel-manual/kernel-manual.html" target="_top">Yocto Project Kernel Architecture and Use Manual</a>:</em></span>
                    This manual describes the architecture of the Yocto Project kernel and provides
                    some work flow examples.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.youtube.com/watch?v=3ZlOu-gLsh0" target="_top">
                    Eclipse IDE Yocto Plug-in</a>:</em></span> A step-by-step instructional video that
                    demonstrates how an application developer uses Yocto Plug-in features within
                    the Eclipse IDE.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="https://wiki.yoctoproject.org/wiki/FAQ" target="_top">FAQ</a>:</em></span>
                    A list of commonly asked questions and their answers.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/download/yocto/yocto-project-1.4-release-notes-poky-8.0" target="_top">
                    Release Notes</a>:</em></span> Features, updates and known issues for the current
                    release of the Yocto Project.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/tools-resources/projects/hob" target="_top">
                    Hob</a>:</em></span> A graphical user interface for BitBake.
                    Hob's primary goal is to enable a user to perform common tasks more easily.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.yoctoproject.org/download/build-appliance-0" target="_top">
                    Build Appliance</a>:</em></span> A bootable custom embedded Linux image you can
                    either build using a non-Linux development system (VMware applications) or download
                    from the Yocto Project website.
                    See the <a class="ulink" href="http://www.yoctoproject.org/documentation/build-appliance-manual" target="_top">Build Appliance</a>
                    page for more information.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://bugzilla.yoctoproject.org" target="_top">Bugzilla</a>:</em></span>
                    The bug tracking application the Yocto Project uses.
                    If you find problems with the Yocto Project, you should report them using this
                    application.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    Yocto Project Mailing Lists:</em></span> To subscribe to the Yocto Project mailing
                    lists, click on the following URLs and follow the instructions:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><a class="ulink" href="http://lists.yoctoproject.org/listinfo/yocto" target="_top">http://lists.yoctoproject.org/listinfo/yocto</a> for a
                            Yocto Project Discussions mailing list.</p></li><li class="listitem"><p><a class="ulink" href="http://lists.yoctoproject.org/listinfo/poky" target="_top">http://lists.yoctoproject.org/listinfo/poky</a> for a
                            Yocto Project Discussions mailing list about the Poky build system.</p></li><li class="listitem"><p><a class="ulink" href="http://lists.yoctoproject.org/listinfo/yocto-announce" target="_top">http://lists.yoctoproject.org/listinfo/yocto-announce</a>
                            for a mailing list to receive official Yocto Project announcements for developments and
                            as well as Yocto Project milestones.</p></li><li class="listitem"><p><a class="ulink" href="http://lists.yoctoproject.org/listinfo" target="_top">http://lists.yoctoproject.org/listinfo</a> for a
                            listing of all public mailing lists on <code class="filename">lists.yoctoproject.org</code>.
                            </p></li></ul></div></li><li class="listitem"><p><span class="emphasis"><em>Internet Relay Chat (IRC):</em></span>
                    Two IRC channels on freenode are available
                    for Yocto Project and Poky discussions: <code class="filename">#yocto</code> and
                    <code class="filename">#poky</code>, respectively.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://o-hand.com" target="_top">OpenedHand</a>:</em></span>
                    The company that initially developed the Poky project, which is the basis
                    for the OpenEmbedded build system used by the Yocto Project.
                    OpenedHand was acquired by Intel Corporation in 2008.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.intel.com/" target="_top">Intel Corporation</a>:</em></span>
                    A multinational semiconductor chip manufacturer company whose Software and
                    Services Group created and supports the Yocto Project.
                    Intel acquired OpenedHand in 2008.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://www.openembedded.org" target="_top">OpenEmbedded</a>:</em></span>
                    The build system used by the Yocto Project.
                    This project is the upstream, generic, embedded distribution from which the Yocto
                    Project derives its build system (Poky) from and to which it contributes.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://developer.berlios.de/projects/bitbake/" target="_top">
                    BitBake</a>:</em></span> The tool used by the OpenEmbedded build system
                    to process project metadata.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    BitBake User Manual:</em></span>
                    A comprehensive guide to the BitBake tool.
                    If you want information on BitBake, see the user manual inculded in the
                    <code class="filename">bitbake/doc/manual</code> directory of the
                    <a class="link" href="#source-directory">Source Directory</a>.</p></li><li class="listitem"><p><span class="emphasis"><em>
                    <a class="ulink" href="http://wiki.qemu.org/Index.html" target="_top">Quick EMUlator (QEMU)</a>:
                    </em></span> An open-source machine emulator and virtualizer.</p></li></ul></div><p>
        </p></div></div>

    <div class="chapter" title="Chapter 2. Getting Started with the Yocto Project"><div class="titlepage"><div><div><h2 class="title"><a id="dev-manual-start"></a>Chapter 2. Getting Started with the Yocto Project</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#introducing-the-yocto-project">2.1. Introducing the Yocto Project</a></span></dt><dt><span class="section"><a href="#getting-setup">2.2. Getting Set Up</a></span></dt><dt><span class="section"><a href="#building-images">2.3. Building Images</a></span></dt><dt><span class="section"><a href="#using-pre-built-binaries-and-qemu">2.4. Using Pre-Built Binaries and QEMU</a></span></dt></dl></div><p>
    This chapter introduces the Yocto Project and gives you an idea of what you need to get started.
    You can find enough information to set up your development host and build or use images for
    hardware supported by the Yocto Project by reading the
    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html" target="_top">Yocto Project Quick Start</a>.
</p><p>
    The remainder of this chapter summarizes what is in the Yocto Project Quick Start and provides
    some higher-level concepts you might want to consider.
</p><div class="section" title="2.1. Introducing the Yocto Project"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="introducing-the-yocto-project"></a>2.1. Introducing the Yocto Project</h2></div></div></div><p>
        The Yocto Project is an open-source collaboration project focused on embedded Linux development.
        The project currently provides a build system, which is
        referred to as the OpenEmbedded build system in the Yocto Project documentation.
        The Yocto Project provides various ancillary tools suitable for the embedded developer
        and also features the Sato reference User Interface, which is optimized for
        stylus driven, low-resolution screens.
    </p><p>
        You can use the OpenEmbedded build system, which uses
        BitBake to develop complete Linux
        images and associated user-space applications for architectures based on ARM, MIPS, PowerPC,
        x86 and x86-64.
        While the Yocto Project does not provide a strict testing framework,
        it does provide or generate for you artifacts that let you perform target-level and
        emulated testing and debugging.
        Additionally, if you are an <span class="trademark">Eclipse</span>™
        IDE user, you can install an Eclipse Yocto Plug-in to allow you to
        develop within that familiar environment.
    </p></div><div class="section" title="2.2. Getting Set Up"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="getting-setup"></a>2.2. Getting Set Up</h2></div></div></div><p>
        Here is what you need to get set up to use the Yocto Project:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Host System:</em></span>  You should have a reasonably current
                Linux-based host system.
                You will have the best results with a recent release of Fedora,
                OpenSUSE, Debian, Ubuntu, or CentOS as these releases are frequently tested against the Yocto Project
                and officially supported.
                For a list of the distributions under validation and their status, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#detailed-supported-distros" target="_top">Supported Linux Distributions</a>" section
                in the Yocto Project Reference Manual and the wiki page at
                <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Distribution_Support" target="_top">Distribution Support</a>.</p><p>
                You should also have about 100 gigabytes of free disk space for building images.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Packages:</em></span>  The OpenEmbedded build system
                requires certain packages exist on your development system (e.g. Python 2.6 or 2.7).
                See "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#packages" target="_top">The Packages</a>"
                section in the Yocto Project Quick Start for the exact package
                requirements and the installation commands to install them
                for the supported distributions.</p></li><li class="listitem"><p><a id="local-yp-release"></a><span class="emphasis"><em>Yocto Project Release:</em></span>
                You need a release of the Yocto Project.
                You set that up with a local <a class="link" href="#source-directory">Source Directory</a>
                one of two ways depending on whether you
                are going to contribute back into the Yocto Project or not.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Regardless of the method you use, this manual refers to the resulting local
                    hierarchical set of files as the "Source Directory."
                </div><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="emphasis"><em>Tarball Extraction:</em></span>  If you are not going to contribute
                        back into the Yocto Project, you can simply download a Yocto Project release you want
                        from the website’s <a class="ulink" href="http://www.yoctoproject.org/download" target="_top">download page</a>.
                        Once you have the tarball, just extract it into a directory of your choice.</p><p>For example, the following command extracts the Yocto Project 1.4
                        release tarball
                        into the current working directory and sets up the local Source Directory
                        with a top-level folder named <code class="filename">poky-tbd-8.0</code>:
                        </p><pre class="literallayout">
     $ tar xfj poky-tbd-8.0.tar.bz2
                        </pre><p>This method does not produce a local Git repository.
                        Instead, you simply end up with a snapshot of the release.</p></li><li class="listitem"><p><span class="emphasis"><em>Git Repository Method:</em></span>  If you are going to be contributing
                        back into the Yocto Project or you simply want to keep up
                        with the latest developments, you should use Git commands to set up a local
                        Git repository of the upstream <code class="filename">poky</code> source repository.
                        Doing so creates a repository with a complete history of changes and allows
                        you to easily submit your changes upstream to the project.
                        Because you cloned the repository, you have access to all the Yocto Project development
                        branches and tag names used in the upstream repository.</p><p>The following transcript shows how to clone the <code class="filename">poky</code>
                        Git repository into the current working directory.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>You can view the Yocto Project Source Repositories at
                        <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a></div><p>
                        The command creates the local repository in a directory named <code class="filename">poky</code>.
                        For information on Git used within the Yocto Project, see the
                        "<a class="link" href="#git" title="3.6. Git">Git</a>" section.
                        </p><pre class="literallayout">
     $ git clone git://git.yoctoproject.org/poky
     Initialized empty Git repository in /home/scottrif/poky/.git/
     remote: Counting objects: 141863, done.
     remote: Compressing objects: 100% (38624/38624), done.
     remote: Total 141863 (delta 99661), reused 141816 (delta 99614)
     Receiving objects: 100% (141863/141863), 76.64 MiB | 126 KiB/s, done.
     Resolving deltas: 100% (99661/99661), done.
                        </pre><p>For another example of how to set up your own local Git repositories, see this
                        <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Transcript:_from_git_checkout_to_meta-intel_BSP" target="_top">
                        wiki page</a>, which describes how to create both <code class="filename">poky</code>
                        and <code class="filename">meta-intel</code> Git repositories.</p></li></ul></div></li><li class="listitem"><p><a id="local-kernel-files"></a><span class="emphasis"><em>Yocto Project Kernel:</em></span>
                If you are going to be making modifications to a supported Yocto Project kernel, you
                need to establish local copies of the source.
                You can find Git repositories of supported Yocto Project Kernels organized under
                "Yocto Linux Kernel" in the Yocto Project Source Repositories at
                <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>.</p><p>This setup can involve creating a bare clone of the Yocto Project kernel and then
                copying that cloned repository.
                You can create the bare clone and the copy of the bare clone anywhere you like.
                For simplicity, it is recommended that you create these structures outside of the
                Source Directory (usually <code class="filename">poky</code>).</p><p>As an example, the following transcript shows how to create the bare clone
                of the <code class="filename">linux-yocto-3.4</code> kernel and then create a copy of
                that clone.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>When you have a local Yocto Project kernel Git repository, you can
                reference that repository rather than the upstream Git repository as
                part of the <code class="filename">clone</code> command.
                Doing so can speed up the process.</div><p>In the following example, the bare clone is named
                <code class="filename">linux-yocto-3.4.git</code>, while the
                copy is named <code class="filename">my-linux-yocto-3.4-work</code>:
                </p><pre class="literallayout">
     $ git clone --bare git://git.yoctoproject.org/linux-yocto-3.4 linux-yocto-3.4.git
     Initialized empty Git repository in /home/scottrif/linux-yocto-3.4.git/
     remote: Counting objects: 2468027, done.
     remote: Compressing objects: 100% (392255/392255), done.
     remote: Total 2468027 (delta 2071693), reused 2448773 (delta 2052498)
     Receiving objects: 100% (2468027/2468027), 530.46 MiB | 129 KiB/s, done.
     Resolving deltas: 100% (2071693/2071693), done.
                </pre><p>Now create a clone of the bare clone just created:
                </p><pre class="literallayout">
     $ git clone linux-yocto-3.4.git my-linux-yocto-3.4-work
     Cloning into 'my-linux-yocto-3.4-work'...
     done.
                </pre></li><li class="listitem"><p><a id="poky-extras-repo"></a><span class="emphasis"><em>
                The <code class="filename">poky-extras</code> Git Repository</em></span>:
                The <code class="filename">poky-extras</code> Git repository contains metadata needed
                only if you are modifying and building the kernel image.
                In particular, it contains the kernel BitBake append (<code class="filename">.bbappend</code>)
                files that you
                edit to point to your locally modified kernel source files and to build the kernel
                image.
                Pointing to these local files is much more efficient than requiring a download of the
                kernel's source files from upstream each time you make changes to the kernel.</p><p>You can find the <code class="filename">poky-extras</code> Git Repository in the
                "Yocto Metadata Layers" area of the Yocto Project Source Repositories at
                <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>.
                It is good practice to create this Git repository inside the Source Directory.</p><p>Following is an example that creates the <code class="filename">poky-extras</code> Git
                repository inside the Source Directory, which is named <code class="filename">poky</code>
                in this case:
                </p><pre class="literallayout">
     $ cd ~/poky
     $ git clone git://git.yoctoproject.org/poky-extras poky-extras
     Initialized empty Git repository in /home/scottrif/poky/poky-extras/.git/
     remote: Counting objects: 618, done.
     remote: Compressing objects: 100% (558/558), done.
     remote: Total 618 (delta 192), reused 307 (delta 39)
     Receiving objects: 100% (618/618), 526.26 KiB | 111 KiB/s, done.
     Resolving deltas: 100% (192/192), done.
                </pre></li><li class="listitem"><p><a id="supported-board-support-packages-(bsps)"></a><span class="emphasis"><em>Supported Board
                Support Packages (BSPs):</em></span>
                The Yocto Project provides a layer called <code class="filename">meta-intel</code> and
                it is maintained in its own separate Git repository.
                The <code class="filename">meta-intel</code> layer contains many supported
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP Layers</a>.</p><p>Similar considerations exist for setting up the <code class="filename">meta-intel</code>
                layer.
                You can get set up for BSP development one of two ways: tarball extraction or
                with a local Git repository.
                It is a good idea to use the same method that you used to set up the Source Directory.
                Regardless of the method you use, the Yocto Project uses the following BSP layer
                naming scheme:
                </p><pre class="literallayout">
     meta-&lt;BSP_name&gt;
                </pre><p>
                where <code class="filename">&lt;BSP_name&gt;</code> is the recognized BSP name.
                Here are some examples:
                </p><pre class="literallayout">
     meta-crownbay
     meta-emenlow
     meta-n450
                </pre><p>
                See the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP Layers</a>"
                section in the Yocto Project Board Support Package (BSP) Developer's Guide for more
                information on BSP Layers.
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="emphasis"><em>Tarball Extraction:</em></span>  You can download any released
                        BSP tarball from the same
                        <a class="ulink" href="http://www.yoctoproject.org/download" target="_top">download site</a> used
                        to get the Yocto Project release.
                        Once you have the tarball, just extract it into a directory of your choice.
                        Again, this method just produces a snapshot of the BSP layer in the form
                        of a hierarchical directory structure.</p></li><li class="listitem"><p><span class="emphasis"><em>Git Repository Method:</em></span>  If you are working
                        with a local Git repository for your Source Directory, you should also use this method
                        to set up the <code class="filename">meta-intel</code> Git repository.
                        You can locate the <code class="filename">meta-intel</code> Git repository in the
                        "Yocto Metadata Layers" area of the Yocto Project Source Repositories at
                        <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>.</p><p>Typically, you set up the <code class="filename">meta-intel</code> Git repository inside
                        the Source Directory.
                        For example, the following transcript shows the steps to clone the
                        <code class="filename">meta-intel</code>
                        Git repository inside the local <code class="filename">poky</code> Git repository.
                        </p><pre class="literallayout">
     $ cd ~/poky
     $ git clone git://git.yoctoproject.org/meta-intel.git
     Initialized empty Git repository in /home/scottrif/poky/meta-intel/.git/
     remote: Counting objects: 3380, done.
     remote: Compressing objects: 100% (2750/2750), done.
     remote: Total 3380 (delta 1689), reused 227 (delta 113)
     Receiving objects: 100% (3380/3380), 1.77 MiB | 128 KiB/s, done.
     Resolving deltas: 100% (1689/1689), done.
                        </pre><p>The same
                        <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Transcript:_from_git_checkout_to_meta-intel_BSP" target="_top">
                        wiki page</a> referenced earlier covers how to
                        set up the <code class="filename">meta-intel</code> Git repository.</p></li></ul></div></li><li class="listitem"><p><span class="emphasis"><em>Eclipse Yocto Plug-in:</em></span>  If you are developing
                applications using the Eclipse Integrated Development Environment (IDE),
                you will need this plug-in.
                See the
                "<a class="link" href="#setting-up-the-eclipse-ide" title="4.2.2.1. Setting Up the Eclipse IDE">Setting up the Eclipse IDE</a>"
                section for more information.</p></li></ul></div><p>
    </p></div><div class="section" title="2.3. Building Images"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="building-images"></a>2.3. Building Images</h2></div></div></div><p>
        The build process creates an entire Linux distribution, including the toolchain, from source.
        For more information on this topic, see the
        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>"
        section in the Yocto Project Quick Start.
    </p><p>
        The build process is as follows:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Make sure you have set up the Source Directory described in the
                previous section.</p></li><li class="listitem"><p>Initialize the build environment by sourcing a build environment
                script.</p></li><li class="listitem"><p>Optionally ensure the <code class="filename">conf/local.conf</code> configuration file,
                which is found in the
                <a class="link" href="#build-directory">Build Directory</a>,
                is set up how you want it.
                This file defines many aspects of the build environment including
                the target machine architecture through the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-MACHINE" target="_top">MACHINE</a></code> variable,
                the development machine's processor use through the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BB_NUMBER_THREADS" target="_top">BB_NUMBER_THREADS</a></code> and
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PARALLEL_MAKE" target="_top">PARALLEL_MAKE</a></code> variables, and
                a centralized tarball download directory through the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-DL_DIR" target="_top">DL_DIR</a></code> variable.</p></li><li class="listitem"><p>Build the image using the <code class="filename">bitbake</code> command.
                If you want information on BitBake, see the user manual inculded in the
                <code class="filename">bitbake/doc/manual</code> directory of the
                <a class="link" href="#source-directory">Source Directory</a>.</p></li><li class="listitem"><p>Run the image either on the actual hardware or using the QEMU
                emulator.</p></li></ol></div><p>
    </p></div><div class="section" title="2.4. Using Pre-Built Binaries and QEMU"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="using-pre-built-binaries-and-qemu"></a>2.4. Using Pre-Built Binaries and QEMU</h2></div></div></div><p>
        Another option you have to get started is to use pre-built binaries.
        The Yocto Project provides many types of binaries with each release.
        See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>"
        chapter in the Yocto Project Reference Manual
        for descriptions of the types of binaries that ship with a Yocto Project
        release.
    </p><p>
        Using a pre-built binary is ideal for developing software applications to run on your
        target hardware.
        To do this, you need to be able to access the appropriate cross-toolchain tarball for
        the architecture on which you are developing.
        If you are using an SDK type image, the image ships with the complete toolchain native to
        the architecture.
        If you are not using an SDK type image, you need to separately download and
        install the stand-alone Yocto Project cross-toolchain tarball.
    </p><p>
        Regardless of the type of image you are using, you need to download the pre-built kernel
        that you will boot in the QEMU emulator and then download and extract the target root
        filesystem for your target machine’s architecture.
        You can get architecture-specific binaries and filesystems from
        <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/machines" target="_top">machines</a>.
        You can get installation scripts for stand-alone toolchains from
        <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/toolchain/" target="_top">toolchains</a>.
        Once you have all your files, you set up the environment to emulate the hardware
        by sourcing an environment setup script.
        Finally, you start the QEMU emulator.
        You can find details on all these steps in the
        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#using-pre-built" target="_top">Using Pre-Built Binaries and QEMU</a>"
        section of the Yocto Project Quick Start.
    </p><p>
        Using QEMU to emulate your hardware can result in speed issues
        depending on the target and host architecture mix.
        For example, using the <code class="filename">qemux86</code> image in the emulator
        on an Intel-based 32-bit (x86) host machine is fast because the target and
        host architectures match.
        On the other hand, using the <code class="filename">qemuarm</code> image on the same Intel-based
        host can be slower.
        But, you still achieve faithful emulation of ARM-specific issues.
    </p><p>
        To speed things up, the QEMU images support using <code class="filename">distcc</code>
        to call a cross-compiler outside the emulated system.
        If you used <code class="filename">runqemu</code> to start QEMU, and the
        <code class="filename">distccd</code> application is present on the host system, any
        BitBake cross-compiling toolchain available from the build system is automatically
        used from within QEMU simply by calling <code class="filename">distcc</code>.
        You can accomplish this by defining the cross-compiler variable
        (e.g. <code class="filename">export CC="distcc"</code>).
        Alternatively, if you are using a suitable SDK image or the appropriate
        stand-alone toolchain is present in <code class="filename">/opt/poky</code>,
        the toolchain is also automatically used.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        Several mechanisms exist that let you connect to the system running on the
        QEMU emulator:
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>QEMU provides a framebuffer interface that makes standard
                consoles available.</p></li><li class="listitem"><p>Generally, headless embedded devices have a serial port.
                If so, you can configure the operating system of the running image
                to use that port to run a console.
                The connection uses standard IP networking.</p></li><li class="listitem"><p>SSH servers exist in some QEMU images.
                The <code class="filename">core-image-sato</code> QEMU image has a Dropbear secure
                shell (ssh) server that runs with the root password disabled.
                The <code class="filename">core-image-basic</code> and <code class="filename">core-image-lsb</code> QEMU images
                have OpenSSH instead of Dropbear.
                Including these SSH servers allow you to use standard <code class="filename">ssh</code> and
                <code class="filename">scp</code> commands.
                The <code class="filename">core-image-minimal</code> QEMU image, however, contains no ssh
                server.</p></li><li class="listitem"><p>You can use a provided, user-space NFS server to boot the QEMU session
                using a local copy of the root filesystem on the host.
                In order to make this connection, you must extract a root filesystem tarball by using the
                <code class="filename">runqemu-extract-sdk</code> command.
                After running the command, you must then point the <code class="filename">runqemu</code>
                script to the extracted directory instead of a root filesystem image file.</p></li></ul></div></div></div></div>

    <div class="chapter" title="Chapter 3. The Yocto Project Open Source Development Environment"><div class="titlepage"><div><div><h2 class="title"><a id="dev-manual-newbie"></a>Chapter 3. The Yocto Project Open Source Development Environment</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#open-source-philosophy">3.1. Open Source Philosophy</a></span></dt><dt><span class="section"><a href="#usingpoky-changes-collaborate">3.2. Using the Yocto Project in a Team Environment</a></span></dt><dt><span class="section"><a href="#yocto-project-repositories">3.3. Yocto Project Source Repositories</a></span></dt><dt><span class="section"><a href="#yocto-project-terms">3.4. Yocto Project Terms</a></span></dt><dt><span class="section"><a href="#licensing">3.5. Licensing</a></span></dt><dt><span class="section"><a href="#git">3.6. Git</a></span></dt><dd><dl><dt><span class="section"><a href="#repositories-tags-and-branches">3.6.1. Repositories, Tags, and Branches</a></span></dt><dt><span class="section"><a href="#basic-commands">3.6.2. Basic Commands</a></span></dt></dl></dd><dt><span class="section"><a href="#workflows">3.7. Workflows</a></span></dt><dt><span class="section"><a href="#tracking-bugs">3.8. Tracking Bugs</a></span></dt><dt><span class="section"><a href="#how-to-submit-a-change">3.9. How to Submit a Change</a></span></dt><dd><dl><dt><span class="section"><a href="#pushing-a-change-upstream">3.9.1. Using Scripts to Push a Change Upstream and Request a Pull</a></span></dt><dt><span class="section"><a href="#submitting-a-patch">3.9.2. Using Email to Submit a Patch</a></span></dt></dl></dd></dl></div><p>
    This chapter helps you understand the Yocto Project as an open source development project.
    In general, working in an open source environment is very different from working in a
    closed, proprietary environment.
    Additionally, the Yocto Project uses specific tools and constructs as part of its development
    environment.
    This chapter specifically addresses open source philosophy, licensing issues, code repositories,
    the open source distributed version control system Git, and best practices using the Yocto Project.
</p><div class="section" title="3.1. Open Source Philosophy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="open-source-philosophy"></a>3.1. Open Source Philosophy</h2></div></div></div><p>
        Open source philosophy is characterized by software development directed by peer production
        and collaboration through an active community of developers.
        Contrast this to the more standard centralized development models used by commercial software
        companies where a finite set of developers produces a product for sale using a defined set
        of procedures that ultimately result in an end product whose architecture and source material
        are closed to the public.
    </p><p>
        Open source projects conceptually have differing concurrent agendas, approaches, and production.
        These facets of the development process can come from anyone in the public (community) that has a
        stake in the software project.
        The open source environment contains new copyright, licensing, domain, and consumer issues
        that differ from the more traditional development environment.
        In an open source environment, the end product, source material, and documentation are
        all available to the public at no cost.
    </p><p>
        A benchmark example of an open source project is the Linux Kernel, which was initially conceived
        and created by Finnish computer science student Linus Torvalds in 1991.
        Conversely, a good example of a non-open source project is the
        <span class="trademark">Windows</span>® family of operating
        systems developed by <span class="trademark">Microsoft</span>® Corporation.
    </p><p>
        Wikipedia has a good historical description of the Open Source Philosophy
        <a class="ulink" href="http://en.wikipedia.org/wiki/Open_source" target="_top">here</a>.
        You can also find helpful information on how to participate in the Linux Community
        <a class="ulink" href="http://ldn.linuxfoundation.org/book/how-participate-linux-community" target="_top">here</a>.
    </p></div><div class="section" title="3.2. Using the Yocto Project in a Team Environment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="usingpoky-changes-collaborate"></a>3.2. Using the Yocto Project in a Team Environment</h2></div></div></div><p>
        It might not be immediately clear how you can use the Yocto Project in a team environment,
        or scale it for a large team of developers.
        The specifics of any situation determine the best solution.
        Granted that the Yocto Project offers immense flexibility regarding this, practices do exist
        that experience has shown work well.
    </p><p>
        The core component of any development effort with the Yocto Project is often an
        automated build and testing framework along with an image generation process.
        You can use these core components to check that the metadata can be built,
        highlight when commits break the build, and provide up-to-date images that
        allow developers to test the end result and use it as a base platform for further
        development.
        Experience shows that buildbot is a good fit for this role.
        What works well is to configure buildbot to make two types of builds:
        incremental and full (from scratch).
        See "<a class="ulink" href="http://autobuilder.yoctoproject.org:8010/" target="_top">Welcome to the buildbot for the Yocto Project</a>"
        for an example implementation that uses buildbot.
    </p><p>
        You can tie an incremental build to a commit hook that triggers the build
        each time a commit is made to the metadata.
        This practice results in useful acid tests that determine whether a given commit
        breaks the build in some serious way.
        Associating a build to a commit can catch a lot of simple errors.
        Furthermore, the tests are fast so developers can get quick feedback on changes.
    </p><p>
        Full builds build and test everything from the ground up.
        These types of builds usually happen at predetermined times like during the
        night when the machine load is low.
    </p><p>
        Most teams have many pieces of software undergoing active development at any given time.
        You can derive large benefits by putting these pieces under the control of a source
        control system that is compatible (i.e. Git or Subversion (SVN)) with the OpenEmbedded
        build system that the Yocto Project uses.
        You can then set the autobuilder to pull the latest revisions of the packages
        and test the latest commits by the builds.
        This practice quickly highlights issues.
        The build system easily supports testing configurations that use both a
        stable known good revision and a floating revision.
        The build system can also take just the changes from specific source control branches.
        This capability allows you to track and test specific changes.
    </p><p>
        Perhaps the hardest part of setting this up is defining the software project or
        the metadata policies that surround the different source control systems.
        Of course circumstances will be different in each case.
        However, this situation reveals one of the Yocto Project's advantages -
        the system itself does not
        force any particular policy on users, unlike a lot of build systems.
        The system allows the best policies to be chosen for the given circumstances.
    </p><p>
        In general, best practices exist that make your work with the Yocto
        Project easier in a team environment.
        This list presents some of these practices you might consider following.
        Of course, you need to understand that you do not have to follow these
        practices and your setup can be totally controlled and customized by
        your team:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use <a class="link" href="#git" title="3.6. Git">Git</a>
                as the source control system.</p></li><li class="listitem"><p>Maintain your metadata in layers that make sense
                for your situation.
                See the "<a class="link" href="#understanding-and-creating-layers" title="5.1. Understanding and Creating Layers">Understanding
                and Creating Layers</a>" section for more information on
                layers.</p></li><li class="listitem"><p>Separate the project's metadata and code by using
                separate Git repositories.
                See the "<a class="link" href="#yocto-project-repositories" title="3.3. Yocto Project Source Repositories">Yocto Project
                Source Repositories</a>" section for information on these
                repositories.
                See the "<a class="link" href="#getting-setup" title="2.2. Getting Set Up">Getting Set Up</a>" section
                for information on how to set up various Yocto Project related
                Git repositories.</p></li><li class="listitem"><p>Set up the directory for the shared state cache
                (<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SSTATE_DIR" target="_top"><code class="filename">SSTATE_DIR</code></a>)
                where they make sense.
                For example, set up the sstate cache for developers using the
                same office and share source directories on the developer's
                machines.</p></li><li class="listitem"><p>Set up an autobuilder and have it populate the
                sstate cache and source directories.</p></li></ul></div><p>
    </p></div><div class="section" title="3.3. Yocto Project Source Repositories"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="yocto-project-repositories"></a>3.3. Yocto Project Source Repositories</h2></div></div></div><p>
        The Yocto Project team maintains complete source repositories for all Yocto Project files
        at <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit/cgit.cgi</a>.
        This web-based source code browser is organized into categories by function such as
        IDE Plugins, Matchbox, Poky, Yocto Linux Kernel, and so forth.
        From the interface, you can click on any particular item in the "Name" column and
        see the URL at the bottom of the page that you need to set up a Git repository for
        that particular item.
        Having a local Git repository of the Source Directory (poky) allows you to
        make changes, contribute to the history, and ultimately enhance the Yocto Project's
        tools, Board Support Packages, and so forth.
    </p><p>
        Conversely, if you are a developer that is not interested in contributing back to the
        Yocto Project, you have the ability to simply download and extract release tarballs
        and use them within the Yocto Project environment.
        All that is required is a particular release of the Yocto Project and
        your application source code.
    </p><p>
        For any supported release of Yocto Project, you can go to the Yocto Project website’s
        <a class="ulink" href="http://www.yoctoproject.org/download" target="_top">download page</a> and get a
        tarball of the release.
        You can also go to this site to download any supported BSP tarballs.
        Unpacking the tarball gives you a hierarchical Source Directory that lets you develop
        using the Yocto Project.
    </p><p>
        Once you are set up through either tarball extraction or a checkout of Git repositories,
        you are ready to develop.
    </p><p>
        In summary, here is where you can get the project files needed for development:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a id="source-repositories"></a><span class="emphasis"><em><a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi" target="_top">Source Repositories:</a></em></span>
                This area contains IDE Plugins, Matchbox, Poky, Poky Support, Tools, Yocto Linux Kernel, and Yocto
                Metadata Layers.
                You can create local copies of Git repositories for each of these areas.</p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 360px"><td align="center"><img src="figures/source-repos.png" align="middle" width="540" /></td></tr></table><p>
                </p></li><li class="listitem"><p><a id="index-downloads"></a><span class="emphasis"><em><a class="ulink" href="http://downloads.yoctoproject.org/releases/" target="_top">Index of /releases:</a></em></span>
                This area contains index releases such as
                the <span class="trademark">Eclipse</span>™
                Yocto Plug-in, miscellaneous support, poky, pseudo, installers for cross-development toolchains,
                and all released versions of Yocto Project in the form of images or tarballs.
                Downloading and extracting these files does not produce a local copy of the
                Git repository but rather a snapshot of a particular release or image.</p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 360px"><td align="center"><img src="figures/index-downloads.png" align="middle" width="540" /></td></tr></table><p>
                </p></li><li class="listitem"><p><span class="emphasis"><em><a class="ulink" href="http://www.yoctoproject.org/download" target="_top">Yocto Project Download Page</a></em></span>
                This page on the Yocto Project website allows you to download any Yocto Project
                release or Board Support Package (BSP) in tarball form.
                The tarballs are similar to those found in the
                <a class="ulink" href="http://downloads.yoctoproject.org/releases/" target="_top">Index of /releases:</a> area.</p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 360px"><td align="center"><img src="figures/yp-download.png" align="middle" width="540" /></td></tr></table><p>
            </p></li></ul></div><p>
    </p></div><div class="section" title="3.4. Yocto Project Terms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="yocto-project-terms"></a>3.4. Yocto Project Terms</h2></div></div></div><p>
        Following is a list of terms and definitions users new to the Yocto Project development
        environment might find helpful.
        While some of these terms are universal, the list includes them just in case:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Append Files:</em></span> Files that append build information to
                a recipe file.
                Append files are known as BitBake append files and <code class="filename">.bbappend</code> files.
                The OpenEmbedded build system expects every append file to have a corresponding and
                underlying recipe (<code class="filename">.bb</code>) file.
                Furthermore, the append file and the underlying recipe must have the same root filename.
                The filenames can differ only in the file type suffix used (e.g.
                <code class="filename">formfactor_0.0.bb</code> and <code class="filename">formfactor_0.0.bbappend</code>).
                </p><p>Information in append files overrides the information in the similarly-named recipe file.
                For an example of an append file in use, see the
                "<a class="link" href="#using-bbappend-files" title="5.1.4. Using .bbappend Files">Using .bbappend Files</a>" section.
                </p></li><li class="listitem"><p><a id="bitbake-term"></a><span class="emphasis"><em>BitBake:</em></span>
                The task executor and scheduler used by
                the OpenEmbedded build system to build images.
                For more information on BitBake, see the BitBake documentation
                in the <code class="filename">bitbake/doc/manual</code> directory of the
                <a class="link" href="#source-directory">Source Directory</a>.</p></li><li class="listitem"><p><a id="build-directory"></a><span class="emphasis"><em>Build Directory:</em></span>
                This term refers to the area used by the OpenEmbedded build system for builds.
                The area is created when you <code class="filename">source</code> the setup
                environment script that is found in the Source Directory
                (i.e. <code class="filename">oe-init-build-env</code>).
                The <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-TOPDIR" target="_top"><code class="filename">TOPDIR</code></a>
                variable points to the Build Directory.</p><p>You have a lot of flexibility when creating the Build Directory.
                Following are some examples that show how to create the directory:
                   </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Create the Build Directory in your current working directory
                            and name it <code class="filename">build</code>.
                            This is the default behavior.
                            </p><pre class="literallayout">
     $ source poky-tbd-8.0/oe-init-build-env
                            </pre></li><li class="listitem"><p>Provide a directory path and specifically name the build
                            directory.
                            This next example creates a Build Directory named <code class="filename">YP-8.0</code>
                            in your home directory within the directory <code class="filename">mybuilds</code>.
                            If <code class="filename">mybuilds</code> does not exist, the directory is created for you:
                            </p><pre class="literallayout">
     $ source poky-tbd-8.0/oe-init-build-env $HOME/mybuilds/YP-8.0
                            </pre></li><li class="listitem"><p>Provide an existing directory to use as the Build Directory.
                            This example uses the existing <code class="filename">mybuilds</code> directory
                            as the Build Directory.
                            </p><pre class="literallayout">
     $ source poky-tbd-8.0/oe-init-build-env $HOME/mybuilds/
                            </pre></li></ul></div><p>
                </p></li><li class="listitem"><p><span class="emphasis"><em>Build System:</em></span> In the context of the Yocto Project
                this term refers to the OpenEmbedded build system used by the project.
                This build system is based on the project known as "Poky."
                For some historical information about Poky, see the
                <a class="link" href="#poky">Poky</a> term further along in this section.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Classes:</em></span> Files that provide for logic encapsulation
                and inheritance allowing commonly used patterns to be defined once and easily used
                in multiple recipes.
                Class files end with the <code class="filename">.bbclass</code> filename extension.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Configuration File:</em></span>  Configuration information in various
                <code class="filename">.conf</code> files provides global definitions of variables.
                The <code class="filename">conf/local.conf</code> configuration file in the
                <a class="link" href="#build-directory">Build Directory</a>
                contains user-defined variables that affect each build.
                The <code class="filename">meta-yocto/conf/distro/poky.conf</code> configuration file
                defines Yocto ‘distro’ configuration
                variables used only when building with this policy.
                Machine configuration files, which
                are located throughout the
                <a class="link" href="#source-directory">Source Directory</a>, define
                variables for specific hardware and are only used when building for that target
                (e.g. the <code class="filename">machine/beagleboard.conf</code> configuration file defines
                variables for the Texas Instruments ARM Cortex-A8 development board).
                Configuration files end with a <code class="filename">.conf</code> filename extension.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Cross-Development Toolchain:</em></span>
                A collection of software development
                tools and utilities that allow you to develop software for targeted architectures.
                This toolchain contains cross-compilers, linkers, and debuggers that are specific to
                an architecture.
                You can use the OpenEmbedded build system to build a cross-development toolchain
                installer that when run installs the toolchain that contains the development tools you
                need to cross-compile and test your software.
                The Yocto Project ships with images that contain installers for
                toolchains for supported architectures as well.
                Sometimes this toolchain is referred to as the meta-toolchain.</p></li><li class="listitem"><p><span class="emphasis"><em>Image:</em></span> An image is the result produced when
                BitBake processes a given collection of recipes and related metadata.
                Images are the binary output that run on specific hardware or QEMU
                and for specific use cases.
                For a list of the supported image types that the Yocto Project provides, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>"
                chapter in the Yocto Project Reference Manual.</p></li><li class="listitem"><p><a id="layer"></a><span class="emphasis"><em>Layer:</em></span> A collection of recipes representing the core,
                a BSP, or an application stack.
                For a discussion on BSP Layers, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP Layers</a>"
                section in the Yocto Project Board Support Packages (BSP) Developer's Guide.</p></li><li class="listitem"><p><a id="metadata"></a><span class="emphasis"><em>Metadata:</em></span> The files that BitBake parses when
                building an image.
                Metadata includes recipes, classes, and configuration files.</p></li><li class="listitem"><p><a id="oe-core"></a><span class="emphasis"><em>OE-Core:</em></span> A core set of metadata originating
                with OpenEmbedded (OE) that is shared between OE and the Yocto Project.
                This metadata is found in the <code class="filename">meta</code> directory of the source
                directory.</p></li><li class="listitem"><p><span class="emphasis"><em>Package:</em></span> In the context of the Yocto Project,
                this term refers to the packaged output from a baked recipe.
                A package is generally the compiled binaries produced from the recipe's sources.
                You ‘bake’ something by running it through BitBake.</p><p>It is worth noting that the term "package" can, in general, have subtle
                meanings.  For example, the packages refered to in the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#packages" target="_top">The Packages</a>" section are
                compiled binaries that when installed add functionality to your Linux
                distribution.</p><p>Another point worth noting is that historically within the Yocto Project,
                recipes were referred to as packages - thus, the existence of several BitBake
                variables that are seemingly mis-named,
                (e.g. <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top"><code class="filename">PR</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PRINC" target="_top"><code class="filename">PRINC</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a>, and
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PE" target="_top"><code class="filename">PE</code></a>).
                </p></li><li class="listitem"><p><a id="poky"></a><span class="emphasis"><em>Poky:</em></span> The term "poky" can mean several things.
                In its most general sense, it is an open-source project that was initially developed
                by OpenedHand.  With OpenedHand, poky was developed off of the existing OpenEmbedded
                build system becoming a build system for embedded images.
                After Intel Corporation acquired OpenedHand, the project poky became the basis for
                the Yocto Project's build system.
                Within the Yocto Project source repositories, poky exists as a separate Git repository
                that can be cloned to yield a local copy on the host system.
                Thus, "poky" can refer to the local copy of the Source Directory used to develop within
                the Yocto Project.</p></li><li class="listitem"><p><span class="emphasis"><em>Recipe:</em></span> A set of instructions for building packages.
                A recipe describes where you get source code and which patches to apply.
                Recipes describe dependencies for libraries or for other recipes, and they
                also contain configuration and compilation options.
                Recipes contain the logical unit of execution, the software/images to build, and
                use the <code class="filename">.bb</code> file extension.</p></li><li class="listitem"><p><a id="source-directory"></a><span class="emphasis"><em>Source Directory:</em></span>
                This term refers to the directory structure created as a result of either downloading
                and unpacking a Yocto Project release tarball or creating a local copy of
                the <code class="filename">poky</code> Git repository
                <code class="filename">git://git.yoctoproject.org/poky</code>.
                Sometimes you might hear the term "poky directory" used to refer to this
                directory structure.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The OpenEmbedded build system does not support file or directory names that
                    contain spaces.
                    Be sure that the Source Directory you use does not contain these types
                    of names.
                </div><p>The Source Directory contains BitBake, Documentation, metadata and
                other files that all support the Yocto Project.
                Consequently, you must have the Source Directory in place on your development
                system in order to do any development using the Yocto Project.</p><p>For tarball expansion, the name of the top-level directory of the Source Directory
                is derived from the Yocto Project release tarball.
                For example, downloading and unpacking <code class="filename">poky-tbd-8.0.tar.bz2</code>
                results in a Source Directory whose top-level folder is named
                <code class="filename">poky-tbd-8.0</code>.
                If you create a local copy of the Git repository, then you can name the repository
                anything you like.
                Throughout much of the documentation, <code class="filename">poky</code> is used as the name of
                the top-level folder of the local copy of the poky Git repository.
                So, for example, cloning the <code class="filename">poky</code> Git repository results in a
                local Git repository whose top-level folder is also named <code class="filename">poky</code>.</p><p>It is important to understand the differences between the Source Directory created
                by unpacking a released tarball as compared to cloning
                <code class="filename">git://git.yoctoproject.org/poky</code>.
                When you unpack a tarball, you have an exact copy of the files based on the time of
                release - a fixed release point.
                Any changes you make to your local files in the Source Directory are on top of the release.
                On the other hand, when you clone the <code class="filename">poky</code> Git repository, you have an
                active development repository.
                In this case, any local changes you make to the Source Directory can be later applied
                to active development branches of the upstream <code class="filename">poky</code> Git
                repository.</p><p>Finally, if you want to track a set of local changes while starting from the same point
                as a release tarball, you can create a local Git branch that
                reflects the exact copy of the files at the time of their release.
                You do this by using Git tags that are part of the repository.</p><p>For more information on concepts related to Git repositories, branches, and tags,
                see the
                "<a class="link" href="#repositories-tags-and-branches" title="3.6.1. Repositories, Tags, and Branches">Repositories, Tags, and Branches</a>"
                section.</p></li><li class="listitem"><p><span class="emphasis"><em>Tasks:</em></span> Arbitrary groups of software Recipes.
                You simply use Tasks to hold recipes that, when built, usually accomplish a single task.
                For example, a task could contain the recipes for a company’s proprietary or value-add software.
                Or, the task could contain the recipes that enable graphics.
                A task is really just another recipe.
                Because task files are recipes, they end with the <code class="filename">.bb</code> filename
                extension.</p></li><li class="listitem"><p><span class="emphasis"><em>Upstream:</em></span> A reference to source code or repositories
                that are not local to the development system but located in a master area that is controlled
                by the maintainer of the source code.
                For example, in order for a developer to work on a particular piece of code, they need to
                first get a copy of it from an "upstream" source.</p></li></ul></div><p>
    </p></div><div class="section" title="3.5. Licensing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="licensing"></a>3.5. Licensing</h2></div></div></div><p>
        Because open source projects are open to the public, they have different licensing structures in place.
        License evolution for both Open Source and Free Software has an interesting history.
        If you are interested in this history, you can find basic information here:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/Open-source_license" target="_top">Open source license history</a>
            </p></li><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/Free_software_license" target="_top">Free software license
            history</a></p></li></ul></div><p>
    </p><p>
        In general, the Yocto Project is broadly licensed under the Massachusetts Institute of Technology
        (MIT) License.
        MIT licensing permits the reuse of software within proprietary software as long as the
        license is distributed with that software.
        MIT is also compatible with the GNU General Public License (GPL).
        Patches to the Yocto Project follow the upstream licensing scheme.
        You can find information on the MIT license at
        <a class="ulink" href="http://www.opensource.org/licenses/mit-license.php" target="_top">here</a>.
        You can find information on the GNU GPL <a class="ulink" href="http://www.opensource.org/licenses/LGPL-3.0" target="_top">
        here</a>.
    </p><p>
        When you build an image using the Yocto Project, the build process uses a
        known list of licenses to ensure compliance.
        You can find this list in the Yocto Project files directory at
        <code class="filename">meta/files/common-licenses</code>.
        Once the build completes, the list of all licenses found and used during that build are
        kept in the
        <a class="link" href="#build-directory">Build Directory</a> at
        <code class="filename">tmp/deploy/images/licenses</code>.
    </p><p>
        If a module requires a license that is not in the base list, the build process
        generates a warning during the build.
        These tools make it easier for a developer to be certain of the licenses with which
        their shipped products must comply.
        However, even with these tools it is still up to the developer to resolve potential licensing issues.
    </p><p>
        The base list of licenses used by the build process is a combination of the Software Package
        Data Exchange (SPDX) list and the Open Source Initiative (OSI) projects.
        <a class="ulink" href="http://spdx.org" target="_top">SPDX Group</a> is a working group of the Linux Foundation
        that maintains a specification
        for a standard format for communicating the components, licenses, and copyrights
        associated with a software package.
        <a class="ulink" href="http://opensource.org" target="_top">OSI</a> is a corporation dedicated to the Open Source
        Definition and the effort for reviewing and approving licenses that are OSD-conformant.
    </p><p>
        You can find a list of the combined SPDX and OSI licenses that the Yocto Project uses
        <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/poky/tree/meta/files/common-licenses" target="_top">here</a>.
        This wiki page discusses the license infrastructure used by the Yocto Project.
    </p><p>
        For information that can help you to maintain compliance with various open source licensing
        during the lifecycle of a product created using the Yocto Project, see the
        "<a class="link" href="#maintaining-open-source-license-compliance-during-your-products-lifecycle" title="5.15. Maintaining Open Source License Compliance During Your Product's Lifecycle">Maintaining Open Source License Compliance During Your Product's Lifecycle</a>" section.
    </p></div><div class="section" title="3.6. Git"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="git"></a>3.6. Git</h2></div></div></div><p>
        The Yocto Project uses Git, which is a free, open source distributed version control system.
        Git supports distributed development, non-linear development, and can handle large projects.
        It is best that you have some fundamental understanding of how Git tracks projects and
        how to work with Git if you are going to use Yocto Project for development.
        This section provides a quick overview of how Git works and provides you with a summary
        of some essential Git commands.
    </p><p>
        For more information on Git, see
        <a class="ulink" href="http://git-scm.com/documentation" target="_top">http://git-scm.com/documentation</a>.
        If you need to download Git, go to <a class="ulink" href="http://git-scm.com/download" target="_top">http://git-scm.com/download</a>.
    </p><div class="section" title="3.6.1. Repositories, Tags, and Branches"><div class="titlepage"><div><div><h3 class="title"><a id="repositories-tags-and-branches"></a>3.6.1. Repositories, Tags, and Branches</h3></div></div></div><p>
            As mentioned earlier in section
            "<a class="link" href="#yocto-project-repositories" title="3.3. Yocto Project Source Repositories">Yocto Project Source Repositories</a>",
            the Yocto Project maintains source repositories at
            <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>.
            If you look at this web-interface of the repositories, each item is a separate
            Git repository.
        </p><p>
            Git repositories use branching techniques that track content change (not files)
            within a project (e.g. a new feature or updated documentation).
            Creating a tree-like structure based on project divergence allows for excellent historical
            information over the life of a project.
            This methodology also allows for an environment in which you can do lots of
            local experimentation on a project as you develop changes or new features.
        </p><p>
            A Git repository represents all development efforts for a given project.
            For example, the Git repository <code class="filename">poky</code> contains all changes
            and developments for Poky over the course of its entire life.
            That means that all changes that make up all releases are captured.
            The repository maintains a complete history of changes.
        </p><p>
            You can create a local copy of any repository by "cloning" it with the Git
            <code class="filename">clone</code> command.
            When you clone a Git repository, you end up with an identical copy of the
            repository on your development system.
            Once you have a local copy of a repository, you can take steps to develop locally.
            For examples on how to clone Git repositories, see the section
            "<a class="link" href="#getting-setup" title="2.2. Getting Set Up">Getting Set Up</a>" earlier in this manual.
        </p><p>
            It is important to understand that Git tracks content change and not files.
            Git uses "branches" to organize different development efforts.
            For example, the <code class="filename">poky</code> repository has
            <code class="filename">bernard</code>,
            <code class="filename">edison</code>, <code class="filename">denzil</code>, <code class="filename">danny</code>
            and <code class="filename">master</code> branches among others.
            You can see all the branches by going to
            <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/poky/" target="_top">http://git.yoctoproject.org/cgit.cgi/poky/</a> and
            clicking on the
            <code class="filename"><a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/poky/refs/heads" target="_top">[...]</a></code>
            link beneath the "Branch" heading.
        </p><p>
            Each of these branches represents a specific area of development.
            The <code class="filename">master</code> branch represents the current or most recent
            development.
            All other branches represent off-shoots of the <code class="filename">master</code>
            branch.
        </p><p>
            When you create a local copy of a Git repository, the copy has the same set
            of branches as the original.
            This means you can use Git to create a local working area (also called a branch)
            that tracks a specific development branch from the source Git repository.
            in other words, you can define your local Git environment to work on any development
            branch in the repository.
            To help illustrate, here is a set of commands that creates a local copy of the
            <code class="filename">poky</code> Git repository and then creates and checks out a local
            Git branch that tracks the Yocto Project 1.4 Release (tbd) development:
            </p><pre class="literallayout">
     $ cd ~
     $ git clone git://git.yoctoproject.org/poky
     $ cd poky
     $ git checkout -b tbd origin/tbd
            </pre><p>
            In this example, the name of the top-level directory of your local Yocto Project
            Files Git repository is <code class="filename">poky</code>,
            and the name of the local working area (or local branch) you have created and checked
            out is <code class="filename">tbd</code>.
            The files in your repository now reflect the same files that are in the
            <code class="filename">tbd</code> development branch of the Yocto Project's
            <code class="filename">poky</code> repository.
            It is important to understand that when you create and checkout a
            local working branch based on a branch name,
            your local environment matches the "tip" of that development branch
            at the time you created your local branch, which could be
            different than the files at the time of a similarly named release.
            In other words, creating and checking out a local branch based on the
            <code class="filename">tbd</code> branch name is not the same as
            cloning and checking out the <code class="filename">master</code> branch.
            Keep reading to see how you create a local snapshot of a Yocto Project Release.
        </p><p>
            Git uses "tags" to mark specific changes in a repository.
            Typically, a tag is used to mark a special point such as the final change
            before a project is released.
            You can see the tags used with the <code class="filename">poky</code> Git repository
            by going to <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/poky/" target="_top">http://git.yoctoproject.org/cgit.cgi/poky/</a> and
            clicking on the
            <code class="filename"><a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/poky/refs/tags" target="_top">[...]</a></code>
            link beneath the "Tag" heading.
        </p><p>
            Some key tags are <code class="filename">bernard-5.0</code>, <code class="filename">denzil-7.0</code>,
            and <code class="filename">tbd-8.0</code>.
            These tags represent Yocto Project releases.
        </p><p>
            When you create a local copy of the Git repository, you also have access to all the
            tags.
            Similar to branches, you can create and checkout a local working Git branch based
            on a tag name.
            When you do this, you get a snapshot of the Git repository that reflects
            the state of the files when the change was made associated with that tag.
            The most common use is to checkout a working branch that matches a specific
            Yocto Project release.
            Here is an example:
            </p><pre class="literallayout">
     $ cd ~
     $ git clone git://git.yoctoproject.org/poky
     $ cd poky
     $ git checkout -b my-tbd-8.0 tbd-8.0
            </pre><p>
            In this example, the name of the top-level directory of your local Yocto Project
            Files Git repository is <code class="filename">poky</code>.
            And, the name of the local branch you have created and checked out is
            <code class="filename">my-tbd-8.0</code>.
            The files in your repository now exactly match the Yocto Project 1.4
            Release tag (<code class="filename">tbd-8.0</code>).
            It is important to understand that when you create and checkout a local
            working branch based on a tag, your environment matches a specific point
            in time and not a development branch.
        </p></div><div class="section" title="3.6.2. Basic Commands"><div class="titlepage"><div><div><h3 class="title"><a id="basic-commands"></a>3.6.2. Basic Commands</h3></div></div></div><p>
            Git has an extensive set of commands that lets you manage changes and perform
            collaboration over the life of a project.
            Conveniently though, you can manage with a small set of basic operations and workflows
            once you understand the basic philosophy behind Git.
            You do not have to be an expert in Git to be functional.
            A good place to look for instruction on a minimal set of Git commands is
            <a class="ulink" href="http://git-scm.com/documentation" target="_top">here</a>.
            If you need to download Git, you can do so
            <a class="ulink" href="http://git-scm.com/download" target="_top">here</a>.
        </p><p>
            If you don’t know much about Git, we suggest you educate
            yourself by visiting the links previously mentioned.
        </p><p>
            The following list briefly describes some basic Git operations as a way to get started.
            As with any set of commands, this list (in most cases) simply shows the base command and
            omits the many arguments they support.
            See the Git documentation for complete descriptions and strategies on how to use these commands:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em><code class="filename">git init</code>:</em></span> Initializes an empty Git repository.
                    You cannot use Git commands unless you have a <code class="filename">.git</code> repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git clone</code>:</em></span> Creates a clone of a repository.
                    During collaboration, this command allows you to create a local repository that is on
                    equal footing with a fellow developer’s repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git add</code>:</em></span> Adds updated file contents
                    to the index that
                    Git uses to track changes.
                    You must add all files that have changed before you can commit them.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git commit</code>:</em></span> Creates a “commit” that documents
                    the changes you made.
                    Commits are used for historical purposes, for determining if a maintainer of a project
                    will allow the change, and for ultimately pushing the change from your local Git repository
                    into the project’s upstream (or master) repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git status</code>:</em></span> Reports any modified files that
                    possibly need to be added and committed.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git checkout &lt;branch-name&gt;</code>:</em></span> Changes
                    your working branch.
                    This command is analogous to “cd”.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git checkout –b &lt;working-branch&gt;</code>:</em></span> Creates
                    a working branch on your local machine where you can isolate work.
                    It is a good idea to use local branches when adding specific features or changes.
                    This way if you don’t like what you have done you can easily get rid of the work.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git branch</code>:</em></span> Reports
                    existing local branches and
                    tells you the branch in which you are currently working.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git branch -D &lt;branch-name&gt;</code>:</em></span>
                    Deletes an existing local branch.
                    You need to be in a local branch other than the one you are deleting
                    in order to delete <code class="filename">&lt;branch-name&gt;</code>.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git pull</code>:</em></span> Retrieves information
                    from an upstream Git
                    repository and places it in your local Git repository.
                    You use this command to make sure you are synchronized with the repository
                    from which you are basing changes (.e.g. the master branch).</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git push</code>:</em></span> Sends all your local changes you
                    have committed to an upstream Git repository (e.g. a contribution repository).
                    The maintainer of the project draws from these repositories when adding your changes to the
                    project’s master repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git merge</code>:</em></span> Combines or adds changes from one
                    local branch of your repository with another branch.
                    When you create a local Git repository, the default branch is named “master”.
                    A typical workflow is to create a temporary branch for isolated work, make and commit your
                    changes, switch to your local master branch, merge the changes from the temporary branch into the
                    local master branch, and then delete the temporary branch.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git cherry-pick</code>:</em></span> Choose and apply specific
                    commits from one branch into another branch.
                    There are times when you might not be able to merge all the changes in one branch with
                    another but need to pick out certain ones.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">gitk</code>:</em></span> Provides a GUI view of the branches
                    and changes in your local Git repository.
                    This command is a good way to graphically see where things have diverged in your
                    local repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git log</code>:</em></span> Reports a history of your changes to the
                    repository.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">git diff</code>:</em></span> Displays line-by-line differences
                    between your local working files and the same files in the upstream Git repository that your
                    branch currently tracks.</p></li></ul></div><p>
        </p></div></div><div class="section" title="3.7. Workflows"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="workflows"></a>3.7. Workflows</h2></div></div></div><p>
        This section provides some overview on workflows using Git.
        In particular, the information covers basic practices that describe roles and actions in a
        collaborative development environment.
        Again, if you are familiar with this type of development environment, you might want to just
        skip this section.
    </p><p>
        The Yocto Project files are maintained using Git in a "master" branch whose Git history
        tracks every change and whose structure provides branches for all diverging functionality.
        Although there is no need to use Git, many open source projects do so.
        For the Yocto Project, a key individual called the "maintainer" is responsible for the "master"
        branch of the Git repository.
        The "master" branch is the “upstream” repository where the final builds of the project occur.
        The maintainer is responsible for allowing changes in from other developers and for
        organizing the underlying branch structure to reflect release strategies and so forth.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>You can see who is the maintainer for Yocto Project files by examining the
        <code class="filename">maintainers.inc</code> file in the Yocto Project
        <code class="filename">meta-yocto/conf/distro/include</code> directory.</div><p>
    </p><p>
        The project also has contribution repositories known as “contrib” areas.
        These areas temporarily hold changes to the project that have been submitted or committed
        by the Yocto Project development team and by community members that contribute to the project.
        The maintainer determines if the changes are qualified to be moved from the "contrib" areas
        into the "master" branch of the Git repository.
    </p><p>
        Developers (including contributing community members) create and maintain cloned repositories
        of the upstream "master" branch.
        These repositories are local to their development platforms and are used to develop changes.
        When a developer is satisfied with a particular feature or change, they “push” the changes
        to the appropriate "contrib" repository.
    </p><p>
        Developers are responsible for keeping their local repository up-to-date with "master".
        They are also responsible for straightening out any conflicts that might arise within files
        that are being worked on simultaneously by more than one person.
        All this work is done locally on the developer’s machine before anything is pushed to a
        "contrib" area and examined at the maintainer’s level.
    </p><p>
        A somewhat formal method exists by which developers commit changes and push them into the
        "contrib" area and subsequently request that the maintainer include them into "master"
        This process is called “submitting a patch” or “submitting a change.”
        For information on submitting patches and changes, see the
        "<a class="link" href="#how-to-submit-a-change" title="3.9. How to Submit a Change">How to Submit a Change</a>" section.
    </p><p>
        To summarize the environment:  we have a single point of entry for changes into the project’s
        "master" branch of the Git repository, which is controlled by the project’s maintainer.
        And, we have a set of developers who independently develop, test, and submit changes
        to "contrib" areas for the maintainer to examine.
        The maintainer then chooses which changes are going to become a permanent part of the project.
    </p><p>
        </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 270px"><td align="left"><img src="figures/git-workflow.png" align="left" height="270" /></td></tr></table><p>
    </p><p>
        While each development environment is unique, there are some best practices or methods
        that help development run smoothly.
        The following list describes some of these practices.
        For more information about Git workflows, see the workflow topics in the
        <a class="ulink" href="http://book.git-scm.com" target="_top">Git Community Book</a>.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Make Small Changes:</em></span> It is best to keep the changes you commit
                small as compared to bundling many disparate changes into a single commit.
                This practice not only keeps things manageable but also allows the maintainer
                to more easily include or refuse changes.</p><p>It is also good practice to leave the repository in a state that allows you to
                still successfully build your project.  In other words, do not commit half of a feature,
                then add the other half in a separate, later commit.
                Each commit should take you from one buildable project state to another
                buildable state.</p></li><li class="listitem"><p><span class="emphasis"><em>Use Branches Liberally:</em></span> It is very easy to create, use, and
                delete local branches in your working Git repository.
                You can name these branches anything you like.
                It is helpful to give them names associated with the particular feature or change
                on which you are working.
                Once you are done with a feature or change, simply discard the branch.</p></li><li class="listitem"><p><span class="emphasis"><em>Merge Changes:</em></span> The <code class="filename">git merge</code>
                command allows you to take the
                changes from one branch and fold them into another branch.
                This process is especially helpful when more than a single developer might be working
                on different parts of the same feature.
                Merging changes also automatically identifies any collisions or “conflicts”
                that might happen as a result of the same lines of code being altered by two different
                developers.</p></li><li class="listitem"><p><span class="emphasis"><em>Manage Branches:</em></span> Because branches are easy to use, you should
                use a system where branches indicate varying levels of code readiness.
                For example, you can have a “work” branch to develop in, a “test” branch where the code or
                change is tested, a “stage” branch where changes are ready to be committed, and so forth.
                As your project develops, you can merge code across the branches to reflect ever-increasing
                stable states of the development.</p></li><li class="listitem"><p><span class="emphasis"><em>Use Push and Pull:</em></span> The push-pull workflow is based on the
                concept of developers “pushing” local commits to a remote repository, which is
                usually a contribution repository.
                This workflow is also based on developers “pulling” known states of the project down into their
                local development repositories.
                The workflow easily allows you to pull changes submitted by other developers from the
                upstream repository into your work area ensuring that you have the most recent software
                on which to develop.
                The Yocto Project has two scripts named <code class="filename">create-pull-request</code> and
                <code class="filename">send-pull-request</code> that ship with the release to facilitate this
                workflow.
                You can find these scripts in the local Yocto Project files Git repository in
                the <code class="filename">scripts</code> directory.</p><p>You can find more information on these scripts in the
                "<a class="link" href="#pushing-a-change-upstream" title="3.9.1. Using Scripts to Push a Change Upstream and Request a Pull">Using
                Scripts to Push a Change Upstream and Request a Pull</a>" section.
                </p></li><li class="listitem"><p><span class="emphasis"><em>Patch Workflow:</em></span> This workflow allows you to notify the
                maintainer through an email that you have a change (or patch) you would like considered
                for the "master" branch of the Git repository.
                To send this type of change you format the patch and then send the email using the Git commands
                <code class="filename">git format-patch</code> and <code class="filename">git send-email</code>.
                You can find information on how to submit changes
                later in this chapter.</p></li></ul></div><p>
    </p></div><div class="section" title="3.8. Tracking Bugs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tracking-bugs"></a>3.8. Tracking Bugs</h2></div></div></div><p>
        The Yocto Project uses its own implementation of
        <a class="ulink" href="http://www.bugzilla.org/about/" target="_top">Bugzilla</a> to track bugs.
        Implementations of Bugzilla work well for group development because they track bugs and code
        changes, can be used to communicate changes and problems with developers, can be used to
        submit and review patches, and can be used to manage quality assurance.
        The home page for the Yocto Project implementation of Bugzilla is
        <a class="ulink" href="http://bugzilla.yoctoproject.org" target="_top">http://bugzilla.yoctoproject.org</a>.
    </p><p>
        Sometimes it is helpful to submit, investigate, or track a bug against the Yocto Project itself
        such as when discovering an issue with some component of the build system that acts contrary
        to the documentation or your expectations.
        Following is the general procedure for submitting a new bug using the Yocto Project
        Bugzilla.
        You can find more information on defect management, bug tracking, and feature request
        processes all accomplished through the Yocto Project Bugzilla on the wiki page
        <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Bugzilla_Configuration_and_Bug_Tracking" target="_top">here</a>.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Always use the Yocto Project implementation of Bugzilla to submit
                a bug.</p></li><li class="listitem"><p>When submitting a new bug, be sure to choose the appropriate
                Classification, Product, and Component for which the issue was found.
                Defects for Yocto Project fall into one of six classifications:  Yocto Project
                Components, Infrastructure, Build System &amp; Metadata, Documentation,
                QA/Testing, and Runtime.
                Each of these Classifications break down into multiple Products and, in some
                cases, multiple Components.</p></li><li class="listitem"><p>Use the bug form to choose the correct Hardware and Architecture
                for which the bug applies.</p></li><li class="listitem"><p>Indicate the Yocto Project version you were using when the issue
                occurred.</p></li><li class="listitem"><p>Be sure to indicate the Severity of the bug.
                Severity communicates how the bug impacted your work.</p></li><li class="listitem"><p>Provide a brief summary of the issue.
                Try to limit your summary to just a line or two and be sure to capture the
                essence of the issue.</p></li><li class="listitem"><p>Provide a detailed description of the issue.
                You should provide as much detail as you can about the context, behavior, output,
                and so forth that surround the issue.
                You can even attach supporting files for output or log by using the "Add an attachment"
                button.</p></li><li class="listitem"><p>Submit the bug by clicking the "Submit Bug" button.</p></li></ol></div><p>
    </p></div><div class="section" title="3.9. How to Submit a Change"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="how-to-submit-a-change"></a>3.9. How to Submit a Change</h2></div></div></div><p>
        Contributions to the Yocto Project and OpenEmbedded are very welcome.
        Because the system is extremely configurable and flexible, we recognize that developers
        will want to extend, configure or optimize it for their specific uses.
        You should send patches to the appropriate mailing list so that they
        can be reviewed and merged by the appropriate maintainer.
        For a list of the Yocto Project and related mailing lists, see the
        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#resources-mailinglist" target="_top">Mailing lists</a>" section in
        the Yocto Project Reference Manual.
    </p><p>
        The following is some guidance on which mailing list to use for what type of change:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>For changes to the core metadata, send your patch to the
                <a class="ulink" href="http://lists.linuxtogo.org/cgi-bin/mailman/listinfo/openembedded-core" target="_top">openembedded-core</a> mailing list.
                For example, a change to anything under the <code class="filename">meta</code> or
                <code class="filename">scripts</code> directories
                should be sent to this mailing list.</p></li><li class="listitem"><p>For changes to BitBake (anything under the <code class="filename">bitbake</code>
                directory), send your patch to the
                <a class="ulink" href="http://lists.linuxtogo.org/cgi-bin/mailman/listinfo/bitbake-devel" target="_top">bitbake-devel</a> mailing list.</p></li><li class="listitem"><p>For changes to <code class="filename">meta-yocto</code>, send your patch to the
                <a class="ulink" href="http://lists.yoctoproject.org/listinfo/poky" target="_top">poky</a> mailing list.</p></li><li class="listitem"><p>For changes to other layers hosted on
                <code class="filename">yoctoproject.org</code> (unless the
                layer's documentation specifies otherwise), tools, and Yocto Project
                documentation, use the
                <a class="ulink" href="http://lists.yoctoproject.org/listinfo/yocto" target="_top">yocto</a> mailing list.</p></li><li class="listitem"><p>For additional recipes that do not fit into the core metadata,
                you should determine which layer the recipe should go into and submit the
                change in the manner recommended by the documentation (e.g. README) supplied
                with the layer. If in doubt, please ask on the
                <a class="ulink" href="http://lists.yoctoproject.org/listinfo/yocto" target="_top">yocto</a> or
                <a class="ulink" href="http://lists.linuxtogo.org/cgi-bin/mailman/listinfo/openembedded-devel" target="_top">openembedded-devel</a>
                mailing lists.</p></li></ul></div><p>
    </p><p>
        When you send a patch, be sure to include a "Signed-off-by:"
        line in the same style as required by the Linux kernel.
        Adding this line signifies that you, the submitter, have agreed to the Developer's Certificate of Origin 1.1
        as follows:
        </p><pre class="literallayout">
     Developer's Certificate of Origin 1.1

     By making a contribution to this project, I certify that:

     (a) The contribution was created in whole or in part by me and I
         have the right to submit it under the open source license
         indicated in the file; or

     (b) The contribution is based upon previous work that, to the best
         of my knowledge, is covered under an appropriate open source
         license and I have the right under that license to submit that
         work with modifications, whether created in whole or in part
         by me, under the same open source license (unless I am
         permitted to submit under a different license), as indicated
         in the file; or

     (c) The contribution was provided directly to me by some other
         person who certified (a), (b) or (c) and I have not modified
         it.

     (d) I understand and agree that this project and the contribution
         are public and that a record of the contribution (including all
         personal information I submit with it, including my sign-off) is
         maintained indefinitely and may be redistributed consistent with
         this project or the open source license(s) involved.
        </pre><p>
    </p><p>
        In a collaborative environment, it is necessary to have some sort of standard
        or method through which you submit changes.
        Otherwise, things could get quite chaotic.
        One general practice to follow is to make small, controlled changes.
        Keeping changes small and isolated aids review, makes merging/rebasing easier
        and keeps the change history clean when anyone needs to refer to it in future.
    </p><p>
        When you make a commit, you must follow certain standards established by the
        OpenEmbedded and Yocto Project development teams.
        For each commit, you must provide a single-line summary of the change and you
        should almost always provide a more detailed description of what you did (i.e.
        the body of the commit message).
        The only exceptions for not providing a detailed description would be if your
        change is a simple, self-explanatory change that needs no further description
        beyond the summary.
        Here are the guidelines for composing a commit message:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Provide a single-line, short summary of the change.
                This summary is typically viewable in the "shortlist" of changes.
                Thus, providing something short and descriptive that gives the reader
                a summary of the change is useful when viewing a list of many commits.
                This should be prefixed by the recipe name (if changing a recipe), or
                else the short form path to the file being changed.
                </p></li><li class="listitem"><p>For the body of the commit message, provide detailed information
                that describes what you changed, why you made the change, and the approach
                you used. It may also be helpful if you mention how you tested the change.
                Provide as much detail as you can in the body of the commit message.
                </p></li><li class="listitem"><p>If the change addresses a specific bug or issue that is
                associated with a bug-tracking ID, include a reference to that ID in
                your detailed description.
                For example, the Yocto Project uses a specific convention for bug
                references - any commit that addresses a specific bug should include the
                bug ID in the description (typically at the beginning) as follows:
                </p><pre class="literallayout">
     [YOCTO #&lt;bug-id&gt;]

     &lt;detailed description of change&gt;
                </pre></li></ul></div><p>
    </p><p>
        You can find more guidance on creating well-formed commit messages at this OpenEmbedded
        wiki page:
        <a class="ulink" href="http://www.openembedded.org/wiki/Commit_Patch_Message_Guidelines" target="_top">http://www.openembedded.org/wiki/Commit_Patch_Message_Guidelines</a>.
    </p><p>
        Following are general instructions for both pushing changes upstream and for submitting
        changes as patches.
    </p><div class="section" title="3.9.1. Using Scripts to Push a Change Upstream and Request a Pull"><div class="titlepage"><div><div><h3 class="title"><a id="pushing-a-change-upstream"></a>3.9.1. Using Scripts to Push a Change Upstream and Request a Pull</h3></div></div></div><p>
            The basic flow for pushing a change to an upstream "contrib" Git repository is as follows:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Make your changes in your local Git repository.</p></li><li class="listitem"><p>Stage your changes by using the <code class="filename">git add</code>
                    command on each file you changed.</p></li><li class="listitem"><p>Commit the change by using the <code class="filename">git commit</code>
                    command and push it to the "contrib" repository.
                    Be sure to provide a commit message that follows the project’s commit message standards
                    as described earlier.</p></li><li class="listitem"><p>Notify the maintainer that you have pushed a change by making a pull
                    request.
                    The Yocto Project provides two scripts that conveniently let you generate and send
                    pull requests to the Yocto Project.
                    These scripts are <code class="filename">create-pull-request</code> and
                    <code class="filename">send-pull-request</code>.
                    You can find these scripts in the <code class="filename">scripts</code> directory
                    within the <a class="link" href="#source-directory">Source Directory</a>.</p><p>Using these scripts correctly formats the requests without introducing any
                    whitespace or HTML formatting.
                    The maintainer that receives your patches needs to be able to save and apply them
                    directly from your emails.
                    Using these scripts is the preferred method for sending patches.</p><p>For help on using these scripts, simply provide the
                    <code class="filename">-h</code> argument as follows:
                    </p><pre class="literallayout">
     $ ~/poky/scripts/create-pull-request -h
     $ ~/poky/scripts/send-pull-request -h
                    </pre></li></ul></div><p>
        </p><p>
            You can find general Git information on how to push a change upstream in the
            <a class="ulink" href="http://book.git-scm.com/3_distributed_workflows.html" target="_top">Git Community Book</a>.
        </p></div><div class="section" title="3.9.2. Using Email to Submit a Patch"><div class="titlepage"><div><div><h3 class="title"><a id="submitting-a-patch"></a>3.9.2. Using Email to Submit a Patch</h3></div></div></div><p>
            You can submit patches without using the <code class="filename">create-pull-request</code> and
            <code class="filename">send-pull-request</code> scripts described in the previous section.
            Keep in mind, the preferred method is to use the scripts, however.
        </p><p>
            Depending on the components changed, you need to submit the email to a specific
            mailing list.
            For some guidance on which mailing list to use, see the list in the
            "<a class="link" href="#how-to-submit-a-change" title="3.9. How to Submit a Change">How to Submit a Change</a>" section
            earlier in this manual.
            For a description of the available mailing lists, see
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#resources-mailinglist" target="_top">Mailing Lists</a>"
            section in the Yocto Project Reference Manual.
        </p><p>
            Here is the general procedure on how to submit a patch through email without using the
            scripts:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Make your changes in your local Git repository.</p></li><li class="listitem"><p>Stage your changes by using the <code class="filename">git add</code>
                    command on each file you changed.</p></li><li class="listitem"><p>Commit the change by using the
                    <code class="filename">git commit --signoff</code> command.
                    Using the <code class="filename">--signoff</code> option identifies you as the person
                    making the change and also satisfies the Developer's Certificate of
                    Origin (DCO) shown earlier.</p><p>When you form a commit you must follow certain standards established by the
                    Yocto Project development team.
                    See the earlier section
                    "<a class="link" href="#how-to-submit-a-change" title="3.9. How to Submit a Change">How to Submit a Change</a>"
                    for Yocto Project commit message standards.</p></li><li class="listitem"><p>Format the commit into an email message.
                    To format commits, use the <code class="filename">git format-patch</code> command.
                    When you provide the command, you must include a revision list or a number of patches
                    as part of the command.
                    For example, these two commands each take the most recent single commit and
                    format it as an email message in the current directory:
                    </p><pre class="literallayout">
     $ git format-patch -1
     $ git format-patch HEAD~
                    </pre><p>After the command is run, the current directory contains a
                    numbered <code class="filename">.patch</code> file for the commit.</p><p>If you provide several commits as part of the command,
                    the <code class="filename">git format-patch</code> command produces a numbered
                    series of files in the current directory – one for each commit.
                    If you have more than one patch, you should also use the
                    <code class="filename">--cover</code> option with the command, which generates a
                    cover letter as the first "patch" in the series.
                    You can then edit the cover letter to provide a description for
                    the series of patches.
                    For information on the <code class="filename">git format-patch</code> command,
                    see <code class="filename">GIT_FORMAT_PATCH(1)</code> displayed using the
                    <code class="filename">man git-format-patch</code> command.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>If you are or will be a frequent contributor to the Yocto Project
                    or to OpenEmbedded, you might consider requesting a contrib area and the
                    necessary associated rights.</div></li><li class="listitem"><p>Import the files into your mail client by using the
                    <code class="filename">git send-email</code> command.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>In order to use <code class="filename">git send-email</code>, you must have the
                    the proper Git packages installed.
                    For Ubuntu and Fedora the package is <code class="filename">git-email</code>.</div><p>The <code class="filename">git send-email</code> command sends email by using a local
                    or remote Mail Transport Agent (MTA) such as
                    <code class="filename">msmtp</code>, <code class="filename">sendmail</code>, or through a direct
                    <code class="filename">smtp</code> configuration in your Git <code class="filename">config</code>
                    file.
                    If you are submitting patches through email only, it is very important
                    that you submit them without any whitespace or HTML formatting that
                    either you or your mailer introduces.
                    The maintainer that receives your patches needs to be able to save and
                    apply them directly from your emails.
                    A good way to verify that what you are sending will be applicable by the
                    maintainer is to do a dry run and send them to yourself and then
                    save and apply them as the maintainer would.</p><p>The <code class="filename">git send-email</code> command is the preferred method
                    for sending your patches since there is no risk of compromising whitespace
                    in the body of the message, which can occur when you use your own mail client.
                    The command also has several options that let you
                    specify recipients and perform further editing of the email message.
                    For information on how to use the <code class="filename">git send-email</code> command,
                    use the <code class="filename">man git-send-email</code> command.</p></li></ul></div><p>
        </p></div></div></div>

    <div class="chapter" title="Chapter 4. Common Development Models"><div class="titlepage"><div><div><h2 class="title"><a id="dev-manual-model"></a>Chapter 4. Common Development Models</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#system-development-model">4.1. System Development Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#developing-a-board-support-package-bsp">4.1.1. Developing a Board Support Package (BSP)</a></span></dt><dt><span class="section"><a href="#modifying-the-kernel">4.1.2. Modifying the Kernel</a></span></dt></dl></dd><dt><span class="section"><a href="#application-development-workflow">4.2. Application Development Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="#workflow-using-the-adt-and-eclipse">4.2.1. Workflow Using the ADT and <span class="trademark">Eclipse</span>™</a></span></dt><dt><span class="section"><a href="#adt-eclipse">4.2.2. Working Within Eclipse</a></span></dt><dt><span class="section"><a href="#workflow-using-stand-alone-cross-development-toolchains">4.2.3. Workflow Using Stand-alone Cross-development Toolchains</a></span></dt></dl></dd><dt><span class="section"><a href="#modifying-temporary-source-code">4.3. Modifying Temporary Source Code</a></span></dt><dd><dl><dt><span class="section"><a href="#finding-the-temporary-source-code">4.3.1. Finding the Temporary Source Code</a></span></dt><dt><span class="section"><a href="#using-a-quilt-workflow">4.3.2. Using a Quilt Workflow</a></span></dt><dt><span class="section"><a href="#using-a-git-workflow">4.3.3. Using a Git Workflow</a></span></dt></dl></dd><dt><span class="section"><a href="#image-development-using-hob">4.4. Image Development Using Hob</a></span></dt><dt><span class="section"><a href="#platdev-appdev-devshell">4.5. Using a Development Shell</a></span></dt></dl></div><p>
    Many development models exist for which you can use the Yocto Project.
    This chapter overviews simple methods that use tools provided by the
    Yocto Project:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>System Development:</em></span>
             System Development covers Board Support Package (BSP) development and kernel
             modification or configuration.
             For an example on how to create a BSP, see the
             "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#creating-a-new-bsp-layer-using-the-yocto-bsp-script" target="_top">Creating a New BSP Layer Using the yocto-bsp Script</a>"
             section in the Yocto Project Board Support Package (BSP) Developer's Guide.
             </p></li><li class="listitem"><p><span class="emphasis"><em>User Application Development:</em></span>
             User Application Development covers development of applications that you intend
             to run on some target hardware.
             For information on how to set up your host development system for user-space
             application development, see the
             <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html" target="_top">Yocto Project Application Developer's Guide</a>.
             For a simple example of user-space application development using the
             <span class="trademark">Eclipse</span>™ IDE, see the
             "<a class="link" href="#application-development-workflow" title="4.2. Application Development Workflow">Application
             Development Workflow</a>" section.
             </p></li><li class="listitem"><p><span class="emphasis"><em>Temporary Source Code Modification:</em></span>
             Direct modification of temporary source code is a convenient development model
             to quickly iterate and develop towards a solution.
             Once the solution has been implemented, you should of course take steps to
             get the changes upstream and applied in the affected recipes.</p></li><li class="listitem"><p><span class="emphasis"><em>Image Development using Hob:</em></span>
             You can use the <a class="ulink" href="http://www.yoctoproject.org/projects/hob" target="_top">Hob</a> to build
             custom operating system images within the build environment.
             Hob provides an efficient interface to the OpenEmbedded build system.</p></li><li class="listitem"><p><span class="emphasis"><em>Using a Development Shell:</em></span>
             You can use a <code class="filename">devshell</code> to efficiently debug commands or simply
             edit packages.
             Working inside a development shell is a quick way to set up the OpenEmbedded build
             environment to work on parts of a project.</p></li></ul></div><p>
</p><div class="section" title="4.1. System Development Workflow"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="system-development-model"></a>4.1. System Development Workflow</h2></div></div></div><p>
        System development involves modification or creation of an image that you want to run on
        a specific hardware target.
        Usually, when you want to create an image that runs on embedded hardware, the image does
        not require the same number of features that a full-fledged Linux distribution provides.
        Thus, you can create a much smaller image that is designed to use only the
        features for your particular hardware.
    </p><p>
        To help you understand how system development works in the Yocto Project, this section
        covers two types of image development:  BSP creation and kernel modification or
        configuration.
    </p><div class="section" title="4.1.1. Developing a Board Support Package (BSP)"><div class="titlepage"><div><div><h3 class="title"><a id="developing-a-board-support-package-bsp"></a>4.1.1. Developing a Board Support Package (BSP)</h3></div></div></div><p>
            A BSP is a package of recipes that, when applied during a build, results in
            an image that you can run on a particular board.
            Thus, the package when compiled into the new image, supports the operation of the board.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            For a brief list of terms used when describing the development process in the Yocto Project,
            see the "<a class="link" href="#yocto-project-terms" title="3.4. Yocto Project Terms">Yocto Project Terms</a>" section.
        </div><p>
            The remainder of this section presents the basic steps used to create a BSP
            using the Yocto Project's
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#using-the-yocto-projects-bsp-tools" target="_top">BSP Tools</a>.
            For an example that shows how to create a new layer using the tools, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#creating-a-new-bsp-layer-using-the-yocto-bsp-script" target="_top">Creating a New BSP Layer Using the yocto-bsp Script</a>"
             section in the Yocto Project Board Support Package (BSP) Developer's Guide.
        </p><p>
            The following illustration and list summarize the BSP creation general workflow.
        </p><p>
            </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 630px"><td align="center"><img src="figures/bsp-dev-flow.png" align="middle" width="540" /></td></tr></table><p>
        </p><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Set up your host development system to support
                    development using the Yocto Project</em></span>:  See the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#the-linux-distro" target="_top">The Linux Distributions</a>"
                    and the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#packages" target="_top">The Packages</a>" sections both
                    in the Yocto Project Quick Start for requirements.</p></li><li class="listitem"><p><span class="emphasis"><em>Establish a local copy of the project files on your
                    system</em></span>:  You need this <a class="link" href="#source-directory">Source
                    Directory</a> available on your host system.
                    Having these files on your system gives you access to the build
                    process and to the tools you need.
                    For information on how to set up the
                    <a class="link" href="#source-directory">Source Directory</a>, see the
                    "<a class="link" href="#getting-setup" title="2.2. Getting Set Up">Getting Setup</a>" section.</p></li><li class="listitem"><p><span class="emphasis"><em>Establish the <code class="filename">meta-intel</code>
                    repository on your system</em></span>:  Having local copies of the
                    supported BSP layers on your system gives you access to the build
                    process and to the tools you need for creating a BSP.
                    For information on how to get these files, see the
                    "<a class="link" href="#getting-setup" title="2.2. Getting Set Up">Getting Setup</a>" section.</p></li><li class="listitem"><p><span class="emphasis"><em>Create your own BSP layer using the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#creating-a-new-bsp-layer-using-the-yocto-bsp-script" target="_top"><code class="filename">yocto-bsp</code></a> script</em></span>:
                    Layers are ideal for
                    isolating and storing work for a given piece of hardware.
                    A layer is really just a location or area in which you place the recipes for your BSP.
                    In fact, a BSP is, in itself, a special type of layer.
                    The simplest way to create a new BSP layer that is compliant with the
                    Yocto Project is to use the <code class="filename">yocto-bsp</code> script.
                    For information about that script, see the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#creating-a-new-bsp-layer-using-the-yocto-bsp-script" target="_top">Creating a New BSP Layer Using the yocto-bsp Script</a>"
                    section in the Yocto Project Board Support (BSP) Developer's Guide.
                    </p><p>
                    Another example that illustrates a layer is an application.
                    Suppose you are creating an application that has library or other dependencies in
                    order for it to compile and run.
                    The layer, in this case, would be where all the recipes that define those dependencies
                    are kept.
                    The key point for a layer is that it is an isolated area that contains
                    all the relevant information for the project that the OpenEmbedded build
                    system knows about.
                    For more information on layers, see the
                    "<a class="link" href="#understanding-and-creating-layers" title="5.1. Understanding and Creating Layers">Understanding and Creating Layers</a>"
                    section.
                    For more information on BSP layers, see the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP Layers</a>" section in the
                    Yocto Project Board Support Package (BSP) Developer's Guide.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Four BSPs exist that are part of the
                    Yocto Project release: <code class="filename">atom-pc</code>, <code class="filename">beagleboard</code>,
                    <code class="filename">mpc8315e</code>, and <code class="filename">routerstationpro</code>.
                    The recipes and configurations for these four BSPs are located and dispersed
                    within the <a class="link" href="#source-directory">Source Directory</a>.
                    On the other hand, BSP layers for Cedar Trail, Chief River, Crown Bay,
                    Crystal Forest, Emenlow, Fish River, Fish River 2, Jasper Forest, N450,
                    Romley, sys940x, Sugar Bay, and tlk exist in their own separate layers
                    within the larger <code class="filename">meta-intel</code> layer.</div><p>When you set up a layer for a new BSP, you should follow a standard layout.
                    This layout is described in the section
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-filelayout" target="_top">Example Filesystem Layout</a>"
                    section of the Board Support Package (BSP) Development Guide.
                    In the standard layout, you will notice a suggested structure for recipes and
                    configuration information.
                    You can see the standard layout for a BSP by examining
                    any supported BSP found in the <code class="filename">meta-intel</code> layer inside
                    the Source Directory.</p></li><li class="listitem"><p><span class="emphasis"><em>Make configuration changes to your new BSP
                    layer</em></span>:  The standard BSP layer structure organizes the files you need
                    to edit in <code class="filename">conf</code> and several <code class="filename">recipes-*</code>
                    directories within the BSP layer.
                    Configuration changes identify where your new layer is on the local system
                    and identify which kernel you are going to use.
                    When you run the <code class="filename">yocto-bsp</code> script you are able to interactively
                    configure many things for the BSP (e.g. keyboard, touchscreen, and so forth).
                    </p></li><li class="listitem"><p><span class="emphasis"><em>Make recipe changes to your new BSP layer</em></span>:  Recipe
                    changes include altering recipes (<code class="filename">.bb</code> files), removing
                    recipes you don't use, and adding new recipes or append files
                    (<code class="filename">.bbappend</code>) that you need to support your hardware.
                    </p></li><li class="listitem"><p><span class="emphasis"><em>Prepare for the build</em></span>:  Once you have made all the
                    changes to your BSP layer, there remains a few things
                    you need to do for the OpenEmbedded build system in order for it to create your image.
                    You need to get the build environment ready by sourcing an environment setup script
                    and you need to be sure two key configuration files are configured appropriately:
                    the <code class="filename">conf/local.conf</code> and the
                    <code class="filename">conf/bblayers.conf</code> file.
                    You must make the OpenEmbedded build system aware of your new layer.
                    See the
                    "<a class="link" href="#enabling-your-layer" title="5.1.3. Enabling Your Layer">Enabling Your Layer</a>" section
                    for information on how to let the build system know about your new layer.</p><p>The entire process for building an image is overviewed in the section
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>" section
                    of the Yocto Project Quick Start.
                    You might want to reference this information.</p></li><li class="listitem"><p><span class="emphasis"><em>Build the image</em></span>:  The OpenEmbedded build system
                    uses the BitBake tool to build images based on the type of image you want to create.
                    You can find more information about BitBake in the user manual, which is found in the
                    <code class="filename">bitbake/doc/manual</code> directory of the
                    <a class="link" href="#source-directory">Source Directory</a>.</p><p>The build process supports several types of images to satisfy different needs.
                    See the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>" chapter
                    in the Yocto Project Reference Manual for information on
                    supported images.</p></li></ol></div><p>
        </p><p>
            You can view a video presentation on "Building Custom Embedded Images with Yocto"
            at <a class="ulink" href="http://free-electrons.com/blog/elc-2011-videos" target="_top">Free Electrons</a>.
            You can also find supplemental information in
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html" target="_top">
            The Board Support Package (BSP) Development Guide</a>.
            Finally, there is wiki page write up of the example also located
            <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Transcript:_creating_one_generic_Atom_BSP_from_another" target="_top">
            here</a> that you might find helpful.
       </p></div><div class="section" title="4.1.2. Modifying the Kernel"><div class="titlepage"><div><div><h3 class="title"><a id="modifying-the-kernel"></a>4.1.2. <a id="kernel-spot"></a>Modifying the Kernel</h3></div></div></div><p>
            Kernel modification involves changing the Yocto Project kernel, which could involve changing
            configuration options as well as adding new kernel recipes.
            Configuration changes can be added in the form of configuration fragments, while recipe
            modification comes through the kernel's <code class="filename">recipes-kernel</code> area
            in a kernel layer you create.
        </p><p>
            The remainder of this section presents a high-level overview of the Yocto Project
            kernel architecture and the steps to modify the kernel.
            For a complete discussion of the kernel, see the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/kernel-manual/kernel-manual.html" target="_top">Yocto Project Kernel Architecture and Use Manual</a>.
            You can reference the
            "<a class="link" href="#patching-the-kernel" title="5.7. Patching the Kernel">Patching the Kernel</a>" section
            for an example that changes the source code of the kernel.
            For information on how to configure the kernel, see the
            "<a class="link" href="#configuring-the-kernel" title="5.6. Configuring the Kernel">Configuring the Kernel</a>" section.
        </p><div class="section" title="4.1.2.1. Kernel Overview"><div class="titlepage"><div><div><h4 class="title"><a id="kernel-overview"></a>4.1.2.1. Kernel Overview</h4></div></div></div><p>
                Traditionally, when one thinks of a patched kernel, they think of a base kernel
                source tree and a fixed structure that contains kernel patches.
                The Yocto Project, however, employs mechanisms, that in a sense, result in a kernel source
                generator.
                By the end of this section, this analogy will become clearer.
            </p><p>
                You can find a web interface to the Yocto Project kernel source repositories at
                <a class="ulink" href="http://git.yoctoproject.org" target="_top">http://git.yoctoproject.org</a>.
                If you look at the interface, you will see to the left a grouping of
                Git repositories titled "Yocto Linux Kernel."
                Within this group, you will find several kernels supported by
                the Yocto Project:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-2.6.34</code></em></span> - The
                    stable Yocto Project kernel that is based on the Linux 2.6.34 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-2.6.37</code></em></span> - The
                    stable Yocto Project kernel that is based on the Linux 2.6.37 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-3.0</code></em></span> - The stable
                    Yocto Project kernel that is based on the Linux 3.0 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-3.0-1.1.x</code></em></span> - The
                    stable Yocto Project kernel to use with the Yocto Project Release 1.1.x. This kernel
                    is based on the Linux 3.0 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-3.2</code></em></span> - The
                    stable Yocto Project kernel to use with the Yocto Project Release 1.2. This kernel
                    is based on the Linux 3.2 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-3.4</code></em></span> - The
                    stable Yocto Project kernel to use with the Yocto Project Release 1.3. This kernel
                    is based on the Linux 3.4 released kernel.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">linux-yocto-dev</code></em></span> - A development
                    kernel based on the latest upstream release candidate available.</p></li></ul></div><p>
            </p><p>
                The kernels are maintained using the Git revision control system
                that structures them using the familiar "tree", "branch", and "leaf" scheme.
                Branches represent diversions from general code to more specific code, while leaves
                represent the end-points for a complete and unique kernel whose source files
                when gathered from the root of the tree to the leaf accumulate to create the files
                necessary for a specific piece of hardware and its features.
                The following figure displays this concept:
            </p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 540px"><td align="center"><img src="figures/kernel-overview-1.png" align="middle" /></td></tr></table><p>
            </p><p>

            </p><p>
                Within the figure, the "Kernel.org Branch Point" represents the point in the tree
                where a supported base kernel is modified from the Linux kernel.
                For example, this could be the branch point for the <code class="filename">linux-yocto-3.0</code>
                kernel.
                Thus, everything further to the right in the structure is based on the
                <code class="filename">linux-yocto-3.0</code> kernel.
                Branch points to right in the figure represent where the
                <code class="filename">linux-yocto-3.0</code> kernel is modified for specific hardware
                or types of kernels, such as real-time kernels.
                Each leaf thus represents the end-point for a kernel designed to run on a specific
                targeted device.
            </p><p>

            </p><p>
                The overall result is a Git-maintained repository from which all the supported
                kernel types can be derived for all the supported devices.
                A big advantage to this scheme is the sharing of common features by keeping them in
                "larger" branches within the tree.
                This practice eliminates redundant storage of similar features shared among kernels.
            </p><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                Keep in mind the figure does not take into account all the supported Yocto
                Project kernel types, but rather shows a single generic kernel just for conceptual purposes.
                Also keep in mind that this structure represents the Yocto Project source repositories
                that are either pulled from during the build or established on the host development system
                prior to the build by either cloning a particular kernel's Git repository or by
                downloading and unpacking a tarball.
            </div><p>

            </p><p>
                Upstream storage of all the available kernel source code is one thing, while
                representing and using the code on your host development system is another.
                Conceptually, you can think of the kernel source repositories as all the
                source files necessary for all the supported kernels.
                As a developer, you are just interested in the source files for the kernel on
                on which you are working.
                And, furthermore, you need them available on your host system.
            </p><p>

            </p><p>
                Kernel source code is available on your host system a couple of different
                ways.
                If you are working in the kernel all the time, you probably would want
                to set up your own local Git repository of the kernel tree.
                If you just need to make some patches to the kernel, you can get at
                temporary kernel source files extracted and used during the OpenEmbedded
                build system.
                We will just talk about working with the temporary source code.
            </p><p>

            </p><p>
                What happens during the build?
                When you build the kernel on your development system, all files needed for the build
                are taken from the source repositories pointed to by the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a> variable
                and gathered in a temporary work area
                where they are subsequently used to create the unique kernel.
                Thus, in a sense, the process constructs a local source tree specific to your
                kernel to generate the new kernel image - a source generator if you will.
            </p><p>
                The following figure shows the temporary file structure
                created on your host system when the build occurs.
                This
                <a class="link" href="#build-directory">Build Directory</a> contains all the
                source files used during the build.
            </p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 450px"><td align="center"><img src="figures/kernel-overview-2-generic.png" align="middle" /></td></tr></table><p>
            </p><p>
                Again, for a complete discussion of the Yocto Project kernel's architecture and its
                branching strategy, see the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/kernel-manual/kernel-manual.html" target="_top">Yocto Project Kernel Architecture and Use Manual</a>.
                You can also reference the
                "<a class="link" href="#patching-the-kernel" title="5.7. Patching the Kernel">Patching the Kernel</a>"
                section for a detailed example that modifies the kernel.
            </p></div><div class="section" title="4.1.2.2. Kernel Modification Workflow"><div class="titlepage"><div><div><h4 class="title"><a id="kernel-modification-workflow"></a>4.1.2.2. Kernel Modification Workflow</h4></div></div></div><p>
                This illustration and the following list summarizes the kernel modification general workflow.
            </p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 450px"><td align="center"><img src="figures/kernel-dev-flow.png" align="middle" width="540" /></td></tr></table><p>
            </p><p>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Set up your host development system to support
                        development using the Yocto Project</em></span>:  See
                        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#the-linux-distro" target="_top">The Linux Distributions</a>" and
                        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#packages" target="_top">The Packages</a>" sections both
                        in the Yocto Project Quick Start for requirements.</p></li><li class="listitem"><p><span class="emphasis"><em>Establish a local copy of project files on your
                        system</em></span>:  Having the <a class="link" href="#source-directory">Source
                        Directory</a> on your system gives you access to the build process and tools
                        you need.
                        For information on how to get these files, see the bulleted item
                        "<a class="link" href="#local-yp-release">Yocto Project Release</a>" earlier in this manual.
                        </p></li><li class="listitem"><p><span class="emphasis"><em>Establish the temporary kernel source files</em></span>:
                        Temporary kernel source files are kept in the Build Directory created by the
                        OpenEmbedded build system when you run BitBake.
                        If you have never built the kernel you are interested in, you need to run
                        an initial build to establish local kernel source files.</p><p>If you are building an image for the first time, you need to get the build
                        environment ready by sourcing
                        the environment setup script.
                        You also need to be sure two key configuration files
                        (<code class="filename">local.conf</code> and <code class="filename">bblayers.conf</code>)
                        are configured appropriately.</p><p>The entire process for building an image is overviewed in the
                        "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>"
                        section of the Yocto Project Quick Start.
                        You might want to reference this information.
                        You can find more information on BitBake in the user manual, which is found in the
                        <code class="filename">bitbake/doc/manual</code> directory of the
                        <a class="link" href="#source-directory">Source Directory</a>.</p><p>The build process supports several types of images to satisfy different needs.
                        See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>" chapter in
                        the Yocto Project Reference Manual for information on supported images.
                        </p></li><li class="listitem"><p><span class="emphasis"><em>Make changes to the kernel source code if
                        applicable</em></span>:  Modifying the kernel does not always mean directly
                        changing source files.
                        However, if you have to do this, you make the changes to the files in the
                        Build directory.</p></li><li class="listitem"><p><span class="emphasis"><em>Make kernel configuration changes
                        if applicable</em></span>:
                        If your situation calls for changing the kernel's configuration, you can
                        use the <code class="filename">yocto-kernel</code> script or <code class="filename">menuconfig</code>
                        to enable and disable kernel configurations.
                        Using the script lets you interactively set up kernel configurations.
                        Using <code class="filename">menuconfig</code> allows you to interactively develop and test the
                        configuration changes you are making to the kernel.
                        When saved, changes using <code class="filename">menuconfig</code> update the kernel's
                        <code class="filename">.config</code>.
                        Try to resist the temptation of directly editing the <code class="filename">.config</code>
                        file found in the
                        <a class="link" href="#build-directory">Build Directory</a> at
                        <code class="filename">tmp/sysroots/&lt;machine-name&gt;/kernel</code>.
                        Doing so, can produce unexpected results when the OpenEmbedded build system
                        regenerates the configuration file.</p><p>Once you are satisfied with the configuration changes made using
                        <code class="filename">menuconfig</code>, you can directly examine the
                        <code class="filename">.config</code> file against a saved original and gather those
                        changes into a config fragment to be referenced from within the kernel's
                        <code class="filename">.bbappend</code> file.</p></li><li class="listitem"><p><span class="emphasis"><em>Rebuild the kernel image with your changes</em></span>:
                        Rebuilding the kernel image applies your changes.</p></li></ol></div><p>
            </p></div></div></div><div class="section" title="4.2. Application Development Workflow"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="application-development-workflow"></a>4.2. Application Development Workflow</h2></div></div></div><p>
        Application development involves creating an application that you want
        to run on your target hardware, which is running a kernel image created using the
        OpenEmbedded build system.
        The Yocto Project provides an Application Development Toolkit (ADT) and
        stand-alone cross-development toolchains that
        facilitate quick development and integration of your application into its run-time environment.
        Using the ADT and toolchains, you can compile and link your application.
        You can then deploy your application to the actual hardware or to the QEMU emulator for testing.
        If you are familiar with the popular <span class="trademark">Eclipse</span>™ IDE,
        you can use an Eclipse Yocto Plug-in to
        allow you to develop, deploy, and test your application all from within Eclipse.
    </p><p>
        While we strongly suggest using the ADT to develop your application, this option might not
        be best for you.
        If this is the case, you can still use pieces of the Yocto Project for your development process.
        However, because the process can vary greatly, this manual does not provide detail on the process.
    </p><div class="section" title="4.2.1. Workflow Using the ADT and Eclipse™"><div class="titlepage"><div><div><h3 class="title"><a id="workflow-using-the-adt-and-eclipse"></a>4.2.1. Workflow Using the ADT and <span class="trademark">Eclipse</span>™</h3></div></div></div><p>
            To help you understand how application development works using the ADT, this section
            provides an overview of the general development process and a detailed example of the process
            as it is used from within the Eclipse IDE.
        </p><p>
            The following illustration and list summarize the application development general workflow.
        </p><p>
            </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="630"><tr style="height: 720px"><td align="center"><img src="figures/app-dev-flow.png" align="middle" /></td></tr></table><p>
        </p><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Prepare the Host System for the Yocto Project</em></span>:
                    See
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#the-linux-distro" target="_top">The Linux Distributions</a>" and
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#packages" target="_top">The Packages</a>" sections both
                    in the Yocto Project Quick Start for requirements.</p></li><li class="listitem"><p><span class="emphasis"><em>Secure the Yocto Project Kernel Target Image</em></span>:
                    You must have a target kernel image that has been built using the OpenEmbeded
                    build system.</p><p>Depending on whether the Yocto Project has a pre-built image that matches your target
                    architecture and where you are going to run the image while you develop your application
                    (QEMU or real hardware), the area from which you get the image differs.
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download the image from
                                <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/machines" target="_top"><code class="filename">machines</code></a>
                                if your target architecture is supported and you are going to develop
                                and test your application on actual hardware.</p></li><li class="listitem"><p>Download the image from the
                                <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/machines/qemu" target="_top">
                                <code class="filename">machines/qemu</code></a> if your target architecture is supported
                                and you are going to develop and test your application using the QEMU
                                emulator.</p></li><li class="listitem"><p>Build your image if you cannot find a pre-built image that matches
                                your target architecture.
                                If your target architecture is similar to a supported architecture, you can
                                modify the kernel image before you build it.
                                See the
                                "<a class="link" href="#patching-the-kernel" title="5.7. Patching the Kernel">Patching the Kernel</a>"
                                section for an example.</p></li></ul></div><p>For information on pre-built kernel image naming schemes for images
                    that can run on the QEMU emulator, see the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#downloading-the-pre-built-linux-kernel" target="_top">Downloading the Pre-Built Linux Kernel</a>"
                    section in the Yocto Project Quick Start.</p></li><li class="listitem"><p><span class="emphasis"><em>Install the ADT</em></span>:
                    The ADT provides a target-specific cross-development toolchain, the root filesystem,
                    the QEMU emulator, and other tools that can help you develop your application.
                    While it is possible to get these pieces separately, the ADT Installer provides an
                    easy method.
                    You can get these pieces by running an ADT installer script, which is configurable.
                    For information on how to install the ADT, see the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-the-adt-installer" target="_top">Using the ADT Installer</a>"
                    section
                    in the Yocto Project Application Developer's Guide.</p></li><li class="listitem"><p><span class="emphasis"><em>If Applicable, Secure the Target Root Filesystem
                    and the Cross-development Toolchain</em></span>:
                    If you choose not to install the ADT using the ADT Installer,
                    you need to find and download the appropriate root filesystem and
                    the cross-development toolchain.</p><p>You can find the tarballs for the root filesystem in the same area used
                    for the kernel image.
                    Depending on the type of image you are running, the root filesystem you need differs.
                    For example, if you are developing an application that runs on an image that
                    supports Sato, you need to get root filesystem that supports Sato.</p><p>You can find the cross-development toolchains at
                    <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/toolchain/" target="_top"><code class="filename">toolchains</code></a>.
                    Be sure to get the correct toolchain for your development host and your
                    target architecture.
                    See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-an-existing-toolchain-tarball" target="_top">Using a Cross-Toolchain Tarball</a>"
                    section in the Yocto Project Application Developer's Guide for information
                    and the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#installing-the-toolchain" target="_top">Installing the Toolchain</a>"
                    in the Yocto Project Quick Start for information on finding and installing
                    the correct toolchain based on your host development system and your target
                    architecture.
                    </p></li><li class="listitem"><p><span class="emphasis"><em>Create and Build your Application</em></span>:
                    At this point, you need to have source files for your application.
                    Once you have the files, you can use the Eclipse IDE to import them and build the
                    project.
                    If you are not using Eclipse, you need to use the cross-development tools you have
                    installed to create the image.</p></li><li class="listitem"><p><span class="emphasis"><em>Deploy the Image with the Application</em></span>:
                    If you are using the Eclipse IDE, you can deploy your image to the hardware or to
                    QEMU through the project's preferences.
                    If you are not using the Eclipse IDE, then you need to deploy the application
                    to the hardware using other methods.
                    Or, if you are using QEMU, you need to use that tool and load your image in for testing.
                    </p></li><li class="listitem"><p><span class="emphasis"><em>Test and Debug the Application</em></span>:
                    Once your application is deployed, you need to test it.
                    Within the Eclipse IDE, you can use the debugging environment along with the
                    set of user-space tools installed along with the ADT to debug your application.
                    Of course, the same user-space tools are available separately if you choose
                    not to use the Eclipse IDE.</p></li></ol></div><p>
        </p></div><div class="section" title="4.2.2. Working Within Eclipse"><div class="titlepage"><div><div><h3 class="title"><a id="adt-eclipse"></a>4.2.2. Working Within Eclipse</h3></div></div></div><p>
            The Eclipse IDE is a popular development environment and it fully supports
            development using the Yocto Project.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>This release of the Yocto Project supports both the Juno and Indigo versions
                of the Eclipse IDE.
                Thus, the following information provides setup information for both versions.
            </div><p>
        </p><p>
            When you install and configure the Eclipse Yocto Project Plug-in into
            the Eclipse IDE, you maximize your Yocto Project experience.
            Installing and configuring the Plug-in results in an environment that
            has extensions specifically designed to let you more easily develop software.
            These extensions allow for cross-compilation, deployment, and execution of
            your output into a QEMU emulation session.
            You can also perform cross-debugging and profiling.
            The environment also supports a suite of tools that allows you to perform
            remote profiling, tracing, collection of power data, collection of
            latency data, and collection of performance data.
        </p><p>
            This section describes how to install and configure the Eclipse IDE
            Yocto Plug-in and how to use it to develop your application.
        </p><div class="section" title="4.2.2.1. Setting Up the Eclipse IDE"><div class="titlepage"><div><div><h4 class="title"><a id="setting-up-the-eclipse-ide"></a>4.2.2.1. Setting Up the Eclipse IDE</h4></div></div></div><p>
                To develop within the Eclipse IDE, you need to do the following:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Install the optimal version of the Eclipse IDE.</p></li><li class="listitem"><p>Configure the Eclipse IDE.</p></li><li class="listitem"><p>Install the Eclipse Yocto Plug-in.</p></li><li class="listitem"><p>Configure the Eclipse Yocto Plug-in.</p></li></ol></div><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Do not install Eclipse from your distribution's package repository.
                    Be sure to install Eclipse from the official Eclipse download site as directed
                    in the next section.
                </div><p>
            </p><div class="section" title="4.2.2.1.1. Installing the Eclipse IDE"><div class="titlepage"><div><div><h5 class="title"><a id="installing-eclipse-ide"></a>4.2.2.1.1. Installing the Eclipse IDE</h5></div></div></div><p>
                    It is recommended that you have the Juno 4.2 version of the
                    Eclipse IDE installed on your development system.
                    However, if you currently have the Indigo 3.7.2 version installed and you do
                    not want to upgrade the IDE, you can configure Indigo to work with the
                    Yocto Project.
                    See the
                    "<a class="link" href="#configuring-the-eclipse-ide-indigo" title="4.2.2.1.3. Configuring the Eclipse IDE (Indigo)">Configuring the Eclipse IDE (Indigo)</a>"
                    section.
                </p><p>
                    If you don’t have the Juno 4.2 Eclipse IDE installed, you can find the tarball at
                    <a class="ulink" href="http://www.eclipse.org/downloads" target="_top">http://www.eclipse.org/downloads</a>.
                    From that site, choose the Eclipse Classic version particular to your development
                    host.
                    This version contains the Eclipse Platform, the Java Development
                    Tools (JDT), and the Plug-in Development Environment.
                </p><p>
                    Once you have downloaded the tarball, extract it into a clean
                    directory.
                    For example, the following commands unpack and install the
                    downloaded Eclipse IDE tarball into a clean directory
                    using the default name <code class="filename">eclipse</code>:
                    </p><pre class="literallayout">
     $ cd ~
     $ tar -xzvf ~/Downloads/eclipse-SDK-4.2-linux-gtk-x86_64.tar.gz
                    </pre><p>
                </p><p>
                    If you have the Indigo 3.7.2 Eclipse IDE already installed and you want to use that
                    version, one issue exists that you need to be aware of regarding the Java
                    Virtual machine’s garbage collection (GC) process.
                    The GC process does not clean up the permanent generation
                    space (PermGen).
                    This space stores metadata descriptions of classes.
                    The default value is set too small and it could trigger an
                    out-of-memory error such as the following:
                    </p><pre class="literallayout">
     Java.lang.OutOfMemoryError: PermGen space
                    </pre><p>
                </p><p>
                    This error causes the application to hang.
                </p><p>
                    To fix this issue, you can use the <code class="filename">--vmargs</code>
                    option when you start the Indigo 3.7.2 Eclipse IDE
                    to increase the size of the permanent generation space:
                    </p><pre class="literallayout">
     eclipse --vmargs --XX:PermSize=256M
                    </pre><p>
                </p></div><div class="section" title="4.2.2.1.2. Configuring the Eclipse IDE (Juno)"><div class="titlepage"><div><div><h5 class="title"><a id="configuring-the-eclipse-ide-juno"></a>4.2.2.1.2. Configuring the Eclipse IDE (Juno)</h5></div></div></div><p>
                    This section presents the steps needed to configure the Juno 4.2 Eclipse IDE.
                    If you are using Indigo 3.7.2, see the
                    "<a class="link" href="#configuring-the-eclipse-ide-indigo" title="4.2.2.1.3. Configuring the Eclipse IDE (Indigo)">Configuring the Eclipse IDE (Indigo)</a>".
                </p><p>
                    Before installing and configuring the Eclipse Yocto Plug-in, you need to configure
                    the Juno 4.2 Eclipse IDE.
                    Follow these general steps:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start the Eclipse IDE.</p></li><li class="listitem"><p>Make sure you are in your Workbench and select
                            "Install New Software" from the "Help" pull-down menu.
                            </p></li><li class="listitem"><p>Select <code class="filename">Juno - http://download.eclipse.org/releases/juno</code>
                            from the "Work with:" pull-down menu.</p></li><li class="listitem"><p>Expand the box next to "Linux Tools" and select the
                            "LTTng - Linux Tracing Toolkit" boxes.</p></li><li class="listitem"><p>Expand the box next to "Mobile and Device Development" and select the
                            following boxes:
                            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename">C/C++ Remote Launch</code></p></li><li class="listitem"><p><code class="filename">Remote System Explorer End-user Runtime</code></p></li><li class="listitem"><p><code class="filename">Remote System Explorer User Actions</code></p></li><li class="listitem"><p><code class="filename">Target Management Terminal</code></p></li><li class="listitem"><p><code class="filename">TCF Remote System Explorer add-in</code></p></li><li class="listitem"><p><code class="filename">TCF Target Explorer</code></p></li></ul></div></li><li class="listitem"><p>Expand the box next to <code class="filename">Programming Languages</code>
                            and select the <code class="filename">Autotools Support for CDT</code>
                            and <code class="filename">C/C++ Development Tools</code> boxes.</p></li><li class="listitem"><p>Complete the installation and restart the Eclipse IDE.</p></li></ol></div><p>
                </p></div><div class="section" title="4.2.2.1.3. Configuring the Eclipse IDE (Indigo)"><div class="titlepage"><div><div><h5 class="title"><a id="configuring-the-eclipse-ide-indigo"></a>4.2.2.1.3. Configuring the Eclipse IDE (Indigo)</h5></div></div></div><p>
                    This section presents the steps needed to configure the Indigo 3.7.2 Eclipse IDE.
                    If you are using Juno 4.2, see the
                    "<a class="link" href="#configuring-the-eclipse-ide-juno" title="4.2.2.1.2. Configuring the Eclipse IDE (Juno)">Configuring the Eclipse IDE (Juno)</a>".
                </p><p>
                    Before installing and configuring the Eclipse Yocto Plug-in, you need to configure
                    the Indigo 3.7.2 Eclipse IDE.
                    Follow these general steps:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start the Eclipse IDE.</p></li><li class="listitem"><p>Make sure you are in your Workbench and select
                            "Install New Software" from the "Help" pull-down menu.
                            </p></li><li class="listitem"><p>Select <code class="filename">indigo - http://download.eclipse.org/releases/indigo</code>
                            from the "Work with:" pull-down menu.</p></li><li class="listitem"><p>Expand the box next to <code class="filename">Programming Languages</code>
                            and select the <code class="filename">Autotools Support for CDT (incubation)</code>
                            and <code class="filename">C/C++ Development Tools</code> boxes.</p></li><li class="listitem"><p>Expand the box next to "Linux Tools" and select the
                            "LTTng - Linux Tracing Toolkit(incubation)" boxes.</p></li><li class="listitem"><p>Complete the installation and restart the Eclipse IDE.</p></li><li class="listitem"><p>After the Eclipse IDE restarts and from the Workbench, select
                            "Install New Software" from the "Help" pull-down menu.</p></li><li class="listitem"><p>Click the
                            "Available Software Sites" link.</p></li><li class="listitem"><p>Check the box next to
                            <code class="filename">http://download.eclipse.org/tm/updates/3.3</code>
                            and click "OK".</p></li><li class="listitem"><p>Select <code class="filename">http://download.eclipse.org/tm/updates/3.3</code>
                            from the "Work with:" pull-down menu.</p></li><li class="listitem"><p>Check the box next to <code class="filename">TM and RSE Main Features</code>.
                            </p></li><li class="listitem"><p>Expand the box next to <code class="filename">TM and RSE Optional Add-ons</code>
                            and select every item except <code class="filename">RSE Unit Tests</code> and
                            <code class="filename">RSE WinCE Services (incubation)</code>.</p></li><li class="listitem"><p>Complete the installation and restart the Eclipse IDE.</p></li><li class="listitem"><p>If necessary, select
                            "Install New Software" from the "Help" pull-down menu so you can click the
                            "Available Software Sites" link again.</p></li><li class="listitem"><p>After clicking "Available Software Sites", check the box next to
                            <code class="filename">http://download.eclipse.org/tools/cdt/releases/indigo</code>
                           and click "OK".</p></li><li class="listitem"><p>Select <code class="filename">http://download.eclipse.orgtools/cdt/releases/indigo</code>
                            from the "Work with:" pull-down menu.</p></li><li class="listitem"><p>Check the box next to <code class="filename">CDT Main Features</code>.
                            </p></li><li class="listitem"><p>Expand the box next to <code class="filename">CDT Optional Features</code>
                            and select <code class="filename">C/C++ Remote Launch</code> and
                            <code class="filename">Target Communication Framework (incubation)</code>.</p></li><li class="listitem"><p>Complete the installation and restart the Eclipse IDE.</p></li></ol></div><p>
                </p></div><div class="section" title="4.2.2.1.4. Installing or Accessing the Eclipse Yocto Plug-in"><div class="titlepage"><div><div><h5 class="title"><a id="installing-the-eclipse-yocto-plug-in"></a>4.2.2.1.4. Installing or Accessing the Eclipse Yocto Plug-in</h5></div></div></div><p>
                    You can install the Eclipse Yocto Plug-in into the Eclipse IDE
                    one of two ways:  use the Yocto Project's Eclipse Update site to install the pre-built plug-in,
                    or build and install the plug-in from the latest source code.
                    If you don't want to permanently install the plug-in but just want to try it out
                    within the Eclipse environment, you can import the plug-in project from the
                    Yocto Project's Source Repositories.
                </p><div class="section" title="4.2.2.1.4.1. Installing the Pre-built Plug-in from the Yocto Project Eclipse Update Site"><div class="titlepage"><div><div><h6 class="title"><a id="new-software"></a>4.2.2.1.4.1. Installing the Pre-built Plug-in from the Yocto Project Eclipse Update Site</h6></div></div></div><p>
                        To install the Eclipse Yocto Plug-in from the update site,
                        follow these steps:
                        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start up the Eclipse IDE.</p></li><li class="listitem"><p>In Eclipse, select "Install New Software" from the "Help" menu.</p></li><li class="listitem"><p>Click "Add..." in the "Work with:" area.</p></li><li class="listitem"><p>Enter
                                <code class="filename">http://downloads.yoctoproject.org/releases/eclipse-plugin/1.4</code>
                                in the URL field and provide a meaningful name in the "Name" field.</p></li><li class="listitem"><p>Click "OK" to have the entry added to the "Work with:"
                                drop-down list.</p></li><li class="listitem"><p>Select the entry for the plug-in from the "Work with:" drop-down
                                list.</p></li><li class="listitem"><p>Check the box next to <code class="filename">Development tools and SDKs for Yocto Linux</code>.
                                </p></li><li class="listitem"><p>Complete the remaining software installation steps and
                                then restart the Eclipse IDE to finish the installation of the plug-in.
                                </p></li></ol></div><p>
                    </p></div><div class="section" title="4.2.2.1.4.2. Installing the Plug-in Using the Latest Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="zip-file-method"></a>4.2.2.1.4.2. Installing the Plug-in Using the Latest Source Code</h6></div></div></div><p>
                        To install the Eclipse Yocto Plug-in from the latest source code, follow these steps:
                        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Open a shell and create a Git repository with:
                                </p><pre class="literallayout">
     $ git clone git://git.yoctoproject.org/eclipse-poky yocto-eclipse
                                </pre><p>
                                For this example, the repository is named
                                <code class="filename">~/yocto-eclipse</code>.</p></li><li class="listitem"><p>Change to the directory where you set up
                                the Git repository:
                                </p><pre class="literallayout">
     $ cd ~/yocto-eclipse
                                </pre></li><li class="listitem"><p>Be sure you are in the right branch for your Git repository.
                                For this release set the branch to <code class="filename">tbd</code>:
                                </p><pre class="literallayout">
     $ git checkout -b tbd origin/tbd
                                </pre></li><li class="listitem"><p>Change to the <code class="filename">scripts</code>
                                directory within the Git repository:
                                </p><pre class="literallayout">
     $ cd scripts
                                </pre></li><li class="listitem"><p>Set up the local build environment by running the
                                setup script:
                                </p><pre class="literallayout">
     $ ./setup.sh
                                </pre></li><li class="listitem"><p>When the script finishes execution, it prompts
                                you with instructions on how to run the
                                <code class="filename">build.sh</code> script, which is also in
                                the <code class="filename">scripts</code> of the
                                Git repository created earlier.
                                </p></li><li class="listitem"><p>Run the <code class="filename">build.sh</code> script
                                as directed.
                                Be sure to provide the name of the Git branch along with the
                                Yocto Project release you are using.
                                Here is an example that uses the <code class="filename">tbd</code> branches:
                                </p><pre class="literallayout">
     $ ECLIPSE_HOME=/home/scottrif/yocto-eclipse/scripts/eclipse ./build.sh tbd tbd
                                </pre><p>
                                After running the script, the file
                                <code class="filename">org.yocto.sdk-&lt;release&gt;-&lt;date&gt;-archive.zip</code>
                                is in the current directory.</p></li><li class="listitem"><p>If necessary, start the Eclipse IDE and be sure you are in the
                                Workbench.</p></li><li class="listitem"><p>Select "Install New Software" from the "Help" pull-down menu.
                                </p></li><li class="listitem"><p>Click "Add".</p></li><li class="listitem"><p>Provide anything you want in the "Name" field.</p></li><li class="listitem"><p>Click "Archive" and browse to the ZIP file you built
                                in step seven.
                                This ZIP file should not be "unzipped", and must be the
                                <code class="filename">*archive.zip</code> file created by running the
                                <code class="filename">build.sh</code> script.</p></li><li class="listitem"><p>Click through the "Okay" buttons.</p></li><li class="listitem"><p>Check the box next to the new entry in the installation window and complete
                        the installation.</p></li><li class="listitem"><p>Restart the Eclipse IDE if necessary.</p></li></ol></div><p>
                    </p><p>
                        At this point you should be able to configure the Eclipse Yocto Plug-in as described in the
                        "<a class="link" href="#configuring-the-eclipse-yocto-plug-in" title="4.2.2.1.5. Configuring the Eclipse Yocto Plug-in">Configuring the Eclipse Yocto Plug-in</a>"
                        section.</p></div><div class="section" title="4.2.2.1.4.3. Importing the Plug-in Project into the Eclipse Environment"><div class="titlepage"><div><div><h6 class="title"><a id="yocto-project-source"></a>4.2.2.1.4.3. Importing the Plug-in Project into the Eclipse Environment</h6></div></div></div><p>
                        Importing the Eclipse Yocto Plug-in project from the Yocto Project source repositories
                        is useful when you want to try out the latest plug-in from the tip of plug-in's
                        development tree.
                        It is important to understand when you import the plug-in you are not installing
                        it into the Eclipse application.
                        Rather, you are importing the project and just using it.
                        To import the plug-in project, follow these steps:
                        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Open a shell and create a Git repository with:
                                </p><pre class="literallayout">
     $ git clone git://git.yoctoproject.org/eclipse-poky yocto-eclipse
                                </pre><p>
                                For this example, the repository is named
                                <code class="filename">~/yocto-eclipse</code>.</p></li><li class="listitem"><p>In Eclipse, select "Import" from the "File" menu.</p></li><li class="listitem"><p>Expand the "General" box and select "existing projects into workspace"
                                and then click "Next".</p></li><li class="listitem"><p>Select the root directory and browse to
                                <code class="filename">~/yocto-eclipse/plugins</code>.</p></li><li class="listitem"><p>Three plug-ins exist: "org.yocto.bc.ui", "org.yocto.sdk.ide", and
                                "org.yocto.sdk.remotetools".
                                Select and import all of them.</p></li></ol></div><p>
                    </p><p>
                        The left navigation pane in the Eclipse application shows the default projects.
                        Right-click on one of these projects and run it as an Eclipse application.
                        This brings up a second instance of Eclipse IDE that has the Yocto Plug-in.
                    </p></div></div><div class="section" title="4.2.2.1.5. Configuring the Eclipse Yocto Plug-in"><div class="titlepage"><div><div><h5 class="title"><a id="configuring-the-eclipse-yocto-plug-in"></a>4.2.2.1.5. Configuring the Eclipse Yocto Plug-in</h5></div></div></div><p>
                    Configuring the Eclipse Yocto Plug-in involves setting the Cross
                    Compiler options and the Target options.
                    The configurations you choose become the default settings for all projects.
                    You do have opportunities to change them later when
                    you configure the project (see the following section).
                </p><p>
                    To start, you need to do the following from within the Eclipse IDE:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Choose <code class="filename">Windows -&gt; Preferences</code> to display
                            the <code class="filename">Preferences</code> Dialog</p></li><li class="listitem"><p>Click <code class="filename">Yocto Project ADT</code></p></li></ul></div><p>
                </p><div class="section" title="4.2.2.1.5.1. Configuring the Cross-Compiler Options"><div class="titlepage"><div><div><h6 class="title"><a id="configuring-the-cross-compiler-options"></a>4.2.2.1.5.1. Configuring the Cross-Compiler Options</h6></div></div></div><p>
                        To configure the Cross Compiler Options, you must select the type of toolchain,
                        point to the toolchain, specify the sysroot location, and select the target architecture.
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Selecting the Toolchain Type:</em></span>
                                Choose between <code class="filename">Standalone pre-built toolchain</code>
                                and <code class="filename">Build system derived toolchain</code> for Cross
                                Compiler Options.
                                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><span class="emphasis"><em>
                                            <code class="filename">Standalone Pre-built Toolchain:</code></em></span>
                                            Select this mode when you are using a stand-alone cross-toolchain.
                                            For example, suppose you are an application developer and do not
                                            need to build a target image.
                                            Instead, you just want to use an architecture-specific toolchain on an
                                            existing kernel and target root filesystem.
                                            </p></li><li class="listitem"><p><span class="emphasis"><em>
                                            <code class="filename">Build System Derived Toolchain:</code></em></span>
                                            Select this mode if the cross-toolchain has been installed and built
                                            as part of the Build Directory.
                                            When you select <code class="filename">Build system derived toolchain</code>,
                                            you are using the toolchain bundled
                                            inside the Build Directory.
                                            </p></li></ul></div><p>
                                </p></li><li class="listitem"><p><span class="emphasis"><em>Point to the Toolchain:</em></span>
                                If you are using a stand-alone pre-built toolchain, you should be pointing to the
                                <code class="filename">/opt/poky/1.4</code> directory.
                                This is the location for toolchains installed by the ADT Installer or by hand.
                                Sections "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#configuring-and-running-the-adt-installer-script" target="_top">Configuring
                                and Running the ADT Installer Script</a>" and
                                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-an-existing-toolchain-tarball" target="_top">Using a Cross-Toolchain Tarball</a>"
                                in the Yocto Project Application Developer's Guide
                                describe two ways to install a stand-alone cross-toolchain in the
                                <code class="filename">/opt/poky</code> directory.
                                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>It is possible to install a stand-alone cross-toolchain in a directory
                                other than <code class="filename">/opt/poky</code>.
                                However, doing so is discouraged.</div><p>If you are using a system-derived toolchain, the path you provide
                                for the <code class="filename">Toolchain Root Location</code>
                                field is the Build Directory.
                                See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-the-toolchain-from-within-the-build-tree" target="_top">Using
                                BitBake and the Build Directory</a>" section in the Yocto Project Application
                                Developer's Guide for information on how to install the toolchain into the build
directory.</p></li><li class="listitem"><p><span class="emphasis"><em>Specify the Sysroot Location:</em></span>
                                This location is where the root filesystem for the target hardware resides.
                                If you used the ADT Installer, then the location is
                                <code class="filename">/opt/poky/&lt;release&gt;</code>.
                                Additionally, when you use the ADT Installer, the same location is used for
                                the QEMU user-space tools and the NFS boot process.</p><p>If you used either of the other two methods to install the toolchain, then the
                                location of the sysroot filesystem depends on where you separately
                                extracted and intalled the filesystem.</p><p>For information on how to install the toolchain and on how to extract
                                and install the sysroot filesystem, see the
                                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#installing-the-adt" target="_top">Installing the ADT and Toolchains</a>" section.
                                </p></li><li class="listitem"><p><span class="emphasis"><em>Select the Target Architecture:</em></span>
                                The target architecture is the type of hardware you are
                                going to use or emulate.
                                Use the pull-down <code class="filename">Target Architecture</code> menu to make
                                your selection.
                                The pull-down menu should have the supported architectures.
                                If the architecture you need is not listed in the menu, you
                                will need to build the image.
                                See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>" section
                                of the Yocto Project Quick Start for more information.</p></li></ul></div><p>
                    </p></div><div class="section" title="4.2.2.1.5.2. Configuring the Target Options"><div class="titlepage"><div><div><h6 class="title"><a id="configuring-the-target-options"></a>4.2.2.1.5.2. Configuring the Target Options</h6></div></div></div><p>
                        You can choose to emulate hardware using the QEMU emulator, or you
                        can choose to run your image on actual hardware.
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em><code class="filename">QEMU:</code></em></span> Select this option if
                                you will be using the QEMU emulator.
                                If you are using the emulator, you also need to locate the kernel
                                and specify any custom options.</p><p>If you selected <code class="filename">Build system derived toolchain</code>,
                                the target kernel you built will be located in the
                                Build Directory in <code class="filename">tmp/deploy/images</code> directory.
                                If you selected <code class="filename">Standalone pre-built toolchain</code>, the
                                pre-built image you downloaded is located
                                in the directory you specified when you downloaded the image.</p><p>Most custom options are for advanced QEMU users to further
                                customize their QEMU instance.
                                These options are specified between paired angled brackets.
                                Some options must be specified outside the brackets.
                               In particular, the options <code class="filename">serial</code>,
                                <code class="filename">nographic</code>, and <code class="filename">kvm</code> must all
                                be outside the brackets.
                                Use the <code class="filename">man qemu</code> command to get help on all the options
                                and their use.
                                The following is an example:
                               </p><pre class="literallayout">
    serial ‘&lt;-m 256 -full-screen&gt;’
                                </pre><p>
                                Regardless of the mode, Sysroot is already defined as part of the
                                Cross Compiler Options configuration in the
                                <code class="filename">Sysroot Location:</code> field.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">External HW:</code></em></span> Select this option
                                if you will be using actual hardware.</p></li></ul></div><p>
                    </p><p>
                        Click the <code class="filename">OK</code> button to save your plug-in configurations.
                    </p></div></div></div><div class="section" title="4.2.2.2. Creating the Project"><div class="titlepage"><div><div><h4 class="title"><a id="creating-the-project"></a>4.2.2.2. Creating the Project</h4></div></div></div><p>
                You can create two types of projects:  Autotools-based, or Makefile-based.
                This section describes how to create Autotools-based projects from within
                the Eclipse IDE.
                For information on creating Makefile-based projects in a terminal window, see the section
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-the-command-line" target="_top">Using the Command Line</a>"
                in the Yocto Project Application Developer's Guide.
            </p><p>
                To create a project based on a Yocto template and then display the source code,
                follow these steps:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <code class="filename">File -&gt; New -&gt; Project</code>.</p></li><li class="listitem"><p>Double click <code class="filename">CC++</code>.</p></li><li class="listitem"><p>Double click <code class="filename">C Project</code> to create the project.</p></li><li class="listitem"><p>Expand <code class="filename">Yocto Project ADT Project</code>.</p></li><li class="listitem"><p>Select <code class="filename">Hello World ANSI C Autotools Project</code>.
                        This is an Autotools-based project based on a Yocto template.</p></li><li class="listitem"><p>Put a name in the <code class="filename">Project name:</code> field.
                        Do not use hyphens as part of the name.</p></li><li class="listitem"><p>Click <code class="filename">Next</code>.</p></li><li class="listitem"><p>Add information in the <code class="filename">Author</code> and
                        <code class="filename">Copyright notice</code> fields.</p></li><li class="listitem"><p>Be sure the <code class="filename">License</code> field is correct.</p></li><li class="listitem"><p>Click <code class="filename">Finish</code>.</p></li><li class="listitem"><p>If the "open perspective" prompt appears, click "Yes" so that you
                        in the C/C++ perspective.</p></li><li class="listitem"><p>The left-hand navigation pane shows your project.
                        You can display your source by double clicking the project's source file.
                        </p></li></ol></div><p>
            </p></div><div class="section" title="4.2.2.3. Configuring the Cross-Toolchains"><div class="titlepage"><div><div><h4 class="title"><a id="configuring-the-cross-toolchains"></a>4.2.2.3. Configuring the Cross-Toolchains</h4></div></div></div><p>
                The earlier section, "<a class="link" href="#configuring-the-eclipse-yocto-plug-in" title="4.2.2.1.5. Configuring the Eclipse Yocto Plug-in">Configuring
                the Eclipse Yocto Plug-in</a>", sets up the default project
                configurations.
                You can override these settings for a given project by following these steps:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <code class="filename">Project -&gt; Change Yocto Project Settings</code>:
                        This selection brings up the <code class="filename">Yocot Project Settings</code> Dialog
                        and allows you to make changes specific to an individual project.
                        </p><p>By default, the Cross Compiler Options and Target Options for a project
                        are inherited from settings you provide using the <code class="filename">Preferences</code>
                        Dialog as described earlier
                        in the "<a class="link" href="#configuring-the-eclipse-yocto-plug-in" title="4.2.2.1.5. Configuring the Eclipse Yocto Plug-in">Configuring the Eclipse
                        Yocto Plug-in</a>" section.
                        The <code class="filename">Yocto Project Settings</code>
                        Dialog allows you to override those default settings
                        for a given project.</p></li><li class="listitem"><p>Make your configurations for the project and click "OK".
                        If you are running the Juno version of Eclipse, you can skip down to the next
                        section where you build the project.
                        If you are not working with Juno, you need to reconfigure the project as
                        described in the next step.</p></li><li class="listitem"><p>Select <code class="filename">Project -&gt; Reconfigure Project</code>:
                        This selection reconfigures the project by running
                       <code class="filename">autogen.sh</code> in the workspace for your project.
                        The script also runs <code class="filename">libtoolize</code>, <code class="filename">aclocal</code>,
                        <code class="filename">autoconf</code>, <code class="filename">autoheader</code>,
                        <code class="filename">automake --a</code>, and
                        <code class="filename">./configure</code>.
                        Click on the <code class="filename">Console</code> tab beneath your source code to
                        see the results of reconfiguring your project.</p></li></ol></div><p>
            </p></div><div class="section" title="4.2.2.4. Building the Project"><div class="titlepage"><div><div><h4 class="title"><a id="building-the-project"></a>4.2.2.4. Building the Project</h4></div></div></div><p>
                To build the project in Juno, right click on the project in the navigator pane and select
                <code class="filename">Build Project</code>.
                If you are not running Juno, select <code class="filename">Project -&gt; Build Project</code>.
                The console should update and you can note the cross-compiler you are using.
            </p></div><div class="section" title="4.2.2.5. Starting QEMU in User Space NFS Mode"><div class="titlepage"><div><div><h4 class="title"><a id="starting-qemu-in-user-space-nfs-mode"></a>4.2.2.5. Starting QEMU in User Space NFS Mode</h4></div></div></div><p>
                To start the QEMU emulator from within Eclipse, follow these steps:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Expose the <code class="filename">Run -&gt; External Tools</code> menu.
                        Your image should appear as a selectable menu item.
                        </p></li><li class="listitem"><p>Select your image from the menu to launch the
                        emulator in a new window.</p></li><li class="listitem"><p>If needed, enter your host root password in the shell window at the prompt.
                        This sets up a <code class="filename">Tap 0</code> connection needed for running in user-space
                        NFS mode.</p></li><li class="listitem"><p>Wait for QEMU to launch.</p></li><li class="listitem"><p>Once QEMU launches, you can begin operating within that
                        environment.
                        For example, you could determine the IP Address
                       for the user-space NFS by using the <code class="filename">ifconfig</code> command.
                        </p></li></ol></div><p>
            </p></div><div class="section" title="4.2.2.6. Deploying and Debugging the Application"><div class="titlepage"><div><div><h4 class="title"><a id="deploying-and-debugging-the-application"></a>4.2.2.6. Deploying and Debugging the Application</h4></div></div></div><p>
                Once the QEMU emulator is running the image, using the Eclipse IDE
                you can deploy your application and use the emulator to perform debugging.
                Follow these steps to deploy the application.
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <code class="filename">Run -&gt; Debug Configurations...</code></p></li><li class="listitem"><p>In the left area, expand <code class="filename">C/C++Remote Application</code>.</p></li><li class="listitem"><p>Locate your project and select it to bring up a new
                        tabbed view in the <code class="filename">Debug Configurations</code> Dialog.</p></li><li class="listitem"><p>Enter the absolute path into which you want to deploy
                        the application.
                        Use the <code class="filename">Remote Absolute File Path for C/C++Application:</code> field.
                        For example, enter <code class="filename">/usr/bin/&lt;programname&gt;</code>.</p></li><li class="listitem"><p>Click on the <code class="filename">Debugger</code> tab to see the cross-tool debugger
                        you are using.</p></li><li class="listitem"><p>Click on the <code class="filename">Main</code> tab.</p></li><li class="listitem"><p>Create a new connection to the QEMU instance
                        by clicking on <code class="filename">new</code>.</p></li><li class="listitem"><p>Select <code class="filename">TCF</code>, which means Target Communication
                        Framework.</p></li><li class="listitem"><p>Click <code class="filename">Next</code>.</p></li><li class="listitem"><p>Clear out the <code class="filename">host name</code> field and enter the IP Address
                        determined earlier.</p></li><li class="listitem"><p>Click <code class="filename">Finish</code> to close the
                        <code class="filename">New Connections</code> Dialog.</p></li><li class="listitem"><p>Use the drop-down menu now in the <code class="filename">Connection</code> field and pick
                        the IP Address you entered.</p></li><li class="listitem"><p>Click <code class="filename">Run</code> to bring up a login screen
                        and login.</p></li><li class="listitem"><p>Accept the debug perspective.</p></li></ol></div><p>
            </p></div><div class="section" title="4.2.2.7. Running User-Space Tools"><div class="titlepage"><div><div><h4 class="title"><a id="running-user-space-tools"></a>4.2.2.7. Running User-Space Tools</h4></div></div></div><p>
                As mentioned earlier in the manual, several tools exist that enhance
                your development experience.
                These tools are aids in developing and debugging applications and images.
                You can run these user-space tools from within the Eclipse IDE through the
                <code class="filename">YoctoTools</code> menu.
            </p><p>
                Once you pick a tool, you need to configure it for the remote target.
                Every tool needs to have the connection configured.
                You must select an existing TCF-based RSE connection to the remote target.
                If one does not exist, click <code class="filename">New</code> to create one.
            </p><p>
                Here are some specifics about the remote tools:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em><code class="filename">OProfile</code>:</em></span>  Selecting this tool causes
                        the <code class="filename">oprofile-server</code> on the remote target to launch on
                        the local host machine.
                        The <code class="filename">oprofile-viewer</code> must be installed on the local host machine and the
                        <code class="filename">oprofile-server</code> must be installed on the remote target,
                        respectively, in order to use.
                        You must compile and install the <code class="filename">oprofile-viewer</code> from the source code
                        on your local host machine.
                        Furthermore, in order to convert the target's sample format data into a form that the
                        host can use, you must have <code class="filename">oprofile</code> version 0.9.4 or
                        greater installed on the host.</p><p>You can locate both the viewer and server from
                        <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi/oprofileui/" target="_top">http://git.yoctoproject.org/cgit/cgit.cgi/oprofileui/</a>.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The <code class="filename">oprofile-server</code> is installed by default on
                        the <code class="filename">core-image-sato-sdk</code> image.</div></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">Lttng2.0 ust trace import</code>:</em></span>
                        Selecting this tool transfers the remote target's
                        <code class="filename">Lttng</code> tracing data back to the local host machine
                        and uses the <code class="filename">Lttng</code> Eclipse plug-in to graphically
                        display the output.
                        For information on how to use <code class="filename">Lttng</code> to trace an application,
                        see <a class="ulink" href="http://lttng.org/documentation" target="_top">http://lttng.org/documentation</a>.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Do not use <code class="filename">Lttng-user space (legacy)</code> tool.
                            This tool no longer has any upstream support.</div><p>
                        </p><p>Before you use the <code class="filename">Lttng2.0 ust trace import</code> tool,
                        you need to setup the <code class="filename">Lttng</code> Eclipse plug-in and create a
                        <code class="filename">Tracing</code> project.
                        Do the following:
                        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <code class="filename">Window -&gt; Open Perspective -&gt; Other</code>
                                and then select <code class="filename">Tracing</code>.</p></li><li class="listitem"><p>Click <code class="filename">OK</code> to change the Eclipse perspective
                                into the <code class="filename">Tracing</code> perspective.</p></li><li class="listitem"><p>Create a new <code class="filename">Tracing</code> project by selecting
                                <code class="filename">File -&gt; New -&gt; Project</code>.</p></li><li class="listitem"><p>Choose <code class="filename">Tracing -&gt; Tracing Project</code>.
                                </p></li><li class="listitem"><p>Generate your tracing data on the remote target.
                                </p></li><li class="listitem"><p>Click
                                <code class="filename">Yocto Project Tools -&gt; Lttng2.0 ust trace import</code>
                                to start the data import process.</p></li><li class="listitem"><p>Specify your remote connection name.</p></li><li class="listitem"><p>For the Ust directory path, specify the location of
                                your remote tracing data.
                                Make sure the location ends with <code class="filename">ust</code> (e.g.
                                <code class="filename">/usr/mysession/ust</code>.</p></li><li class="listitem"><p>Click <code class="filename">OK</code> to complete the import process.
                                The data is now in the local tracing project you created.</p></li><li class="listitem"><p>Right click on the data and then use the menu to
                                <code class="filename">Select Trace Type... -&gt; Common Trace Format -&gt; Generic CTF Trace</code>
                                to map the tracing type.</p></li><li class="listitem"><p>Right click the mouse and select <code class="filename">Open</code>
                                to bring up the Eclipse <code class="filename">Lttng</code> Trace Viewer so you
                                view the tracing data.</p></li></ol></div></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">PowerTOP</code>:</em></span> Selecting this tool runs
                        <code class="filename">powertop</code> on the remote target machine and displays the results in a
                        new view called <code class="filename">powertop</code>.</p><p><code class="filename">Time to gather data(sec):</code> is the time passed in seconds before data
                        is gathered from the remote target for analysis.</p><p><code class="filename">show pids in wakeups list:</code> corresponds to the
                        <code class="filename">-p</code> argument
                        passed to <code class="filename">powertop</code>.</p></li><li class="listitem"><p><span class="emphasis"><em><code class="filename">LatencyTOP and Perf</code>:</em></span>
                        <code class="filename">latencytop</code> identifies system latency, while
                        <code class="filename">perf</code> monitors the system's
                        performance counter registers.
                        Selecting either of these tools causes an RSE terminal view to appear
                        from which you can run the tools.
                        Both tools refresh the entire screen to display results while they run.</p></li></ul></div><p>
            </p></div><div class="section" title="4.2.2.8. Customizing an Image Using a BitBake Commander Project and Hob"><div class="titlepage"><div><div><h4 class="title"><a id="customizing-an-image-using-a-bitbake-commander-project-and-hob"></a>4.2.2.8. Customizing an Image Using a BitBake Commander Project and Hob</h4></div></div></div><p>
                Within Eclipse, you can create a Yocto BitBake Commander project,
                edit the metadata, and then use the
                <a class="ulink" href="http://www.yoctoproject.org/projects/hob" target="_top">Hob</a> to build a customized
                image all within one IDE.
            </p><div class="section" title="4.2.2.8.1. Creating the Yocto BitBake Commander Project"><div class="titlepage"><div><div><h5 class="title"><a id="creating-the-yocto-bitbake-commander-project"></a>4.2.2.8.1. Creating the Yocto BitBake Commander Project</h5></div></div></div><p>
                    To create a Yocto BitBake Commander project, follow these steps:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <code class="filename">Window -&gt; Open Perspective -&gt; Other</code>
                            and then choose <code class="filename">Bitbake Commander</code>.</p></li><li class="listitem"><p>Click <code class="filename">OK</code> to change the Eclipse perspective into the
                            Bitbake Commander perspective.</p></li><li class="listitem"><p>Select <code class="filename">File -&gt; New -&gt; Project</code> to create a new Yocto
                            Bitbake Commander project.</p></li><li class="listitem"><p>Choose <code class="filename">Yocto Project Bitbake Commander -&gt; New Yocto Project</code>
                            and click <code class="filename">Next</code>.</p></li><li class="listitem"><p>Enter the Project Name and choose the Project Location.
                            The Yocto project's metadata files will be put under the directory
                            <code class="filename">&lt;project_location&gt;/&lt;project_name&gt;</code>.
                            If that directory does not exist, you need to check
                            the "Clone from Yocto Git Repository" box, which would execute a
                            <code class="filename">git clone</code> command to get the project's metadata files.
                            </p></li><li class="listitem"><p>Select <code class="filename">Finish</code> to create the project.</p></li></ol></div><p>
                </p></div><div class="section" title="4.2.2.8.2. Editing the Metadata Files"><div class="titlepage"><div><div><h5 class="title"><a id="editing-the-metadata-files"></a>4.2.2.8.2. Editing the Metadata Files</h5></div></div></div><p>
                    After you create the Yocto Bitbake Commander project, you can modify the metadata files
                    by opening them in the project.
                    When editing recipe files (<code class="filename">.bb</code> files), you can view BitBake
                    variable values and information by hovering the mouse pointer over the variable name and
                    waiting a few seconds.
                </p><p>
                    To edit the metadata, follow these steps:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select your Yocto Bitbake Commander project.</p></li><li class="listitem"><p>Select <code class="filename">File -&gt; New -&gt; Yocto BitBake Commander -&gt; BitBake Recipe</code>
                            to open a new recipe wizard.</p></li><li class="listitem"><p>Point to your source by filling in the "SRC_URL" field.
                            For example, you can add a recipe to your
                            <a class="link" href="#source-directory">Source Directory</a>
                            by defining "SRC_URL" as follows:
                            </p><pre class="literallayout">
     ftp://ftp.gnu.org/gnu/m4/m4-1.4.9.tar.gz
                            </pre></li><li class="listitem"><p>Click "Populate" to calculate the archive md5, sha256,
                            license checksum values and to auto-generate the recipe filename.</p></li><li class="listitem"><p>Fill in the "Description" field.</p></li><li class="listitem"><p>Be sure values for all required fields exist.</p></li><li class="listitem"><p>Click <code class="filename">Finish</code>.</p></li></ol></div><p>
                </p></div><div class="section" title="4.2.2.8.3. Building and Customizing the Image"><div class="titlepage"><div><div><h5 class="title"><a id="buiding-and-customizing-the-image"></a>4.2.2.8.3. Building and Customizing the Image</h5></div></div></div><p>
                    To build and customize the image in Eclipse, follow these steps:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select your Yocto Bitbake Commander project.</p></li><li class="listitem"><p>Select <code class="filename">Project -&gt; Launch HOB</code>.</p></li><li class="listitem"><p>Enter the Build Directory where you want to put your final images.</p></li><li class="listitem"><p>Click <code class="filename">OK</code> to launch Hob.</p></li><li class="listitem"><p>Use Hob to customize and build your own images.
                            For information on Hob, see the
                            <a class="ulink" href="http://www.yoctoproject.org/projects/hob" target="_top">Hob Project Page</a> on the
                            Yocto Project website.</p></li></ol></div><p>
                </p></div></div></div><div class="section" title="4.2.3. Workflow Using Stand-alone Cross-development Toolchains"><div class="titlepage"><div><div><h3 class="title"><a id="workflow-using-stand-alone-cross-development-toolchains"></a>4.2.3. Workflow Using Stand-alone Cross-development Toolchains</h3></div></div></div><p>
            If you want to develop an application without prior installation of the ADT, you
            still can employ the cross-development toolchain, the QEMU emulator, and a number of supported
            target image files.
            You just need to follow these general steps:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Install the cross-development toolchain for your target hardware:</em></span>
                    For information on how to install the toolchain, see the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#using-an-existing-toolchain-tarball" target="_top">Using a Cross-Toolchain Tarball</a>"
                    section
                    in the Yocto Project Application Developer's Guide.</p></li><li class="listitem"><p><span class="emphasis"><em>Download the Target Image:</em></span>  The Yocto Project supports
                    several target architectures and has many pre-built kernel images and root filesystem
                    images.</p><p>If you are going to develop your application on hardware, go to the
                    <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/machines" target="_top"><code class="filename">machines</code></a>
                    download area and choose a target machine area
                    from which to download the kernel image and root filesystem.
                    This download area could have several files in it that support development using
                    actual hardware.
                    For example, the area might contain <code class="filename">.hddimg</code> files that combine the
                    kernel image with the filesystem, boot loaders, etc.
                    Be sure to get the files you need for your particular development process.</p><p>If you are going to develop your application and then run and test it using the QEMU
                    emulator, go to the
                    <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-1.4/machines/qemu" target="_top"><code class="filename">machines/qemu</code></a>
                    download area.
                    From this area, go down into the directory for your target architecture
                    (e.g. <code class="filename">qemux86_64</code> for an
                    <span class="trademark">Intel</span>®-based 64-bit architecture).
                    Download kernel, root filesystem, and any other files you need for your process.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>In order to use the root filesystem in QEMU, you need to extract it.
                    See the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/adt-manual/adt-manual.html#extracting-the-root-filesystem" target="_top">Extracting the Root Filesystem</a>"
                    section for information on how to extract the root filesystem.</div></li><li class="listitem"><p><span class="emphasis"><em>Develop and Test your Application:</em></span>  At this point,
                    you have the tools to develop your application.
                    If you need to separately install and use the QEMU emulator, you can go to
                    <a class="ulink" href="http://www.qemu.org" target="_top">QEMU Home Page</a> to download and learn about the
                    emulator.</p></li></ol></div><p>
        </p></div></div><div class="section" title="4.3. Modifying Temporary Source Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="modifying-temporary-source-code"></a>4.3. Modifying Temporary Source Code</h2></div></div></div><p>
        You might
        find it helpful during development to modify the temporary source code used by recipes
        to build packages.
        For example, suppose you are developing a patch and you need to experiment a bit
        to figure out your solution.
        After you have initially built the package, you can iteratively tweak the
        source code, which is located in the
        <a class="link" href="#build-directory">Build Directory</a>, and then
        you can force a re-compile and quickly test your altered code.
        Once you settle on a solution, you can then preserve your changes in the form of
        patches.
        You can accomplish these steps all within either a
        <a class="ulink" href="http://savannah.nongnu.org/projects/quilt" target="_top">Quilt</a> or
        <a class="link" href="#git" title="3.6. Git">Git</a> workflow.
    </p><div class="section" title="4.3.1. Finding the Temporary Source Code"><div class="titlepage"><div><div><h3 class="title"><a id="finding-the-temporary-source-code"></a>4.3.1. Finding the Temporary Source Code</h3></div></div></div><p>
            During a build, the unpacked temporary source code used by recipes
            to build packages is available in the Build Directory as
            defined by the
            <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top">S</a></code> variable.
            Below is the default value for the <code class="filename">S</code> variable as defined in the
            <code class="filename">meta/conf/bitbake.conf</code> configuration file in the
            <a class="link" href="#source-directory">Source Directory</a>:
            </p><pre class="literallayout">
     S = ${WORKDIR}/${BP}
            </pre><p>
            You should be aware that many recipes override the <code class="filename">S</code> variable.
            For example, recipes that fetch their source from Git usually set
            <code class="filename">S</code> to <code class="filename">${WORKDIR}/git</code>.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                The
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BP" target="_top"><code class="filename">BP</code></a>
                represents the base recipe name, which consists of the name and version:
                <pre class="literallayout">
     BP = ${BPN}-${PV}
                </pre></div><p>
        </p><p>
            The path to the work directory for the recipe
            (<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a>) depends
            on the recipe name and the architecture of the target device.
            For example, here is the work directory for recipes and resulting packages that are
            not device-dependent:
            </p><pre class="literallayout">
     ${TMPDIR}/work/${PACKAGE_ARCH}-poky-${TARGET_OS}/${PN}-${PV}-${PR}
            </pre><p>
            Let's look at an example without variables.
            Assuming a top-level <a class="link" href="#source-directory">Source Directory</a>
            named <code class="filename">poky</code>
            and a default Build Directory of <code class="filename">poky/build</code>,
            the following is the work directory for the <code class="filename">acl</code> recipe that
            creates the <code class="filename">acl</code> package:
            </p><pre class="literallayout">
     ~/poky/build/tmp/work/i586-poky-linux/acl-2.2.51-r3
            </pre><p>
        </p><p>
            If your resulting package is dependent on the target device,
            the work directory varies slightly:
            </p><pre class="literallayout">
     ${TMPDIR}/work/${MACHINE}-poky-${TARGET_OS}/${PN}-${PV}-${PR}
            </pre><p>
            Again, assuming top-level Source Directory named <code class="filename">poky</code>
            and a default Build Directory of <code class="filename">poky/build</code>, the
            following are the work and temporary source directories, respectively,
            for the <code class="filename">acl</code> package that is being
            built for a MIPS-based device:
            </p><pre class="literallayout">
     ~/poky/build/tmp/work/mips-poky-linux/acl-2.2.51-r2
     ~/poky/build/tmp/work/mips-poky-linux/acl-2.2.51-r2/acl-2.2.51
            </pre><p>
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            To better understand how the OpenEmbedded build system resolves directories during the
            build process, see the glossary entries for the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-TMPDIR" target="_top"><code class="filename">TMPDIR</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-TOPDIR" target="_top"><code class="filename">TOPDIR</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGE_ARCH" target="_top"><code class="filename">PACKAGE_ARCH</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-TARGET_OS" target="_top"><code class="filename">TARGET_OS</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a>,
            and
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top"><code class="filename">PR</code></a>
            variables in the Yocto Project Reference Manual.
        </div><p>
            Now that you know where to locate the directory that has the temporary source code,
            you can use a Quilt or Git workflow to make your edits, test the changes,
            and preserve the changes in the form of patches.
        </p></div><div class="section" title="4.3.2. Using a Quilt Workflow"><div class="titlepage"><div><div><h3 class="title"><a id="using-a-quilt-workflow"></a>4.3.2. Using a Quilt Workflow</h3></div></div></div><p>
            <a class="ulink" href="http://savannah.nongnu.org/projects/quilt" target="_top">Quilt</a>
            is a powerful tool that allows you to capture source code changes without having
            a clean source tree.
            This section outlines the typical workflow you can use to modify temporary source code,
            test changes, and then preserve the changes in the form of a patch all using Quilt.
        </p><p>
            Follow these general steps:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Find the Source Code:</em></span>
                    The temporary source code used by the OpenEmbedded build system is kept in the
                    Build Directory.
                    See the
                    "<a class="link" href="#finding-the-temporary-source-code" title="4.3.1. Finding the Temporary Source Code">Finding the Temporary Source Code</a>"
                    section to learn how to locate the directory that has the temporary source code for a
                    particular package.</p></li><li class="listitem"><p><span class="emphasis"><em>Change Your Working Directory:</em></span>
                    You need to be in the directory that has the temporary source code.
                    That directory is defined by the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top"><code class="filename">S</code></a>
                    variable.</p></li><li class="listitem"><p><span class="emphasis"><em>Create a New Patch:</em></span>
                    Before modifying source code, you need to create a new patch.
                    To create a new patch file, use <code class="filename">quilt new</code> as below:
                    </p><pre class="literallayout">
     $ quilt new my_changes.patch
                    </pre></li><li class="listitem"><p><span class="emphasis"><em>Notify Quilt and Add Files:</em></span>
                    After creating the patch, you need to notify Quilt about the files
                    you plan to edit.
                    You notify Quilt by adding the files to the patch you just created:
                    </p><pre class="literallayout">
     $ quilt add file1.c file2.c file3.c
                    </pre><p>
                    </p></li><li class="listitem"><p><span class="emphasis"><em>Edit the Files:</em></span>
                    Make your changes in the temporary source code to the files you added
                    to the patch.</p></li><li class="listitem"><p><span class="emphasis"><em>Test Your Changes:</em></span>
                    Once you have modified the source code, the easiest way to test your changes
                    is by calling the <code class="filename">compile</code> task as shown in the following example:
                    </p><pre class="literallayout">
     $ bitbake -c compile -f &lt;name_of_package&gt;
                    </pre><p>
                    The <code class="filename">-f</code> or <code class="filename">--force</code>
                    option forces re-execution of the specified task.
                    If you find problems with your code, you can just keep editing and
                    re-testing iteratively until things work as expected.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>All the modifications you make to the temporary source code
                    disappear once you <code class="filename">-c clean</code> or
                    <code class="filename">-c cleanall</code> with BitBake for the package.
                    Modifications will also disappear if you use the <code class="filename">rm_work</code>
                    feature as described in the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>"
                    section of the Yocto Project Quick Start.
                    </div></li><li class="listitem"><p><span class="emphasis"><em>Generate the Patch:</em></span>
                    Once your changes work as expected, you need to use Quilt to generate the final patch that
                    contains all your modifications.
                    </p><pre class="literallayout">
     $ quilt refresh
                    </pre><p>
                    At this point the <code class="filename">my_changes.patch</code> file has all your edits made
                    to the <code class="filename">file1.c</code>, <code class="filename">file2.c</code>, and
                    <code class="filename">file3.c</code> files.</p><p>You can find the resulting patch file in the <code class="filename">patches/</code>
                    subdirectory of the source (<code class="filename">S</code>) directory.</p></li><li class="listitem"><p><span class="emphasis"><em>Copy the Patch File:</em></span>
                    For simplicity, copy the patch file into a directory named <code class="filename">files</code>,
                    which you can create in the same directory that holds the recipe
                    (<code class="filename">.bb</code>) file or the
                    append (<code class="filename">.bbappend</code>) file.
                    Placing the patch here guarantees that the OpenEmbedded build system will find
                    the patch.
                    Next, add the patch into the
                    <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code>
                    of the recipe.
                    Here is an example:
                    </p><pre class="literallayout">
     SRC_URI += "file://my_changes.patch"
                    </pre></li><li class="listitem"><p><span class="emphasis"><em>Increment the Recipe Revision Number:</em></span>
                    Finally, don't forget to 'bump' the
                    <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top">PR</a></code>
                    value in the recipe since the resulting packages have changed.</p></li></ol></div><p>
        </p></div><div class="section" title="4.3.3. Using a Git Workflow"><div class="titlepage"><div><div><h3 class="title"><a id="using-a-git-workflow"></a>4.3.3. Using a Git Workflow</h3></div></div></div><p>
            Git is an even more powerful tool that allows you to capture source code changes without having
            a clean source tree.
            This section outlines the typical workflow you can use to modify temporary source code,
            test changes, and then preserve the changes in the form of a patch all using Git.
            For general information on Git as it is used in the Yocto Project, see the
            "<a class="link" href="#git" title="3.6. Git">Git</a>" section.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            This workflow uses Git only for its ability to manage local changes to the source code
            and produce patches independent of any version control system used with the Yocto Project.
        </div><p>
            Follow these general steps:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Find the Source Code:</em></span>
                    The temporary source code used by the OpenEmbedded build system is kept in the
                    Build Directory.
                    See the
                    "<a class="link" href="#finding-the-temporary-source-code" title="4.3.1. Finding the Temporary Source Code">Finding the Temporary Source Code</a>"
                    section to learn how to locate the directory that has the temporary source code for a
                    particular package.</p></li><li class="listitem"><p><span class="emphasis"><em>Change Your Working Directory:</em></span>
                    You need to be in the directory that has the temporary source code.
                    That directory is defined by the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top"><code class="filename">S</code></a>
                    variable.</p></li><li class="listitem"><p><span class="emphasis"><em>If needed, initialize a Git Repository:</em></span>
                    If the recipe you are working with does not use a Git fetcher,
                    you need to set up a Git repository as follows:
                    </p><pre class="literallayout">
     $ git init
     $ git add *
     $ git commit -m "initial revision"
                    </pre><p>
                    The above Git commands initialize a Git repository that is based on the
                    files in your current working directory, stage all the files, and commit
                    the files.
                    At this point, your Git repository is aware of all the source code files.
                    Any edits you now make to files can be committed later and will be tracked by
                    Git.</p></li><li class="listitem"><p><span class="emphasis"><em>Edit the Files:</em></span>
                    Make your changes to the temporary source code.</p></li><li class="listitem"><p><span class="emphasis"><em>Test Your Changes:</em></span>
                    Once you have modified the source code, the easiest way to test your changes
                    is by calling the <code class="filename">compile</code> task as shown in the following example:
                    </p><pre class="literallayout">
     $ bitbake -c compile -f &lt;name_of_package&gt;
                    </pre><p>
                    The <code class="filename">-f</code> or <code class="filename">--force</code>
                    option forces re-execution of the specified task.
                    If you find problems with your code, you can just keep editing and
                    re-testing iteratively until things work as expected.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>All the modifications you make to the temporary source code
                    disappear once you <code class="filename">-c clean</code>, <code class="filename">-c cleansstate</code>,
                    or <code class="filename">-c cleanall</code> with BitBake for the package.
                    Modifications will also disappear if you use the <code class="filename">rm_work</code>
                    feature as described in the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>"
                    section of the Yocto Project Quick Start.
                    </div></li><li class="listitem"><p><span class="emphasis"><em>See the List of Files You Changed:</em></span>
                    Use the <code class="filename">git status</code> command to see what files you have actually edited.
                    The ability to have Git track the files you have changed is an advantage that this
                    workflow has over the Quilt workflow.
                    Here is the Git command to list your changed files:
                    </p><pre class="literallayout">
     $ git status
                    </pre></li><li class="listitem"><p><span class="emphasis"><em>Stage the Modified Files:</em></span>
                    Use the <code class="filename">git add</code> command to stage the changed files so they
                    can be committed as follows:
                    </p><pre class="literallayout">
     $ git add file1.c file2.c file3.c
                    </pre></li><li class="listitem"><p><span class="emphasis"><em>Commit the Staged Files and View Your Changes:</em></span>
                    Use the <code class="filename">git commit</code> command to commit the changes to the
                    local repository.
                    Once you have committed the files, you can use the <code class="filename">git log</code>
                    command to see your changes:
                    </p><pre class="literallayout">
     $ git commit -m "&lt;commit-summary-message&gt;"
     $ git log
                    </pre><p>
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The name of the patch file created in the next step is based on your
                        <code class="filename">commit-summary-message</code>.</div></li><li class="listitem"><p><span class="emphasis"><em>Generate the Patch:</em></span>
                    Once the changes are committed, use the <code class="filename">git format-patch</code>
                    command to generate a patch file:
                    </p><pre class="literallayout">
     $ git format-patch -1
                    </pre><p>
                    Specifying "-1" causes Git to generate the
                    patch file for the most recent commit.</p><p>At this point, the patch file has all your edits made
                    to the <code class="filename">file1.c</code>, <code class="filename">file2.c</code>, and
                    <code class="filename">file3.c</code> files.
                    You can find the resulting patch file in the current directory and it
                    is named according to the <code class="filename">git commit</code> summary line.
                    The patch file ends with <code class="filename">.patch</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>Copy the Patch File:</em></span>
                    For simplicity, copy the patch file into a directory named <code class="filename">files</code>,
                    which you can create in the same directory that holds the recipe
                    (<code class="filename">.bb</code>) file or the
                    append (<code class="filename">.bbappend</code>) file.
                    Placing the patch here guarantees that the OpenEmbedded build system will find
                    the patch.
                    Next, add the patch into the
                    <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code>
                    of the recipe.
                    Here is an example:
                    </p><pre class="literallayout">
     SRC_URI += "file://0001-&lt;commit-summary-message&gt;.patch"
                    </pre></li><li class="listitem"><p><span class="emphasis"><em>Increment the Recipe Revision Number:</em></span>
                    Finally, don't forget to 'bump' the
                    <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top">PR</a></code>
                    value in the recipe since the resulting packages have changed.</p></li></ol></div><p>
        </p></div></div><div class="section" title="4.4. Image Development Using Hob"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="image-development-using-hob"></a>4.4. Image Development Using Hob</h2></div></div></div><p>
        The <a class="ulink" href="http://www.yoctoproject.org/projects/hob" target="_top">Hob</a> is a graphical user interface for the
        OpenEmbedded build system, which is based on BitBake.
        You can use the Hob to build custom operating system images within the Yocto Project build environment.
        Hob simply provides a friendly interface over the build system used during system development.
        In other words, building images with the Hob lets you take care of common build tasks more easily.
    </p><p>
        For a better understanding of Hob, see the project page at
        <a class="ulink" href="http://www.yoctoproject.org/projects/hob" target="_top">http://www.yoctoproject.org/projects/hob</a> on the Yocto Project website.
        The page has a short introductory training video on Hob.
        The following lists some features of Hob:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can setup and run Hob using these commands:
            </p><pre class="literallayout">
     $ source oe-init-build-env
     $ hob
            </pre></li><li class="listitem"><p>You can set the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-MACHINE" target="_top"><code class="filename">MACHINE</code></a>
                for which you are building the image.</p></li><li class="listitem"><p>You can modify various policy settings such as the package format used to build with,
                the parrallelism BitBake uses, whether or not to build an external toolchain, and which host
                to build against.</p></li><li class="listitem"><p>You can manage
                <a class="link" href="#understanding-and-creating-layers" title="5.1. Understanding and Creating Layers">layers</a>.</p></li><li class="listitem"><p>You can select a base image and then add extra packages for your custom build.
                </p></li><li class="listitem"><p>You can launch and monitor the build from within Hob.</p></li></ul></div><p>
    </p></div><div class="section" title="4.5. Using a Development Shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="platdev-appdev-devshell"></a>4.5. Using a Development Shell</h2></div></div></div><p>
        When debugging certain commands or even when just editing packages,
        <code class="filename">devshell</code> can be a useful tool.
        When you invoke <code class="filename">devshell</code>, source files are
        extracted into your working directory and patches are applied.
        Then, a new terminal is opened and you are placed in the working directory.
        In the new terminal, all the OpenEmbedded build-related environment variables are
        still defined so you can use commands such as <code class="filename">configure</code> and
        <code class="filename">make</code>.
        The commands execute just as if the OpenEmbedded build system were executing them.
        Consequently, working this way can be helpful when debugging a build or preparing
        software to be used with the OpenEmbedded build system.
    </p><p>
        Following is an example that uses <code class="filename">devshell</code> on a target named
        <code class="filename">matchbox-desktop</code>:
        </p><pre class="literallayout">
     $ bitbake matchbox-desktop -c devshell
        </pre><p>
    </p><p>
        This command spawns a terminal with a shell prompt within the OpenEmbedded build environment.
        The <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-OE_TERMINAL" target="_top"><code class="filename">OE_TERMINAL</code></a>
        controls what type of shell is opened.
    </p><p>
        For spawned terminals, the following occurs:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <code class="filename">PATH</code> variable includes the
                cross-toolchain.</p></li><li class="listitem"><p>The <code class="filename">pkgconfig</code> variables find the correct
                <code class="filename">.pc</code> files.</p></li><li class="listitem"><p>The <code class="filename">configure</code> command finds the
                Yocto Project site files as well as any other necessary files.</p></li></ul></div><p>
    </p><p>
        Within this environment, you can run configure or compile
        commands as if they were being run by
        the OpenEmbedded build system itself.
        As noted earlier, the working directory also automatically changes to the
        Source Directory (<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top"><code class="filename">S</code></a>).
    </p><p>
        When you are finished, you just exit the shell or close the terminal window.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            It is worth remembering that when using <code class="filename">devshell</code>
            you need to use the full compiler name such as <code class="filename">arm-poky-linux-gnueabi-gcc</code>
            instead of just using <code class="filename">gcc</code>.
            The same applies to other applications such as <code class="filename">binutils</code>,
            <code class="filename">libtool</code> and so forth.
            BitBake sets up environment variables such as <code class="filename">CC</code>
            to assist applications, such as <code class="filename">make</code> to find the correct tools.
        </p><p>
            It is also worth noting that <code class="filename">devshell</code> still works over
            X11 forwarding and similar situations
        </p></div></div></div>

    <div class="chapter" title="Chapter 5. Common Tasks"><div class="titlepage"><div><div><h2 class="title"><a id="extendpoky"></a>Chapter 5. Common Tasks</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#understanding-and-creating-layers">5.1. Understanding and Creating Layers</a></span></dt><dd><dl><dt><span class="section"><a href="#yocto-project-layers">5.1.1. Layers</a></span></dt><dt><span class="section"><a href="#creating-your-own-layer">5.1.2. Creating Your Own Layer</a></span></dt><dt><span class="section"><a href="#enabling-your-layer">5.1.3. Enabling Your Layer</a></span></dt><dt><span class="section"><a href="#using-bbappend-files">5.1.4. Using .bbappend Files</a></span></dt><dt><span class="section"><a href="#prioritizing-your-layer">5.1.5. Prioritizing Your Layer</a></span></dt><dt><span class="section"><a href="#managing-layers">5.1.6. Managing Layers</a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-extend-customimage">5.2. Customizing Images</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-extend-customimage-custombb">5.2.1. Customizing Images Using Custom .bb Files</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-customtasks">5.2.2. Customizing Images Using Custom Package Groups</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-imagefeatures">5.2.3. Customizing Images Using Custom <code class="filename">IMAGE_FEATURES</code> and
                <code class="filename">EXTRA_IMAGE_FEATURES</code></a></span></dt><dt><span class="section"><a href="#usingpoky-extend-customimage-localconf">5.2.4. Customizing Images Using <code class="filename">local.conf</code></a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-extend-addpkg">5.3. Adding a Package</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-extend-addpkg-singlec">5.3.1. Single .c File Package (Hello World!)</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-autotools">5.3.2. Autotooled Package</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-makefile">5.3.3. Makefile-Based Package</a></span></dt><dt><span class="section"><a href="#splitting-an-application-into-multiple-packages">5.3.4. Splitting an Application into Multiple Packages</a></span></dt><dt><span class="section"><a href="#including-static-library-files">5.3.5. Including Static Library Files</a></span></dt><dt><span class="section"><a href="#usingpoky-extend-addpkg-postinstalls">5.3.6. Post Install Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#platdev-newmachine">5.4. Adding a New Machine</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-newmachine-conffile">5.4.1. Adding the Machine Configuration File</a></span></dt><dt><span class="section"><a href="#platdev-newmachine-kernel">5.4.2. Adding a Kernel for the Machine</a></span></dt><dt><span class="section"><a href="#platdev-newmachine-formfactor">5.4.3. Adding a Formfactor Configuration File</a></span></dt></dl></dd><dt><span class="section"><a href="#building-multiple-architecture-libraries-into-one-image">5.5. Combining Multiple Versions of Library Files into One Image</a></span></dt><dd><dl><dt><span class="section"><a href="#preparing-to-use-multilib">5.5.1. Preparing to use Multilib</a></span></dt><dt><span class="section"><a href="#using-multilib">5.5.2. Using Multilib</a></span></dt><dt><span class="section"><a href="#additional-implementation-details">5.5.3. Additional Implementation Details</a></span></dt></dl></dd><dt><span class="section"><a href="#configuring-the-kernel">5.6. Configuring the Kernel</a></span></dt><dd><dl><dt><span class="section"><a href="#using-menuconfig">5.6.1. Using  <code class="filename">menuconfig</code></a></span></dt><dt><span class="section"><a href="#creating-config-fragments">5.6.2. Creating Configuration Fragments</a></span></dt><dt><span class="section"><a href="#fine-tuning-the-kernel-configuration-file">5.6.3. Fine-tuning the Kernel Configuration File</a></span></dt></dl></dd><dt><span class="section"><a href="#patching-the-kernel">5.7. Patching the Kernel</a></span></dt><dd><dl><dt><span class="section"><a href="#create-a-layer-for-your-changes">5.7.1. Create a Layer for your Changes</a></span></dt><dt><span class="section"><a href="#finding-the-kernel-source-code">5.7.2. Finding the Kernel Source Code</a></span></dt><dt><span class="section"><a href="#creating-the-patch">5.7.3. Creating the Patch</a></span></dt><dt><span class="section"><a href="#get-your-layer-setup-for-the-build">5.7.4. Get Your Layer Setup for the Build</a></span></dt><dt><span class="section"><a href="#set-up-for-the-build">5.7.5. Set Up for the Build</a></span></dt><dt><span class="section"><a href="#build-and-booting-the-modified-qemu-kernel-image">5.7.6. Build and Booting the Modified QEMU Kernel Image</a></span></dt><dt><span class="section"><a href="#verify-your-changes">5.7.7. Verify Your Changes</a></span></dt></dl></dd><dt><span class="section"><a href="#usingpoky-changes-updatingimages">5.8. Updating Existing Images</a></span></dt><dt><span class="section"><a href="#working-with-packages">5.9. Working with Packages</a></span></dt><dd><dl><dt><span class="section"><a href="#usingpoky-changes-prbump">5.9.1. Incrementing a Package Revision Number</a></span></dt><dt><span class="section"><a href="#usingpoky-configuring-DISTRO_PN_ALIAS">5.9.2. Handling a Package Name Alias</a></span></dt><dt><span class="section"><a href="#handling-optional-module-packaging">5.9.3. Handling Optional Module Packaging</a></span></dt></dl></dd><dt><span class="section"><a href="#building-software-from-an-external-source">5.10. Building Software from an External Source</a></span></dt><dt><span class="section"><a href="#excluding-recipes-from-the-build">5.11. Excluding Recipes From the Build</a></span></dt><dt><span class="section"><a href="#platdev-appdev-srcrev">5.12. Using an External SCM</a></span></dt><dt><span class="section"><a href="#platdev-gdb-remotedebug">5.13. Debugging With the GNU Project Debugger (GDB) Remotely</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-gdb-remotedebug-launch-gdbserver">5.13.1. Launching Gdbserver on the Target</a></span></dt><dt><span class="section"><a href="#platdev-gdb-remotedebug-launch-gdb">5.13.2. Launching GDB on the Host Computer</a></span></dt></dl></dd><dt><span class="section"><a href="#platdev-oprofile">5.14. Profiling with OProfile</a></span></dt><dd><dl><dt><span class="section"><a href="#platdev-oprofile-target">5.14.1. Profiling on the Target</a></span></dt><dt><span class="section"><a href="#platdev-oprofile-oprofileui">5.14.2. Using OProfileUI</a></span></dt></dl></dd><dt><span class="section"><a href="#maintaining-open-source-license-compliance-during-your-products-lifecycle">5.15. Maintaining Open Source License Compliance During Your Product's Lifecycle</a></span></dt><dd><dl><dt><span class="section"><a href="#providing-the-source-code">5.15.1. Providing the Source Code</a></span></dt><dt><span class="section"><a href="#providing-license-text">5.15.2. Providing License Text</a></span></dt><dt><span class="section"><a href="#providing-compilation-scripts-and-source-code-modifications">5.15.3. Providing Compilation Scripts and Source Code Modifications</a></span></dt></dl></dd></dl></div><p>
        This chapter describes standard tasks such as adding new
        software packages, extending or customizing images, and porting work to
        new hardware (adding a new machine).
        The chapter also describes how to combine multiple
        versions of library files into a single image, how to handle a package name alias, and
        gives advice about how to make changes to the Yocto Project to achieve the best results.
    </p><div class="section" title="5.1. Understanding and Creating Layers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="understanding-and-creating-layers"></a>5.1. Understanding and Creating Layers</h2></div></div></div><p>
            The OpenEmbedded build system supports organizing <a class="link" href="#metadata">metadata</a>
            into multiple layers.
            Layers allow you to isolate different types of customizations from each other.
            You might find it tempting to keep everything in one layer when working on a single project.
            However, the more modular you organize your metadata, the easier it is to cope with future changes.
        </p><p>
            To illustrate how layers are used to keep things modular, consider machine customizations.
            These types of customizations typically reside in a BSP Layer.
            Furthermore, the machine customizations should be isolated from recipes and metadata that support
            a new GUI environment, for example.
            This situation gives you a couple of layers: one for the machine configurations, and one for the
            GUI environment.
            It is important to understand, however, that the BSP layer can still make machine-specific
            additions to recipes within the GUI environment layer without polluting the GUI layer itself
            with those machine-specific changes.
            You can accomplish this through a recipe that is a BitBake append
            (<code class="filename">.bbappend</code>) file, which is described later in this section.
        </p><p>
        </p><div class="section" title="5.1.1. Layers"><div class="titlepage"><div><div><h3 class="title"><a id="yocto-project-layers"></a>5.1.1. Layers</h3></div></div></div><p>
                The Source Directory contains several layers right out of the box.
                You can easily identify a layer in the Source Directory by its folder name.
                Folders that are layers begin with the string <code class="filename">meta</code>.
                For example, when you set up the <a class="link" href="#source-directory">Source Directory</a>
                structure, you will see several layers: <code class="filename">meta</code>,
                <code class="filename">meta-hob</code>, <code class="filename">meta-skeleton</code>,
                <code class="filename">meta-yocto</code>, and <code class="filename">meta-yocto-bsp</code>.
                Each of these folders is a layer.
            </p><p>
                Furthermore, if you set up a local copy of the <code class="filename">meta-intel</code> Git repository
                and then explore that folder, you will discover many BSP layers within the
                <code class="filename">meta-intel</code> layer.
                For more information on BSP layers, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP Layers</a>"
                section in the Yocto Project Board Support Package (BSP) Developer's Guide.
            </p></div><div class="section" title="5.1.2. Creating Your Own Layer"><div class="titlepage"><div><div><h3 class="title"><a id="creating-your-own-layer"></a>5.1.2. Creating Your Own Layer</h3></div></div></div><p>
                It is very easy to create your own layer to use with the OpenEmbedded build system.
                Follow these general steps to create your layer:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Check Existing Layers:</em></span> Before creating a new layer,
                        you should be sure someone has not already created a layer containing the metadata
                        you need.
                        You can see the
                        <a class="ulink" href="http://www.openembedded.org/wiki/LayerIndex" target="_top"><code class="filename">LayerIndex</code></a>
                        for a list of layers from the OpenEmbedded community that can be used in the
                        Yocto Project.</p></li><li class="listitem"><p><span class="emphasis"><em>Create a Directory:</em></span> Create the directory
                        for your layer.
                        Traditionally, prepend the name of the folder with the string
                        <code class="filename">meta</code>.
                        For example:
                        </p><pre class="literallayout">
     meta-mylayer
     meta-GUI_xyz
     meta-mymachine
                        </pre></li><li class="listitem"><p><span class="emphasis"><em>Create a Layer Configuration File:</em></span> Inside your new
                       layer folder, you need to create a <code class="filename">conf/layer.conf</code> file.
                       It is easiest to take an existing layer configuration file and copy that to your
                       layer's <code class="filename">conf</code> directory and then modify the file as needed.</p><p>The <code class="filename">meta-yocto/conf/layer.conf</code> file demonstrates the
                       required syntax:
                       </p><pre class="literallayout">
     # We have a conf and classes directory, add to BBPATH
     BBPATH := "${LAYERDIR}:${BBPATH}"

     # We have recipes-* directories, add to BBFILES
     BBFILES := "${BBFILES} ${LAYERDIR}/recipes-*/*/*.bb \
                 ${LAYERDIR}/recipes-*/*/*.bbappend"

     BBFILE_COLLECTIONS += "yocto"
     BBFILE_PATTERN_yocto := "^${LAYERDIR}/"
     BBFILE_PRIORITY_yocto = "5"
                        </pre><p>In the previous example, the recipes for the layers are added to
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBFILES" target="_top">BBFILES</a></code>.
                        The
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBFILE_COLLECTIONS" target="_top">BBFILE_COLLECTIONS</a></code>
                        variable is then appended with the layer name.
                        The
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBFILE_PATTERN" target="_top">BBFILE_PATTERN</a></code>
                        variable is set to a regular expression and is used to match files
                        from <code class="filename">BBFILES</code> into a particular layer.
                        In this case, immediate expansion of
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-LAYERDIR" target="_top">LAYERDIR</a></code>
                        sets <code class="filename">BBFILE_PATTERN</code> to the layer's path.
                        The
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBFILE_PRIORITY" target="_top">BBFILE_PRIORITY</a></code>
                        variable then assigns a priority to the layer.
                        Applying priorities is useful in situations where the same package might appear in multiple
                        layers and allows you to choose what layer should take precedence.</p><p>Note the use of the
                        <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-LAYERDIR" target="_top">LAYERDIR</a></code>
                        variable with the immediate expansion operator.
                        The <code class="filename">LAYERDIR</code> variable expands to the directory of the current layer and
                        requires the immediate expansion operator so that BitBake does not wait to expand the variable
                        when it's parsing a different directory.</p><p>Through the use of the <code class="filename">BBPATH</code> variable,
                        BitBake locates <code class="filename">.bbclass</code> files, configuration
                        files, and files that are included with <code class="filename">include</code>
                        and <code class="filename">require</code> statements.
                        For these cases, BitBake uses the first file with the matching name found in
                        <code class="filename">BBPATH</code>.
                        This is similar to the way the <code class="filename">PATH</code> variable is used for binaries.
                        We recommend, therefore, that you use unique <code class="filename">.bbclass</code>
                        and configuration file names in your custom layer.</p></li><li class="listitem"><p><span class="emphasis"><em>Add Content:</em></span> Depending on the type of layer,
                        add the content.
                        If the layer adds support for a machine, add the machine configuration in
                        a <code class="filename">conf/machine/</code> file within the layer.
                        If the layer adds distro policy, add the distro configuration in a
                        <code class="filename">conf/distro/</code> file with the layer.
                        If the layer introduces new recipes, put the recipes you need in
                        <code class="filename">recipes-*</code> subdirectories within the layer.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>In order to be compliant with the Yocto Project, a layer must contain
                            a <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-filelayout-readme" target="_top">README file.</a></div></li></ol></div><p>
            </p><p>
                To create layers that are easier to maintain, you should consider the following:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Avoid "overlaying" entire recipes from other layers in your
                        configuration.
                        In other words, don't copy an entire recipe into your layer and then modify it.
                        Use <code class="filename">.bbappend</code> files to override the parts of the
                        recipe you need to modify.</p></li><li class="listitem"><p>Avoid duplicating include files.
                        Use <code class="filename">.bbappend</code> files for each recipe that uses an include
                        file.
                        Or, if you are introducing a new recipe that requires the included file, use the
                        path relative to the original layer directory to refer to the file.
                        For example, use <code class="filename">require recipes-core/somepackage/somefile.inc</code>
                        instead of <code class="filename">require somefile.inc</code>.
                        If you're finding you have to overlay the include file, it could indicate a
                        deficiency in the include file in the layer to which it originally belongs.
                        If this is the case, you need to address that deficiency instead of overlaying
                        the include file.
                        For example, consider how Qt 4 database support plug-ins are configured.
                        The Source Directory does not have
                        MySQL or PostgreSQL, however OpenEmbedded's
                        layer <code class="filename">meta-oe</code> does.
                        Consequently, <code class="filename">meta-oe</code> uses <code class="filename">.bbappend</code>
                        files to modify the <code class="filename">QT_SQL_DRIVER_FLAGS</code> variable to enable
                        the appropriate plugins.
                        This variable was added to the <code class="filename">qt4.inc</code> include file in
                        the Source Directory specifically to allow the <code class="filename">meta-oe</code> layer
                        to be able to control which plugins are built.</p></li></ul></div><p>
            </p><p>
                We also recommend the following:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Store custom layers in a Git repository that uses the
                        <code class="filename">meta-&lt;layer_name&gt;</code> format.</p></li><li class="listitem"><p>Clone the repository alongside other <code class="filename">meta</code>
                        directories in the
                        <a class="link" href="#source-directory">Source Directory</a>.</p></li></ul></div><p>
                 Following these recommendations keeps your Source Directory and
                 its configuration entirely inside the Yocto Project's core base.
            </p></div><div class="section" title="5.1.3. Enabling Your Layer"><div class="titlepage"><div><div><h3 class="title"><a id="enabling-your-layer"></a>5.1.3. Enabling Your Layer</h3></div></div></div><p>
                Before the OpenEmbedded build system can use your new layer, you need to enable it.
                To enable your layer, simply add your layer's path to the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBLAYERS" target="_top">BBLAYERS</a></code>
                variable in your <code class="filename">conf/bblayers.conf</code> file, which is found in the
                <a class="link" href="#build-directory">Build Directory</a>.
                The following example shows how to enable a layer named <code class="filename">meta-mylayer</code>:
                </p><pre class="literallayout">
     LCONF_VERSION = "6"

     BBPATH = "${TOPDIR}"
     BBFILES ?= ""

     BBLAYERS ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       $HOME/poky/meta-yocto-bsp \
       $HOME/poky/meta-mylayer \
       "

     BBLAYERS_NON_REMOVABLE ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       "
                </pre><p>
            </p><p>
                BitBake parses each <code class="filename">conf/layer.conf</code> file as specified in the
                <code class="filename">BBLAYERS</code> variable within the <code class="filename">conf/bblayers.conf</code>
                file.
                During the processing of each <code class="filename">conf/layer.conf</code> file, BitBake adds the
                recipes, classes and configurations contained within the particular layer to the source
                directory.
            </p></div><div class="section" title="5.1.4. Using .bbappend Files"><div class="titlepage"><div><div><h3 class="title"><a id="using-bbappend-files"></a>5.1.4. Using .bbappend Files</h3></div></div></div><p>
                Recipes used to append metadata to other recipes are called BitBake append files.
                BitBake append files use the <code class="filename">.bbappend</code> file type suffix, while
                the corresponding recipes to which metadata is being appended use the
                <code class="filename">.bb</code> file type suffix.
            </p><p>
                A <code class="filename">.bbappend</code> file allows your layer to make additions or
                changes to the content of another layer's recipe without having to copy the other
                recipe into your layer.
                Your <code class="filename">.bbappend</code> file resides in your layer, while the underlying
                <code class="filename">.bb</code> recipe file to which you are appending metadata
                resides in a different layer.
            </p><p>
                Append files files must have the same name as the corresponding recipe.
                For example, the append file <code class="filename">someapp_1.4.bbappend</code> must
                apply to <code class="filename">someapp_1.4.bb</code>.
                This means the original recipe and append file names are version number specific.
                If the corresponding recipe is renamed to update to a newer version, the
                underlying <code class="filename">.bbappend</code> file must be renamed as well.
                During the build process, BitBake displays an error on starting if it detects a
                <code class="filename">.bbappend</code> file that does not have a corresponding recipe
                with a matching name.
            </p><p>
                Being able to append information to an existing recipe not only avoids duplication,
                but also automatically applies recipe changes in a different layer to your layer.
                If you were copying recipes, you would have to manually merge changes as they occur.
            </p><p>
                As an example, consider the main formfactor recipe and a corresponding formfactor
                append file both from the
                <a class="link" href="#source-directory">Source Directory</a>.
                Here is the main formfactor recipe, which is named <code class="filename">formfactor_0.0.bb</code> and
                located in the meta layer at <code class="filename">meta/recipes-bsp/formfactor</code>:
                </p><pre class="literallayout">
     DESCRIPTION = "Device formfactor information"
     SECTION = "base"
     LICENSE = "MIT"
     LIC_FILES_CHKSUM = "file://${COREBASE}/LICENSE;md5=3f40d7994397109285ec7b81fdeb3b58 \
                         file://${COREBASE}/meta/COPYING.MIT;md5=3da9cfbcb788c80a0384361b4de20420"
     PR = "r20"

     SRC_URI = "file://config file://machconfig"
     S = "${WORKDIR}"

     PACKAGE_ARCH = "${MACHINE_ARCH}"
     INHIBIT_DEFAULT_DEPS = "1"

     do_install() {
     	# Only install file if it has a contents
             install -d ${D}${sysconfdir}/formfactor/
             install -m 0644 ${S}/config ${D}${sysconfdir}/formfactor/
     	if [ -s "${S}/machconfig" ]; then
     	        install -m 0644 ${S}/machconfig ${D}${sysconfdir}/formfactor/
     	fi
     }
                </pre><p>
                Here is the append file, which is named <code class="filename">formfactor_0.0.bbappend</code> and is from the
                Crown Bay BSP Layer named <code class="filename">meta-intel/meta-crownbay</code>.
                The file is in <code class="filename">recipes-bsp/formfactor</code>:
                </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"

     PRINC := "${@int(PRINC) + 2}"
                </pre><p>
                This example adds or overrides files in
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                within a <code class="filename">.bbappend</code> by extending the path BitBake uses to search for files.
                The most reliable way to do this is by prepending the
                <code class="filename">FILESEXTRAPATHS</code> variable.
                For example, if you have your files in a directory that is named the same as your package
                (<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a>),
                you can add this directory by adding the following to your <code class="filename">.bbappend</code> file:
                </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
                </pre><p>
                Using the immediate expansion assignment operator <code class="filename">:=</code> is important because
                of the reference to <code class="filename">THISDIR</code>.
                The trailing colon character is important as it ensures that items in the list remain
                colon-separated.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>BitBake automatically defines the <code class="filename">THISDIR</code> variable.
                    You should never set this variable yourself.
                    Using <code class="filename">_prepend</code> ensures your path will be searched prior to other
                    paths in the final list.
                </div><p>
            </p></div><div class="section" title="5.1.5. Prioritizing Your Layer"><div class="titlepage"><div><div><h3 class="title"><a id="prioritizing-your-layer"></a>5.1.5. Prioritizing Your Layer</h3></div></div></div><p>
                Each layer is assigned a priority value.
                Priority values control which layer takes precedence if there are recipe files with
                the same name in multiple layers.
                For these cases, the recipe file from the layer with a higher priority number taking precedence.
                Priority values also affect the order in which multiple <code class="filename">.bbappend</code> files
                for the same recipe are applied.
                You can either specify the priority manually, or allow the build system to calculate it
                based on the layer's dependencies.
            </p><p>
                To specify the layer's priority manually, use the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBFILE_PRIORITY" target="_top"><code class="filename">BBFILE_PRIORITY</code></a>
                variable.
                For example:
                </p><pre class="literallayout">
     BBFILE_PRIORITY := "1"
                </pre><p>
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is possible for a recipe with a lower version number
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a>
                in a layer that has a higher priority to take precedence.</p><p>Also, the layer priority does not currently affect the precedence order of
                <code class="filename">.conf</code> or <code class="filename">.bbclass</code> files.
                Future versions of BitBake might address this.</p></div></div><div class="section" title="5.1.6. Managing Layers"><div class="titlepage"><div><div><h3 class="title"><a id="managing-layers"></a>5.1.6. Managing Layers</h3></div></div></div><p>
                You can use the BitBake layer management tool to provide a view into the structure of
                recipes across a multi-layer project.
                Being able to generate output that reports on configured layers with their paths and
                priorities and on <code class="filename">.bbappend</code> files and their applicable recipes
                can help to reveal potential problems.
            </p><p>
                Use the following form when running the layer management tool.
                </p><pre class="literallayout">
     $ bitbake-layers &lt;command&gt; [arguments]
                </pre><p>
                The following list describes the available commands:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename"><span class="emphasis"><em>help:</em></span></code>
                        Displays general help or help on a specified command.</p></li><li class="listitem"><p><code class="filename"><span class="emphasis"><em>show-layers:</em></span></code>
                        Show the current configured layers.</p></li><li class="listitem"><p><code class="filename"><span class="emphasis"><em>show-recipes:</em></span></code>
                        Lists available recipes and the layers that provide them.
                        </p></li><li class="listitem"><p><code class="filename"><span class="emphasis"><em>show-overlayed:</em></span></code>
                        Lists overlayed recipes.
                        A recipe is overlayed when a recipe with the same name exists in another layer
                        that has a higher layer priority.
                        </p></li><li class="listitem"><p><code class="filename"><span class="emphasis"><em>show-appends:</em></span></code>
                        Lists <code class="filename">.bbappend</code> files and the recipe files to which
                        they apply.</p></li><li class="listitem"><p><code class="filename"><span class="emphasis"><em>flatten:</em></span></code>
                        Flattens the layer configuration into a separate output directory.
                        Flattening your layer configuration builds a "flattened" directory that contains
                        the contents of all layers, with any overlayed recipes removed and any
                        <code class="filename">.bbappend</code> files appended to the corresponding recipes.
                        You might have to perform some manual cleanup of the flattened layer as follows:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Non-recipe files (such as patches) are overwritten.
                                The flatten command shows a warning for these files.</p></li><li class="listitem"><p>Anything beyond the normal layer setup has been added to
                                the <code class="filename">layer.conf</code> file.
                                Only the lowest priority layer's <code class="filename">layer.conf</code> is used.
                                </p></li><li class="listitem"><p>Overridden and appended items from <code class="filename">.bbappend</code>
                                files need to be cleaned up.
                                The contents of each <code class="filename">.bbappend</code> end up in the
                                flattened recipe.
                                However, if there are appended or changed variable values, you need to tidy
                                these up yourself.
                                Consider the following example.
                                Here, the <code class="filename">bitbake-layers</code> command adds the line
                                <code class="filename">#### bbappended ...</code> so that you know where the following
                                lines originate:
                                </p><pre class="literallayout">
     ...
     DESCRIPTION = "A useful utility"
     ...
     EXTRA_OECONF = "--enable-something"
     ...

     #### bbappended from meta-anotherlayer ####

     DESCRIPTION = "Customized utility"
     EXTRA_OECONF += "--enable-somethingelse"
                                </pre><p>
                                Ideally, you would tidy up these utilities as follows:
                                </p><pre class="literallayout">
     ...
     DESCRIPTION = "Customized utility"
     ...
     EXTRA_OECONF = "--enable-something --enable-somethingelse"
     ...
                                </pre></li></ul></div></li></ul></div><p>
            </p></div></div><div class="section" title="5.2. Customizing Images"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="usingpoky-extend-customimage"></a>5.2. Customizing Images</h2></div></div></div><p>
            You can customize images to satisfy particular requirements.
            This section describes several methods and provides guidelines for each.
        </p><div class="section" title="5.2.1. Customizing Images Using Custom .bb Files"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-customimage-custombb"></a>5.2.1. Customizing Images Using Custom .bb Files</h3></div></div></div><p>
                One way to get additional software into an image is to create a custom image.
                The following example shows the form for the two lines you need:
                </p><pre class="literallayout">
     IMAGE_INSTALL = "packagegroup-core-x11-base package1 package2"

     inherit core-image
                </pre><p>
            </p><p>
                By creating a custom image, a developer has total control
                over the contents of the image.
                It is important to use the correct names of packages in the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_INSTALL" target="_top">IMAGE_INSTALL</a></code>
                variable.
                You must use the OpenEmbedded notation and not the Debian notation for the names
                (e.g. <code class="filename">eglibc-dev</code> instead of <code class="filename">libc6-dev</code>).
            </p><p>
                The other method for creating a custom image is to base it on an existing image.
                For example, if you want to create an image based on <code class="filename">core-image-sato</code>
                but add the additional package <code class="filename">strace</code> to the image,
                copy the <code class="filename">meta/recipes-sato/images/core-image-sato.bb</code> to a
                new <code class="filename">.bb</code> and add the following line to the end of the copy:
                </p><pre class="literallayout">
     IMAGE_INSTALL += "strace"
                </pre><p>
            </p></div><div class="section" title="5.2.2. Customizing Images Using Custom Package Groups"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-customimage-customtasks"></a>5.2.2. Customizing Images Using Custom Package Groups</h3></div></div></div><p>
                For complex custom images, the best approach is to create a custom package group recipe
                that is used to build the image or images.
                A good example of a package group recipe is
                <code class="filename">meta/recipes-core/packagegroups/packagegroup-core-boot.bb</code>.
                The
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES" target="_top">PACKAGES</a></code>
                variable lists the package group packages you wish to produce. <code class="filename">inherit packagegroup</code>
                sets appropriate default values and automatically adds <code class="filename">-dev</code>
                and <code class="filename">-dbg</code> complementary
                packages for every package specified in <code class="filename">PACKAGES</code>.
                Note that the inherit line should be towards
                the top of the recipe, certainly before you set <code class="filename">PACKAGES</code>.
                For each package you specify in <code class="filename">PACKAGES</code>, you can use
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RDEPENDS" target="_top">RDEPENDS</a></code>
                and
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RRECOMMENDS" target="_top">RRECOMMENDS</a></code>
                entries to provide a list of packages the parent task package should contain.
                Following is an example:
                </p><pre class="literallayout">
     DESCRIPTION = "My Custom Package Groups"

     inherit packagegroup

     PACKAGES = "\
         packagegroup-custom-apps \
         packagegroup-custom-tools \
         "

     RDEPENDS_packagegroup-custom-apps = "\
         dropbear \
         portmap \
         psplash"

     RDEPENDS_packagegroup-custom-tools = "\
         oprofile \
         oprofileui-server \
         lttng-control \
         lttng-viewer"

     RRECOMMENDS_packagegroup-custom-tools = "\
         kernel-module-oprofile"
                </pre><p>
            </p><p>
                In the previous example, two package group packages are created with their dependencies and their
                recommended package dependencies listed: <code class="filename">packagegroup-custom-apps</code>, and
                <code class="filename">packagegroup-custom-tools</code>.
                To build an image using these package group packages, you need to add
                <code class="filename">packagegroup-custom-apps</code> and/or
                <code class="filename">packagegroup-custom-tools</code> to
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_INSTALL" target="_top">IMAGE_INSTALL</a></code>.
                For other forms of image dependencies see the other areas of this section.
            </p></div><div class="section" title="5.2.3. Customizing Images Using Custom IMAGE_FEATURES and EXTRA_IMAGE_FEATURES"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-customimage-imagefeatures"></a>5.2.3. Customizing Images Using Custom <code class="filename">IMAGE_FEATURES</code> and
                <code class="filename">EXTRA_IMAGE_FEATURES</code></h3></div></div></div><p>
                Ultimately users might want to add extra image features to the set by using the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_FEATURES" target="_top">IMAGE_FEATURES</a></code>
                variable.
                To create these features, the best reference is
                <code class="filename">meta/classes/core-image.bbclass</code>, which shows how this is
                achieved.
                In summary, the file looks at the contents of the
                <code class="filename">IMAGE_FEATURES</code>
                variable and then maps that into a set of tasks or packages.
                Based on this information, the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_INSTALL" target="_top"> IMAGE_INSTALL</a></code>
                variable is generated automatically.
                Users can add extra features by extending the class or creating a custom class for use
                with specialized image <code class="filename">.bb</code> files.
                You can also add more features by configuring the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-EXTRA_IMAGE_FEATURES" target="_top">EXTRA_IMAGE_FEATURES</a></code>
                variable in the <code class="filename">local.conf</code> file found in the Source Directory
                located in the Build Directory.
            </p><p>
                The Yocto Project ships with two SSH servers you can use in your images:
                Dropbear and OpenSSH.
                Dropbear is a minimal SSH server appropriate for resource-constrained environments,
                while OpenSSH is a well-known standard SSH server implementation.
                By default, the <code class="filename">core-image-sato</code> image is configured to use Dropbear.
                The <code class="filename">core-image-basic</code> and <code class="filename">core-image-lsb</code>
                images both include OpenSSH.
                The <code class="filename">core-image-minimal</code> image does not contain an SSH server.
                To change these defaults, edit the <code class="filename">IMAGE_FEATURES</code> variable
                so that it sets the image you are working with to include
                <code class="filename">ssh-server-dropbear</code> or <code class="filename">ssh-server-openssh</code>.
            </p></div><div class="section" title="5.2.4. Customizing Images Using local.conf"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-customimage-localconf"></a>5.2.4. Customizing Images Using <code class="filename">local.conf</code></h3></div></div></div><p>
                It is possible to customize image contents by using variables from your
                local configuration in your <code class="filename">conf/local.conf</code> file.
                Because it is limited to local use, this method generally only allows you to
                add packages and is not as flexible as creating your own customized image.
                When you add packages using local variables this way, you need to realize that
                these variable changes affect all images at the same time and might not be
                what you require.
            </p><p>
                The simplest way to add extra packages to all images is by using the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_INSTALL" target="_top">IMAGE_INSTALL</a></code>
                variable with the <code class="filename">_append</code> operator:
                </p><pre class="literallayout">
     IMAGE_INSTALL_append = " strace"
                </pre><p>
                Use of the syntax is important.
                Specifically, the space between the quote and the package name, which is
                <code class="filename">strace</code> in this example.
                This space is required since the <code class="filename">_append</code>
                operator does not add the space.
            </p><p>
                Furthermore, you must use <code class="filename">_append</code> instead of the <code class="filename">+=</code>
                operator if you want to avoid ordering issues.
                The reason for this is because doing so unconditionally appends to the variable and
                avoids ordering problems due to the variable being set in image recipes and
                <code class="filename">.bbclass</code> files with operators like <code class="filename">?=</code>.
                Using <code class="filename">_append</code> ensures the operation takes affect.
            </p><p>
                As shown in its simplest use, <code class="filename">IMAGE_INSTALL_append</code> affects
                all images.
                It is possible to extend the syntax so that the variable applies to a specific image only.
                Here is an example:
                </p><pre class="literallayout">
     IMAGE_INSTALL_append_pn-core-image-minimal = " strace"
                </pre><p>
                This example adds <code class="filename">strace</code> to <code class="filename">core-image-minimal</code>
                only.
            </p><p>
                You can add packages using a similar approach through the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-CORE_IMAGE_EXTRA_INSTALL" target="_top">CORE_IMAGE_EXTRA_INSTALL</a></code>
                variable.
                If you use this variable, only <code class="filename">core-image-*</code> images are affected.
            </p></div></div><div class="section" title="5.3. Adding a Package"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="usingpoky-extend-addpkg"></a>5.3. Adding a Package</h2></div></div></div><p>
            To add a package you need to write a recipe for it.
            Writing a recipe means creating a <code class="filename">.bb</code> file that sets some
            variables.
            For information on variables that are useful for recipes and for information about recipe naming
            issues, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-varlocality-recipe-required" target="_top">Required</a>"
            section of the Yocto Project Reference Manual.
        </p><p>
            Before writing a recipe from scratch, it is often useful to check
            whether someone else has written one already.
            OpenEmbedded is a good place to look as it has a wider scope and range of packages.
            Because the Yocto Project aims to be compatible with OpenEmbedded, most recipes
            you find there should work for you.
        </p><p>
            For new packages, the simplest way to add a recipe is to base it on a similar
            pre-existing recipe.
            The sections that follow provide some examples that show how to add standard
            types of packages.
        </p><div class="section" title="5.3.1. Single .c File Package (Hello World!)"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-addpkg-singlec"></a>5.3.1. Single .c File Package (Hello World!)</h3></div></div></div><p>
                Building an application from a single file that is stored locally (e.g. under
                <code class="filename">files/</code>) requires a recipe that has the file listed in
                the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code>
                variable.
                Additionally, you need to manually write the <code class="filename">do_compile</code> and
                <code class="filename">do_install</code> tasks.
                The <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top">S</a></code>
                variable defines the
                directory containing the source code, which is set to
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-WORKDIR" target="_top">
                WORKDIR</a></code> in this case - the directory BitBake uses for the build.
                </p><pre class="literallayout">
     DESCRIPTION = "Simple helloworld application"
     SECTION = "examples"
     LICENSE = "MIT"
     LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"
     PR = "r0"

     SRC_URI = "file://helloworld.c"

     S = "${WORKDIR}"

     do_compile() {
     	${CC} helloworld.c -o helloworld
     }

     do_install() {
     	install -d ${D}${bindir}
     	install -m 0755 helloworld ${D}${bindir}
     }
                </pre><p>
            </p><p>
                By default, the <code class="filename">helloworld</code>, <code class="filename">helloworld-dbg</code>,
                and <code class="filename">helloworld-dev</code> packages are built.
                For information on how to customize the packaging process, see the
                "<a class="link" href="#splitting-an-application-into-multiple-packages" title="5.3.4. Splitting an Application into Multiple Packages">Splitting an Application
                into Multiple Packages</a>" section.
            </p></div><div class="section" title="5.3.2. Autotooled Package"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-addpkg-autotools"></a>5.3.2. Autotooled Package</h3></div></div></div><p>
                Applications that use Autotools such as <code class="filename">autoconf</code> and
                <code class="filename">automake</code> require a recipe that has a source archive listed in
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code> and
                also inherits Autotools, which instructs BitBake to use the
                <code class="filename">autotools.bbclass</code> file, which contains the definitions of all the steps
                needed to build an Autotool-based application.
                The result of the build is automatically packaged.
                And, if the application uses NLS for localization, packages with local information are
                generated (one package per language).
                Following is one example: (<code class="filename">hello_2.3.bb</code>)
                </p><pre class="literallayout">
     DESCRIPTION = "GNU Helloworld application"
     SECTION = "examples"
     LICENSE = "GPLv2+"
     LIC_FILES_CHKSUM = "file://COPYING;md5=751419260aa954499f7abaabaa882bbe"
     PR = "r0"

     SRC_URI = "${GNU_MIRROR}/hello/hello-${PV}.tar.gz"

     inherit autotools gettext
                 </pre><p>
            </p><p>
                The variable
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-LIC_FILES_CHKSUM" target="_top">LIC_FILES_CHKSUM</a></code>
                is used to track source license changes as described in the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#usingpoky-configuring-LIC_FILES_CHKSUM" target="_top">Track License Changes</a>" section.
                You can quickly create Autotool-based recipes in a manner similar to the previous example.
            </p></div><div class="section" title="5.3.3. Makefile-Based Package"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-addpkg-makefile"></a>5.3.3. Makefile-Based Package</h3></div></div></div><p>
                Applications that use GNU <code class="filename">make</code> also require a recipe that has
                the source archive listed in
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code>.
                You do not need to add a <code class="filename">do_compile</code> step since by default BitBake
                starts the <code class="filename">make</code> command to compile the application.
                If you need additional <code class="filename">make</code> options you should store them in the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-EXTRA_OEMAKE" target="_top">EXTRA_OEMAKE</a></code>
                variable.
                BitBake passes these options into the <code class="filename">make</code> GNU invocation.
                Note that a <code class="filename">do_install</code> task is still required.
                Otherwise, BitBake runs an empty <code class="filename">do_install</code> task by default.
            </p><p>
                Some applications might require extra parameters to be passed to the compiler.
                For example, the application might need an additional header path.
                You can accomplish this by adding to the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-CFLAGS" target="_top">CFLAGS</a></code> variable.
                The following example shows this:
                </p><pre class="literallayout">
     CFLAGS_prepend = "-I ${S}/include "
                </pre><p>
            </p><p>
            In the following example, <code class="filename">mtd-utils</code> is a makefile-based package:
                </p><pre class="literallayout">
     DESCRIPTION = "Tools for managing memory technology devices."
     SECTION = "base"
     DEPENDS = "zlib lzo e2fsprogs util-linux"
     HOMEPAGE = "http://www.linux-mtd.infradead.org/"
     LICENSE = "GPLv2+"
     LIC_FILES_CHKSUM = "file://COPYING;md5=0636e73ff0215e8d672dc4c32c317bb3 \
                    file://include/common.h;beginline=1;endline=17;md5=ba05b07912a44ea2bf81ce409380049c"

     SRC_URI = "git://git.infradead.org/mtd-utils.git;protocol=git;tag=995cfe51b0a3cf32f381c140bf72b21bf91cef1b \
	     	file://add-exclusion-to-mkfs-jffs2-git-2.patch"

     S = "${WORKDIR}/git/"

     PR = "r1"

     EXTRA_OEMAKE = "'CC=${CC}' 'RANLIB=${RANLIB}' 'AR=${AR}' \
        'CFLAGS=${CFLAGS} -I${S}/include -DWITHOUT_XATTR' 'BUILDDIR=${S}'"

     do_install () {
	     oe_runmake install DESTDIR=${D} SBINDIR=${sbindir} MANDIR=${mandir} \
            INCLUDEDIR=${includedir}
	     install -d ${D}${includedir}/mtd/
	     for f in ${S}/include/mtd/*.h; do
	     	install -m 0644 $f ${D}${includedir}/mtd/
	     done
     }

     PARALLEL_MAKE = ""

     BBCLASSEXTEND = "native"
                </pre><p>
            </p><p>
                If your sources are available as a tarball instead of a Git repository, you
                will need to provide the URL to the tarball as well as an
                <code class="filename">md5</code> or <code class="filename">sha256</code> sum of
                the download.
                Here is an example:
                </p><pre class="literallayout">
     SRC_URI="ftp://ftp.infradead.org/pub/mtd-utils/mtd-utils-1.4.9.tar.bz2"
     SRC_URI[md5sum]="82b8e714b90674896570968f70ca778b"
                </pre><p>
                You can generate the <code class="filename">md5</code> or <code class="filename">sha256</code> sums
                by using the <code class="filename">md5sum</code> or <code class="filename">sha256sum</code> commands
                with the target file as the only argument.
                Here is an example:
                </p><pre class="literallayout">
     $ md5sum mtd-utils-1.4.9.tar.bz2
     82b8e714b90674896570968f70ca778b mtd-utils-1.4.9.tar.bz2
                </pre><p>
            </p></div><div class="section" title="5.3.4. Splitting an Application into Multiple Packages"><div class="titlepage"><div><div><h3 class="title"><a id="splitting-an-application-into-multiple-packages"></a>5.3.4. Splitting an Application into Multiple Packages</h3></div></div></div><p>
                You can use the variables
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES" target="_top">PACKAGES</a></code> and
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-FILES" target="_top">FILES</a></code>
                to split an application into multiple packages.
            </p><p>
                Following is an example that uses the <code class="filename">libXpm</code> recipe.
                By default, this recipe generates a single package that contains the library along
                with a few binaries.
                You can modify the recipe to split the binaries into separate packages:
                </p><pre class="literallayout">
     require xorg-lib-common.inc

     DESCRIPTION = "X11 Pixmap library"
     LICENSE = "X-BSD"
     LIC_FILES_CHKSUM = "file://COPYING;md5=3e07763d16963c3af12db271a31abaa5"
     DEPENDS += "libxext libsm libxt"
     PR = "r3"
     PE = "1"

     XORG_PN = "libXpm"

     PACKAGES =+ "sxpm cxpm"
     FILES_cxpm = "${bindir}/cxpm"
     FILES_sxpm = "${bindir}/sxpm"
                </pre><p>
            </p><p>
                In the previous example, we want to ship the <code class="filename">sxpm</code>
                and <code class="filename">cxpm</code> binaries in separate packages.
                Since <code class="filename">bindir</code> would be packaged into the main
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top">PN</a></code>
                package by default, we prepend the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES" target="_top">PACKAGES</a>
                </code> variable so additional package names are added to the start of list.
                This results in the extra
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-FILES" target="_top">FILES</a>_*</code>
                variables then containing information that define which files and
                directories go into which packages.
                Files included by earlier packages are skipped by latter packages.
                Thus, the main
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top">PN</a></code> package
                does not include the above listed files.
            </p></div><div class="section" title="5.3.5. Including Static Library Files"><div class="titlepage"><div><div><h3 class="title"><a id="including-static-library-files"></a>5.3.5. Including Static Library Files</h3></div></div></div><p>
                If you are building a library and the library offers static linking, you can control
                which static library files (<code class="filename">*.a</code> files) get included in the
                built library.
            </p><p>
                The <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES" target="_top"><code class="filename">PACKAGES</code></a>
                and <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-FILES" target="_top"><code class="filename">FILES_*</code></a>
                variables in the
                <code class="filename">meta/conf/bitbake.conf</code> configuration file define how files installed
                by the <code class="filename">do_install</code> task are packaged.
                By default, the <code class="filename">PACKAGES</code> variable contains
                <code class="filename">${PN}-staticdev</code>, which includes all static library files.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Previously released versions of the Yocto Project defined the static library files
                    through <code class="filename">${PN}-dev</code>.
                </div><p>
                Following, is part of the BitBake configuration file.
                You can see where the static library files are defined:
                </p><pre class="literallayout">
     PACKAGES = "${PN}-dbg ${PN} ${PN}-doc ${PN}-dev ${PN}-staticdev ${PN}-locale"
     PACKAGES_DYNAMIC = "${PN}-locale-*"
     FILES = ""

     FILES_${PN} = "${bindir}/* ${sbindir}/* ${libexecdir}/* ${libdir}/lib*${SOLIBS} \
                 ${sysconfdir} ${sharedstatedir} ${localstatedir} \
                 ${base_bindir}/* ${base_sbindir}/* \
                 ${base_libdir}/*${SOLIBS} \
                 ${datadir}/${BPN} ${libdir}/${BPN}/* \
                 ${datadir}/pixmaps ${datadir}/applications \
                 ${datadir}/idl ${datadir}/omf ${datadir}/sounds \
                 ${libdir}/bonobo/servers"

     FILES_${PN}-doc = "${docdir} ${mandir} ${infodir} ${datadir}/gtk-doc \
                 ${datadir}/gnome/help"
     SECTION_${PN}-doc = "doc"

     FILES_${PN}-dev = "${includedir} ${libdir}/lib*${SOLIBSDEV} ${libdir}/*.la \
                     ${libdir}/*.o ${libdir}/pkgconfig ${datadir}/pkgconfig \
                     ${datadir}/aclocal ${base_libdir}/*.o"
     SECTION_${PN}-dev = "devel"
     ALLOW_EMPTY_${PN}-dev = "1"
     RDEPENDS_${PN}-dev = "${PN} (= ${EXTENDPKGV})"

     FILES_${PN}-staticdev = "${libdir}/*.a ${base_libdir}/*.a"
     SECTION_${PN}-staticdev = "devel"
     RDEPENDS_${PN}-staticdev = "${PN}-dev (= ${EXTENDPKGV})"
                </pre><p>
            </p></div><div class="section" title="5.3.6. Post Install Scripts"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-extend-addpkg-postinstalls"></a>5.3.6. Post Install Scripts</h3></div></div></div><p>
                To add a post-installation script to a package, add a <code class="filename">pkg_postinst_PACKAGENAME()
                </code> function to the <code class="filename">.bb</code> file and use
                <code class="filename">PACKAGENAME</code> as the name of the package you want to attach to the
                <code class="filename">postinst</code> script.
                Normally
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top">PN</a></code>
                can be used, which automatically expands to <code class="filename">PACKAGENAME</code>.
                A post-installation function has the following structure:
                </p><pre class="literallayout">
     pkg_postinst_PACKAGENAME () {
     #!/bin/sh -e
     # Commands to carry out
     }
                </pre><p>
            </p><p>
                The script defined in the post-installation function is called when the
                root filesystem is created.
                If the script succeeds, the package is marked as installed.
                If the script fails, the package is marked as unpacked and the script is
                executed when the image boots again.
            </p><p>
                Sometimes it is necessary for the execution of a post-installation
                script to be delayed until the first boot.
                For example, the script might need to be executed on the device itself.
                To delay script execution until boot time, use the following structure in the
                post-installation script:
                </p><pre class="literallayout">
     pkg_postinst_PACKAGENAME () {
     #!/bin/sh -e
     if [ x"$D" = "x" ]; then
          # Actions to carry out on the device go here
     else
          exit 1
     fi
     }
                </pre><p>
            </p><p>
                The previous example delays execution until the image boots again because the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-D" target="_top">D</a></code>
                variable points
                to the directory containing the image when the root filesystem is created at build time but
                is unset when executed on the first boot.
            </p></div></div><div class="section" title="5.4. Adding a New Machine"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="platdev-newmachine"></a>5.4. Adding a New Machine</h2></div></div></div><p>
            Adding a new machine to the Yocto Project is a straightforward process.
            This section provides information that gives you an idea of the changes you must make.
            The information covers adding machines similar to those the Yocto Project already supports.
            Although well within the capabilities of the Yocto Project, adding a totally new architecture
            might require
            changes to <code class="filename">gcc/eglibc</code> and to the site information, which is
            beyond the scope of this manual.
        </p><p>
            For a complete example that shows how to add a new machine,
            see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#creating-a-new-bsp-layer-using-the-yocto-bsp-script" target="_top">Creating a New BSP Layer Using the yocto-bsp Script</a>"
            in the Yocto Project Board Support Package (BSP) Developer's Guide.
        </p><div class="section" title="5.4.1. Adding the Machine Configuration File"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-newmachine-conffile"></a>5.4.1. Adding the Machine Configuration File</h3></div></div></div><p>
                To add a machine configuration you need to add a <code class="filename">.conf</code> file
                with details of the device being added to the <code class="filename">conf/machine/</code> file.
                The name of the file determines the name the OpenEmbedded build system
                uses to reference the new machine.
            </p><p>
                The most important variables to set in this file are as follows:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-TARGET_ARCH" target="_top">
                        TARGET_ARCH</a></code> (e.g. "arm")</p></li><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PREFERRED_PROVIDER" target="_top">
                        PREFERRED_PROVIDER</a></code>_virtual/kernel (see below)</p></li><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-MACHINE_FEATURES" target="_top">
                        MACHINE_FEATURES</a></code> (e.g. "apm screen wifi")</p></li></ul></div><p>
            </p><p>
                You might also need these variables:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SERIAL_CONSOLE" target="_top">
                        SERIAL_CONSOLE</a></code> (e.g. "115200 ttyS0")</p></li><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-KERNEL_IMAGETYPE" target="_top">
                        KERNEL_IMAGETYPE</a></code> (e.g. "zImage")</p></li><li class="listitem"><p><code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_FSTYPES" target="_top">
                        IMAGE_FSTYPES</a></code> (e.g. "tar.gz jffs2")</p></li></ul></div><p>
            </p><p>
                You can find full details on these variables in the reference section.
                You can leverage many existing machine <code class="filename">.conf</code> files from
                <code class="filename">meta/conf/machine/</code>.
            </p></div><div class="section" title="5.4.2. Adding a Kernel for the Machine"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-newmachine-kernel"></a>5.4.2. Adding a Kernel for the Machine</h3></div></div></div><p>
                The OpenEmbedded build system needs to be able to build a kernel for the machine.
                You need to either create a new kernel recipe for this machine, or extend an
                existing recipe.
                You can find several kernel examples in the
                Source Directory at <code class="filename">meta/recipes-kernel/linux</code>
                that you can use as references.
            </p><p>
                If you are creating a new recipe, normal recipe-writing rules apply for setting
                up a
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top">SRC_URI</a></code>.
                Thus, you need to specify any necessary patches and set
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top">S</a></code> to point at the source code.
                You need to create a <code class="filename">configure</code> task that configures the
                unpacked kernel with a defconfig.
                You can do this by using a <code class="filename">make defconfig</code> command or,
                more commonly, by copying in a suitable <code class="filename">defconfig</code> file and and then running
                <code class="filename">make oldconfig</code>.
                By making use of <code class="filename">inherit kernel</code> and potentially some of the
                <code class="filename">linux-*.inc</code> files, most other functionality is
                centralized and the the defaults of the class normally work well.
            </p><p>
                If you are extending an existing kernel, it is usually a matter of adding a
                suitable defconfig file.
                The file needs to be added into a location similar to defconfig files
                used for other machines in a given kernel.
                A possible way to do this is by listing the file in the
                <code class="filename">SRC_URI</code> and adding the machine to the expression in
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-COMPATIBLE_MACHINE" target="_top">COMPATIBLE_MACHINE</a></code>:
                </p><pre class="literallayout">
     COMPATIBLE_MACHINE = '(qemux86|qemumips)'
                </pre><p>
            </p></div><div class="section" title="5.4.3. Adding a Formfactor Configuration File"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-newmachine-formfactor"></a>5.4.3. Adding a Formfactor Configuration File</h3></div></div></div><p>
                A formfactor configuration file provides information about the
                target hardware for which the image is being built and information that
                the build system cannot obtain from other sources such as the kernel.
                Some examples of information contained in a formfactor configuration file include
                framebuffer orientation, whether or not the system has a keyboard,
                the positioning of the keyboard in relation to the screen, and
                the screen resolution.
            </p><p>
                The build system uses reasonable defaults in most cases, but if customization is
                necessary you need to create a <code class="filename">machconfig</code> file
                in the <code class="filename">meta/recipes-bsp/formfactor/files</code>
                directory.
                This directory contains directories for specific machines such as
                <code class="filename">qemuarm</code> and <code class="filename">qemux86</code>.
                For information about the settings available and the defaults, see the
                <code class="filename">meta/recipes-bsp/formfactor/files/config</code> file found in the
                same area.
                Following is an example for qemuarm:
                </p><pre class="literallayout">
     HAVE_TOUCHSCREEN=1
     HAVE_KEYBOARD=1

     DISPLAY_CAN_ROTATE=0
     DISPLAY_ORIENTATION=0
     #DISPLAY_WIDTH_PIXELS=640
     #DISPLAY_HEIGHT_PIXELS=480
     #DISPLAY_BPP=16
     DISPLAY_DPI=150
     DISPLAY_SUBPIXEL_ORDER=vrgb
                </pre><p>
            </p></div></div><div class="section" title="5.5. Combining Multiple Versions of Library Files into One Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="building-multiple-architecture-libraries-into-one-image"></a>5.5. Combining Multiple Versions of Library Files into One Image</h2></div></div></div><p>
            The build system offers the ability to build libraries with different
            target optimizations or architecture formats and combine these together
            into one system image.
            You can link different binaries in the image
            against the different libraries as needed for specific use cases.
            This feature is called "Multilib."
        </p><p>
            An example would be where you have most of a system compiled in 32-bit
            mode using 32-bit libraries, but you have something large, like a database
            engine, that needs to be a 64-bit application and use 64-bit libraries.
            Multilib allows you to get the best of both 32-bit and 64-bit libraries.
        </p><p>
            While the Multilib feature is most commonly used for 32 and 64-bit differences,
            the approach the build system uses facilitates different target optimizations.
            You could compile some binaries to use one set of libraries and other binaries
            to use other different sets of libraries.
            The libraries could differ in architecture, compiler options, or other
            optimizations.
        </p><p>
            This section overviews the Multilib process only.
            For more details on how to implement Multilib, see the
            <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Multilib" target="_top">Multilib</a> wiki
            page.
        </p><div class="section" title="5.5.1. Preparing to use Multilib"><div class="titlepage"><div><div><h3 class="title"><a id="preparing-to-use-multilib"></a>5.5.1. Preparing to use Multilib</h3></div></div></div><p>
                User-specific requirements drive the Multilib feature,
                Consequently, there is no one "out-of-the-box" configuration that likely
                exists to meet your needs.
            </p><p>
                In order to enable Multilib, you first need to ensure your recipe is
                extended to support multiple libraries.
                Many standard recipes are already extended and support multiple libraries.
                You can check in the <code class="filename">meta/conf/multilib.conf</code>
                configuration file in the Source Directory to see how this is
                done using the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBCLASSEXTEND" target="_top"><code class="filename">BBCLASSEXTEND</code></a>
                variable.
                Eventually, all recipes will be covered and this list will be unneeded.
            </p><p>
                For the most part, the Multilib class extension works automatically to
                extend the package name from <code class="filename">${PN}</code> to
                <code class="filename">${MLPREFIX}${PN}</code>, where <code class="filename">MLPREFIX</code>
                is the particular multilib (e.g. "lib32-" or "lib64-").
                Standard variables such as
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-DEPENDS" target="_top"><code class="filename">DEPENDS</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RDEPENDS" target="_top"><code class="filename">RDEPENDS</code></a>,
                <code class="filename">RPROVIDES</code>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RRECOMMENDS" target="_top"><code class="filename">RRECOMMENDS</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES" target="_top"><code class="filename">PACKAGES</code></a>,
                and <code class="filename">PACKAGES_DYNAMIC</code> are automatically extended by the system.
                If you are extending any manual code in the recipe, you can use the
                <code class="filename">${MLPREFIX}</code> variable to ensure those names are extended
                correctly.
                This automatic extension code resides in <code class="filename">multilib.bbclass</code>.
            </p></div><div class="section" title="5.5.2. Using Multilib"><div class="titlepage"><div><div><h3 class="title"><a id="using-multilib"></a>5.5.2. Using Multilib</h3></div></div></div><p>
                After you have set up the recipes, you need to define the actual
                combination of multiple libraries you want to build.
                You accomplish this through your <code class="filename">local.conf</code>
                configuration file in the
                <a class="link" href="#build-directory">Build Directory</a>.
                An example configuration would be as follows:
                </p><pre class="literallayout">
     MACHINE = "qemux86-64"
     require conf/multilib.conf
     MULTILIBS = "multilib:lib32"
     DEFAULTTUNE_virtclass-multilib-lib32 = "x86"
     IMAGE_INSTALL = "lib32-connman"
                </pre><p>
                This example enables an
                additional library named <code class="filename">lib32</code> alongside the
                normal target packages.
                When combining these "lib32" alternatives, the example uses "x86" for tuning.
                For information on this particular tuning, see
                <code class="filename">meta/conf/machine/include/ia32/arch-ia32.inc</code>.
            </p><p>
                The example then includes <code class="filename">lib32-connman</code>
                in all the images, which illustrates one method of including a
                multiple library dependency.
                You can use a normal image build to include this dependency,
                for example:
                </p><pre class="literallayout">
     $ bitbake core-image-sato
                </pre><p>
                You can also build Multilib packages specifically with a command like this:
                </p><pre class="literallayout">
     $  bitbake lib32-connman
                </pre><p>
            </p></div><div class="section" title="5.5.3. Additional Implementation Details"><div class="titlepage"><div><div><h3 class="title"><a id="additional-implementation-details"></a>5.5.3. Additional Implementation Details</h3></div></div></div><p>
                Different packaging systems have different levels of native Multilib
                support.
                For the RPM Package Management System, the following implementation details
                exist:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A unique architecture is defined for the Multilib packages,
                        along with creating a unique deploy folder under
                        <code class="filename">tmp/deploy/rpm</code> in the
                        <a class="link" href="#build-directory">Build Directory</a>.
                        For example, consider <code class="filename">lib32</code> in a
                        <code class="filename">qemux86-64</code> image.
                        The possible architectures in the system are "all", "qemux86_64",
                        "lib32_qemux86_64", and "lib32_x86".</p></li><li class="listitem"><p>The <code class="filename">${MLPREFIX}</code> variable is stripped from
                        <code class="filename">${PN}</code> during RPM packaging.
                        The naming for a normal RPM package and a Multilib RPM package in a
                        <code class="filename">qemux86-64</code> system resolves to something similar to
                        <code class="filename">bash-4.1-r2.x86_64.rpm</code> and
                        <code class="filename">bash-4.1.r2.lib32_x86.rpm</code>, respectively.
                        </p></li><li class="listitem"><p>When installing a Multilib image, the RPM backend first
                        installs the base image and then installs the Multilib libraries.
                        </p></li><li class="listitem"><p>The build system relies on RPM to resolve the identical files in the
                        two (or more) Multilib packages.</p></li></ul></div><p>
            </p><p>
                For the IPK Package Management System, the following implementation details exist:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <code class="filename">${MLPREFIX}</code> is not stripped from
                        <code class="filename">${PN}</code> during IPK packaging.
                        The naming for a normal RPM package and a Multilib IPK package in a
                        <code class="filename">qemux86-64</code> system resolves to something like
                        <code class="filename">bash_4.1-r2.x86_64.ipk</code> and
                        <code class="filename">lib32-bash_4.1-rw_x86.ipk</code>, respectively.
                        </p></li><li class="listitem"><p>The IPK deploy folder is not modified with
                        <code class="filename">${MLPREFIX}</code> because packages with and without
                        the Multilib feature can exist in the same folder due to the
                        <code class="filename">${PN}</code> differences.</p></li><li class="listitem"><p>IPK defines a sanity check for Multilib installation
                        using certain rules for file comparison, overridden, etc.
                        </p></li></ul></div><p>
            </p></div></div><div class="section" title="5.6. Configuring the Kernel"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="configuring-the-kernel"></a>5.6. Configuring the Kernel</h2></div></div></div><p>
            Configuring the Yocto Project kernel consists of making sure the <code class="filename">.config</code>
            file has all the right information in it for the image you are building.
            You can use the <code class="filename">menuconfig</code> tool and configuration fragments to
            make sure your <code class="filename">.config</code> file is just how you need it.
            This section describes how to use <code class="filename">menuconfig</code>, create and use
            configuration fragments, and how to interactively tweak your <code class="filename">.config</code>
            file to create the leanest kernel configuration file possible.
        </p><p>
            For concepts on kernel configuration, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/kernel-manual/kernel-manual.html#kernel-configuration" target="_top">Kernel Configuration</a>"
            section in the Yocto Project Kernel Architecture and Use Manual.
        </p><div class="section" title="5.6.1. Using  menuconfig"><div class="titlepage"><div><div><h3 class="title"><a id="using-menuconfig"></a>5.6.1. Using  <code class="filename">menuconfig</code></h3></div></div></div><p>
                The easiest way to define kernel configurations is to set them through the
                <code class="filename">menuconfig</code> tool.
                This tool provides an interactive method with which
                to set kernel configurations.
                For general information on <code class="filename">menuconfig</code>, see
                <a class="ulink" href="http://en.wikipedia.org/wiki/Menuconfig" target="_top">http://en.wikipedia.org/wiki/Menuconfig</a>.
            </p><p>
                To use the <code class="filename">menuconfig</code> tool in the Yocto Project development
                environment, you must build the tool using BitBake.
                Thus, the environment must be set up using the <code class="filename">oe-init-build-env</code>
                script found in the
                <a class="link" href="#build-directory">Build Directory</a>.
                The following commands build and invoke <code class="filename">menuconfig</code> assuming the
                Source Directory top-level folder is <code class="filename">~/poky</code>:
                </p><pre class="literallayout">
     $ cd ~/poky
     $ source oe-init-build-env
     $ bitbake linux-yocto -c menuconfig
                </pre><p>
                Once <code class="filename">menuconfig</code> comes up, its standard interface allows you to
                interactively examine and configure all the kernel configuration parameters.
                After making your changes, simply exit the tool and save your changes to
                create an updated version of the <code class="filename">.config</code> configuration file.
            </p><p>
                Consider an example that configures the <code class="filename">linux-yocto-3.4</code>
                kernel.
                The OpenEmbedded build system recognizes this kernel as
                <code class="filename">linux-yocto</code>.
                Thus, the following commands from the shell in which you previously sourced the
                environment initialization script cleans the shared state cache and the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a>
                directory and then builds and launches <code class="filename">menuconfig</code>:
                </p><pre class="literallayout">
     $ bitbake linux-yocto -c menuconfig
                </pre><p>
            </p><p>
                Once <code class="filename">menuconfig</code> launches, you use the interface
                to navigate through the selections to find the configuration settings in
                which you are interested.
                For example, consider the <code class="filename">CONFIG_SMP</code> configuration setting.
                You can find it at <code class="filename">Processor Type and Features</code> under
                the configuration selection <code class="filename">Symmetric Multi-processing Support</code>.
                After highlighting the selection, you can use the arrow keys to select or deselect
                the setting.
                When you are finished with all your selections, exit out and save them.
            </p><p>
                Saving the selections updates the <code class="filename">.config</code> configuration file.
                This is the file that the OpenEmbedded build system uses to configure the
                kernel during the build.
                You can find and examine this file in the Build Directory in
                <code class="filename">tmp/work/</code>.
                The actual <code class="filename">.config</code> is located in the area where the
                specific kernel is built.
                For example, if you were building a Linux Yocto kernel based on the
                Linux 3.4 kernel and you were building a QEMU image targeted for
                <code class="filename">x86</code> architecture, the
                <code class="filename">.config</code> file would be located here:
                </p><pre class="literallayout">
     ~/poky/build/tmp/work/qemux86-poky-linux/linux-yocto-3.4.11+git1+84f...
        ...656ed30-r1/linux-qemux86-standard-build
                </pre><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The previous example directory is artificially split and many of the characters
                    in the actual filename are omitted in order to make it more readable.
                    Also, depending on the kernel you are using, the exact pathname
                    for <code class="filename">linux-yocto-3.4...</code> might differ.
                </div><p>
            </p><p>
                Within the <code class="filename">.config</code> file, you can see the kernel settings.
                For example, the following entry shows that symmetric multi-processor support
                is not set:
                </p><pre class="literallayout">
     # CONFIG_SMP is not set
                </pre><p>
            </p><p>
                A good method to isolate changed configurations is to use a combination of the
                <code class="filename">menuconfig</code> tool and simple shell commands.
                Before changing configurations with <code class="filename">menuconfig</code>, copy the
                existing <code class="filename">.config</code> and rename it to something else,
                use <code class="filename">menuconfig</code> to make
                as many changes an you want and save them, then compare the renamed configuration
                file against the newly created file.
                You can use the resulting differences as your base to create configuration fragments
                to permanently save in your kernel layer.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Be sure to make a copy of the <code class="filename">.config</code> and don't just
                    rename it.
                    The build system needs an existing <code class="filename">.config</code>
                    from which to work.
                </div><p>
            </p></div><div class="section" title="5.6.2. Creating Configuration Fragments"><div class="titlepage"><div><div><h3 class="title"><a id="creating-config-fragments"></a>5.6.2. Creating Configuration Fragments</h3></div></div></div><p>
                Configuration fragments are simply kernel options that appear in a file
                placed where the OpenEmbedded build system can find and apply them.
                Syntactically, the configuration statement is identical to what would appear
                in the <code class="filename">.config</code> file, which is in the
                <a class="link" href="#build-directory">Build Directory</a> in
                <code class="filename">tmp/work/&lt;arch&gt;-poky-linux/linux-yocto-&lt;release-specific-string&gt;/linux-&lt;arch&gt;-&lt;build-type&gt;</code>.
            </p><p>
                It is simple to create a configuration fragment.
                For example, issuing the following from the shell creates a configuration fragment
                file named <code class="filename">my_smp.cfg</code> that enables multi-processor support
                within the kernel:
                </p><pre class="literallayout">
     $ echo "CONFIG_SMP=y" &gt;&gt; my_smp.cfg
                </pre><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    All configuration files must use the <code class="filename">.cfg</code> extension in order
                    for the OpenEmbedded build system to recognize them as a configuration fragment.
                </div><p>
            </p><p>
                Where do you put your configuration files?
                You can place these configuration files in the same area pointed to by
                <code class="filename">SRC_URI</code>.
                The OpenEmbedded build system will pick up the configuration and add it to the
                kernel's configuration.
                For example, suppose you had a set of configuration options in a file called
                <code class="filename">myconfig.cfg</code>.
                If you put that file inside a directory named <code class="filename">/linux-yocto</code>
                that resides in the same directory as the kernel's append file and then add
                a <code class="filename">SRC_URI</code> statement such as the following to the kernel's append file,
                those configuration options will be picked up and applied when the kernel is built.
                </p><pre class="literallayout">
     SRC_URI += "file://myconfig.cfg"
                </pre><p>
            </p><p>
                As mentioned earlier, you can group related configurations into multiple files and
                name them all in the <code class="filename">SRC_URI</code> statement as well.
                For example, you could group separate configurations specifically for Ethernet and graphics
                into their own files and add those by using a <code class="filename">SRC_URI</code> statement like the
                following in your append file:
                </p><pre class="literallayout">
     SRC_URI += "file://myconfig.cfg \
            file://eth.cfg \
            file://gfx.cfg"
                </pre><p>
            </p></div><div class="section" title="5.6.3. Fine-tuning the Kernel Configuration File"><div class="titlepage"><div><div><h3 class="title"><a id="fine-tuning-the-kernel-configuration-file"></a>5.6.3. Fine-tuning the Kernel Configuration File</h3></div></div></div><p>
                You can make sure the <code class="filename">.config</code> is as lean or efficient as
                possible by reading the output of the kernel configuration fragment audit,
                noting any issues, making changes to correct the issues, and then repeating.
            </p><p>
                As part of the kernel build process, the
                <code class="filename">kernel_configcheck</code> task runs.
                This task validates the kernel configuration by checking the final
                <code class="filename">.config</code> file against the input files.
                During the check, the task produces warning messages for the following
                issues:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Requested options that did not make the final
                        <code class="filename">.config</code> file.</p></li><li class="listitem"><p>Configuration items that appear twice in the same
                        configuration fragment.</p></li><li class="listitem"><p>Configuration items tagged as 'required' were overridden.
                        </p></li><li class="listitem"><p>A board overrides a non-board specific option.</p></li><li class="listitem"><p>Listed options not valid for the kernel being processed.
                        In other words, the option does not appear anywhere.</p></li></ul></div><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The <code class="filename">kernel_configcheck</code> task can also optionally report
                    if an option is overridden during processing.
                </div><p>
            </p><p>
                For each output warning, a message points to the file
                that contains a list of the options and a pointer to the config
                fragment that defines them.
                Collectively, the files are the key to streamlining the configuration.
            </p><p>
                To streamline the configuration, do the following:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start with a full configuration that you know
                        works - it builds and boots successfully.
                        This configuration file will be your baseline.</p></li><li class="listitem"><p>Separately run the <code class="filename">configme</code> and
                        <code class="filename">kernel_configcheck</code> tasks.</p></li><li class="listitem"><p>Take the resulting list of files from the
                        <code class="filename">kernel_configcheck</code> task warnings and do the following:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Drop values that are redefined in the fragment but do not
                                change the final <code class="filename">.config</code> file.</p></li><li class="listitem"><p>Analyze and potentially drop values from the
                                <code class="filename">.config</code> file that override required
                                configurations.</p></li><li class="listitem"><p>Analyze and potentially remove non-board specific options.
                                </p></li><li class="listitem"><p>Remove repeated and invalid options.</p></li></ul></div></li><li class="listitem"><p>After you have worked through the output of the kernel configuration
                        audit, you can re-run the <code class="filename">configme</code>
                        and <code class="filename">kernel_configcheck</code> tasks to see the results of your
                        changes.
                        If you have more issues, you can deal with them as described in the
                        previous step.</p></li></ol></div><p>
            </p><p>
                Iteratively working through steps two through four eventually yields
                a minimal, streamlined configuration file.
                Once you have the best <code class="filename">.config</code>, you can build the Linux
                Yocto kernel.
            </p></div></div><div class="section" title="5.7. Patching the Kernel"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="patching-the-kernel"></a>5.7. Patching the Kernel</h2></div></div></div><p>
            Patching the kernel involves changing or adding configurations to an existing kernel,
            changing or adding recipes to the kernel that are needed to support specific hardware features,
            or even altering the source code itself.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                You can use the <code class="filename">yocto-kernel</code> script
                found in the <a class="link" href="#source-directory">Source Directory</a>
                under <code class="filename">scripts</code> to manage kernel patches and configuration.
                See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#managing-kernel-patches-and-config-items-with-yocto-kernel" target="_top">Managing kernel Patches and Config Items with yocto-kernel</a>"
                section in the Yocto Project Board Support Packages (BSP) Developer's Guide for
                more information.</div><p>
        </p><p>
            This example creates a simple patch by adding some QEMU emulator console
            output at boot time through <code class="filename">printk</code> statements in the kernel's
            <code class="filename">calibrate.c</code> source code file.
            Applying the patch and booting the modified image causes the added
            messages to appear on the emulator's console.
        </p><p>
            The example assumes a clean build exists for the <code class="filename">qemux86</code>
            machine in a Source Directory named <code class="filename">poky</code>.
            Furthermore, the <a class="link" href="#build-directory">Build Directory</a> is
            <code class="filename">build</code> and is located in <code class="filename">poky</code> and
            the kernel is based on the Linux 3.4 kernel.
            For general information on how to configure the most efficient build, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/yocto-project-qs/yocto-project-qs.html#building-image" target="_top">Building an Image</a>" section
            in the Yocto Project Quick Start.
        </p><div class="section" title="5.7.1. Create a Layer for your Changes"><div class="titlepage"><div><div><h3 class="title"><a id="create-a-layer-for-your-changes"></a>5.7.1. Create a Layer for your Changes</h3></div></div></div><p>
                The first step is to create a layer so you can isolate your changes:
                </p><pre class="literallayout">
     $cd ~/poky
     $mkdir meta-mylayer
                </pre><p>
                Creating a directory that follows the Yocto Project layer naming
                conventions sets up the layer for your changes.
                The layer is where you place your configuration files, append
                files, and patch files.
                To learn more about creating a layer and filling it with the
                files you need, see the "<a class="link" href="#understanding-and-creating-layers" title="5.1. Understanding and Creating Layers">Understanding
                and Creating Layers</a>" section.
            </p></div><div class="section" title="5.7.2. Finding the Kernel Source Code"><div class="titlepage"><div><div><h3 class="title"><a id="finding-the-kernel-source-code"></a>5.7.2. Finding the Kernel Source Code</h3></div></div></div><p>
                Each time you build a kernel image, the kernel source code is fetched
                and unpacked into the following directory:
                </p><pre class="literallayout">
     ${S}/linux
                </pre><p>
                See the "<a class="link" href="#finding-the-temporary-source-code" title="4.3.1. Finding the Temporary Source Code">Finding the Temporary Source Code</a>"
                section and the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top"><code class="filename">S</code></a> variable
                for more information about where source is kept during a build.
            </p><p>
                For this example, we are going to patch the
                <code class="filename">init/calibrate.c</code> file
                by adding some simple console <code class="filename">printk</code> statements that we can
                see when we boot the image using QEMU.
            </p></div><div class="section" title="5.7.3. Creating the Patch"><div class="titlepage"><div><div><h3 class="title"><a id="creating-the-patch"></a>5.7.3. Creating the Patch</h3></div></div></div><p>
                Two methods exist by which you can create the patch:
                <a class="link" href="#using-a-git-workflow" title="4.3.3. Using a Git Workflow">Git workflow</a> and
                <a class="link" href="#using-a-quilt-workflow" title="4.3.2. Using a Quilt Workflow">Quilt workflow</a>.
                For kernel patches, the Git workflow is more appropriate.
                This section assumes the Git workflow and shows the steps specific to
                this example.
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Change the working directory</em></span>:
                        Change to where the kernel source code is before making
                        your edits to the <code class="filename">calibrate.c</code> file:
                        </p><pre class="literallayout">
     $ cd ~/poky/build/tmp/work/qemux86-poky-linux/linux-yocto-${PV}-${PR}/linux
                        </pre><p>
                        Because you are working in an established Git repository,
                        you must be in this directory in order to commit your changes
                        and create the patch file.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a> and
                            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top"><code class="filename">PR</code></a> variables
                            represent the version and revision for the
                            <code class="filename">linux-yocto</code> recipe.
                            The <code class="filename">PV</code> variable includes the Git meta and machine
                            hashes, which make the directory name longer than you might
                            expect.
                        </div></li><li class="listitem"><p><span class="emphasis"><em>Edit the source file</em></span>:
                        Edit the <code class="filename">init/calibrate.c</code> file to have the
                        following changes:
                        </p><pre class="literallayout">
     void __cpuinit calibrate_delay(void)
     {
         unsigned long lpj;
         static bool printed;
         int this_cpu = smp_processor_id();

         printk("*************************************\n");
         printk("*                                   *\n");
         printk("*        HELLO YOCTO KERNEL         *\n");
         printk("*                                   *\n");
         printk("*************************************\n");

     	if (per_cpu(cpu_loops_per_jiffy, this_cpu)) {
               .
               .
               .
                        </pre></li><li class="listitem"><p><span class="emphasis"><em>Stage and commit your changes</em></span>:
                        These Git commands list out the changed file, stage it, and then
                        commit the file:
                        </p><pre class="literallayout">
     $ git status
     $ git add init/calibrate.c
     $ git commit -m "calibrate: Add printk example"
                        </pre></li><li class="listitem"><p><span class="emphasis"><em>Generate the patch file</em></span>:
                        This Git command creates the a patch file named
                        <code class="filename">0001-calibrate-Add-printk-example.patch</code>
                        in the current directory.
                        </p><pre class="literallayout">
     $ git format-patch -1
                        </pre><p>
                        </p></li></ol></div><p>
            </p></div><div class="section" title="5.7.4. Get Your Layer Setup for the Build"><div class="titlepage"><div><div><h3 class="title"><a id="get-your-layer-setup-for-the-build"></a>5.7.4. Get Your Layer Setup for the Build</h3></div></div></div><p>These steps get your layer set up for the build:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Create additional structure</em></span>:
                        Create the additional layer structure:
                        </p><pre class="literallayout">
     $ cd ~/poky/meta-mylayer
     $ mkdir conf
     $ mkdir recipes-kernel
     $ mkdir recipes-kernel/linux
     $ mkdir recipes-kernel/linux/linux-yocto
                         </pre><p>
                         The <code class="filename">conf</code> directory holds your configuration files, while the
                         <code class="filename">recipes-kernel</code> directory holds your append file and
                         your patch file.</p></li><li class="listitem"><p><span class="emphasis"><em>Create the layer configuration file</em></span>:
                        Move to the <code class="filename">meta-mylayer/conf</code> directory and create
                        the <code class="filename">layer.conf</code> file as follows:
                        </p><pre class="literallayout">
     # We have a conf and classes directory, add to BBPATH
     BBPATH := "${LAYERDIR}:${BBPATH}"

     # We have a packages directory, add to BBFILES
     BBFILES := "${BBFILES} ${LAYERDIR}/recipes-*/*/*.bb \
                 ${LAYERDIR}/recipes-*/*/*.bbappend"

     BBFILE_COLLECTIONS += "mylayer"
     BBFILE_PATTERN_mylayer := "^${LAYERDIR}/"
     BBFILE_PRIORITY_mylayer = "5"
                         </pre><p>
                         Notice <code class="filename">mylayer</code> as part of the last three
                         statements.</p></li><li class="listitem"><p><span class="emphasis"><em>Create the kernel recipe append file</em></span>:
                        Move to the <code class="filename">meta-mylayer/recipes-kernel/linux</code> directory and create
                        the <code class="filename">linux-yocto_3.4.bbappend</code> file as follows:
                        </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"

     SRC_URI += "file://0001-calibrate-Add-printk-example.patch"

     PRINC := "${@int(PRINC) + 1}"
                        </pre><p>
                        The <code class="filename">FILESEXTRAPATHS</code> and <code class="filename">SRC_URI</code>
                        statements enable the OpenEmbedded build system to find the patch file.
                        </p></li><li class="listitem"><p><span class="emphasis"><em>Put the patch file in your layer</em></span>:
                        Move the <code class="filename">0001-calibrate-Add-printk-example.patch</code> file to
                        the <code class="filename">meta-mylayer/recipes-kernel/linux/linux-yocto</code>
                        directory.</p></li></ol></div><p>
            </p></div><div class="section" title="5.7.5. Set Up for the Build"><div class="titlepage"><div><div><h3 class="title"><a id="set-up-for-the-build"></a>5.7.5. Set Up for the Build</h3></div></div></div><p>
                Do the following to make sure the build parameters are set up for the example.
                Once you set up these build parameters, they do not have to change unless you
                change the target architecture of the machine you are building:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Build for the Correct Target Architecture:</em></span> Your
                        selected <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-MACHINE" target="_top"><code class="filename">MACHINE</code></a>
                        definition within the <code class="filename">local.conf</code> file in the Build Directory
                        specifies the target architecture used when building the Linux kernel.
                        By default, <code class="filename">MACHINE</code> is set to
                        <code class="filename">qemux86</code>, which specifies a 32-bit
                        <span class="trademark">Intel</span>® Architecture
                        target machine suitable for the QEMU emulator.</p></li><li class="listitem"><p><span class="emphasis"><em>Identify Your <code class="filename">meta-mylayer</code>
                        Layer:</em></span> The <code class="filename">BBLAYERS</code> variable in the
                        <code class="filename">bblayers.conf</code> file found in the
                        <code class="filename">poky/build/conf</code> directory needs to have the path to your local
                        <code class="filename">meta-mylayer</code> layer.
                        By default, the <code class="filename">BBLAYERS</code> variable contains paths to
                        <code class="filename">meta</code>, <code class="filename">meta-yocto</code>, and
                        <code class="filename">meta-yocto-bsp</code> in the
                        <code class="filename">poky</code> Git repository.
                        Add the path to your <code class="filename">meta-mylayer</code> location:
                        </p><pre class="literallayout">
     BBLAYERS ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       $HOME/poky/meta-yocto-bsp \
       $HOME/poky/meta-mylayer \
       "

     BBLAYERS_NON_REMOVABLE ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       "
                        </pre></li></ul></div><p>
            </p></div><div class="section" title="5.7.6. Build and Booting the Modified QEMU Kernel Image"><div class="titlepage"><div><div><h3 class="title"><a id="build-and-booting-the-modified-qemu-kernel-image"></a>5.7.6. Build and Booting the Modified QEMU Kernel Image</h3></div></div></div><p>
                The following steps build and boot your modified kernel image:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Be sure your build environment is initialized</em></span>:
                        Your environment should be set up since you previously sourced
                        the <code class="filename">oe-init-build-env</code> script.
                        If it is not, source the script again from <code class="filename">poky</code>.
                        </p><pre class="literallayout">
     $ cd ~/poky
     $ source oe-init-build-env
                        </pre><p>
                        </p></li><li class="listitem"><p><span class="emphasis"><em>Clean up</em></span>:
                        Be sure to clean the shared state out by running the
                        <code class="filename">cleansstate</code> BitBake task as follows from your Build Directory:
                        </p><pre class="literallayout">
     $ bitbake -c cleansstate linux-yocto
                        </pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Never remove any files by hand from the <code class="filename">tmp/deploy</code>
                        directory inside the Build Directory.
                        Always use the various BitBake clean tasks to clear out previous
                        build artifacts.
                        </div></li><li class="listitem"><p><span class="emphasis"><em>Build the image</em></span>:
                        Next, build the kernel image using this command:
                        </p><pre class="literallayout">
     $ bitbake -k linux-yocto
                        </pre></li></ol></div><p>
            </p></div><div class="section" title="5.7.7. Verify Your Changes"><div class="titlepage"><div><div><h3 class="title"><a id="verify-your-changes"></a>5.7.7. Verify Your Changes</h3></div></div></div><p>
                These steps boot the image and allow you to see the changes
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Boot the image</em></span>:
                        Boot the modified image in the QEMU emulator
                        using this command:
                        </p><pre class="literallayout">
     $ runqemu qemux86
                        </pre></li><li class="listitem"><p><span class="emphasis"><em>Verify the changes</em></span>:
                        Log into the machine using <code class="filename">root</code> with no password and then
                        use the following shell command to scroll through the console's boot output.
                        </p><pre class="literallayout">
     # dmesg | less
                        </pre><p>
                        You should see the results of your <code class="filename">printk</code> statements
                        as part of the output.</p></li></ol></div><p>
            </p></div></div><div class="section" title="5.8. Updating Existing Images"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="usingpoky-changes-updatingimages"></a>5.8. Updating Existing Images</h2></div></div></div><p>
            Often, rather than re-flashing a new image, you might wish to install updated
            packages into an existing running system.
            You can do this by first sharing the <code class="filename">tmp/deploy/ipk/</code> directory
            through a web server and then by changing <code class="filename">/etc/opkg/base-feeds.conf</code>
            to point at the shared server.
            Following is an example:
            </p><pre class="literallayout">
     $ src/gz all http://www.mysite.com/somedir/deploy/ipk/all
     $ src/gz armv7a http://www.mysite.com/somedir/deploy/ipk/armv7a
     $ src/gz beagleboard http://www.mysite.com/somedir/deploy/ipk/beagleboard
            </pre><p>
        </p></div><div class="section" title="5.9. Working with Packages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="working-with-packages"></a>5.9. Working with Packages</h2></div></div></div><p>
            This section describes a few tasks that involve packages:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Incrementing a package revision number
                    </p></li><li class="listitem"><p>Handling a package name alias
                    </p></li><li class="listitem"><p>Handling option module packaging
                    </p></li></ul></div><p>
        </p><div class="section" title="5.9.1. Incrementing a Package Revision Number"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-changes-prbump"></a>5.9.1. Incrementing a Package Revision Number</h3></div></div></div><p>
                If a committed change results in changing the package output,
                then the value of the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PR" target="_top">PR</a></code>
                variable needs to be increased
                (or "bumped") as part of that commit.
                For new recipes you should add the <code class="filename">PR</code>
                variable and set its initial value equal to "r0", which is the default.
                Even though the default value is "r0", the practice of adding it to a new recipe makes
                it harder to forget to bump the variable when you make changes
                to the recipe in future.
            </p><p>
                If you are sharing a common <code class="filename">.inc</code> file with multiple recipes,
                you can also use the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-INC_PR" target="_top">INC_PR</a></code>
                variable to ensure that
                the recipes sharing the <code class="filename">.inc</code> file are rebuilt when the
                <code class="filename">.inc</code> file itself is changed.
                The <code class="filename">.inc</code> file must set <code class="filename">INC_PR</code>
                (initially to "r0"), and all recipes referring to it should set <code class="filename">PR</code>
                to "$(INC_PR).0" initially, incrementing the last number when the recipe is changed.
                If the <code class="filename">.inc</code> file is changed then its
                <code class="filename">INC_PR</code> should be incremented.
            </p><p>
                When upgrading the version of a package, assuming the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PV" target="_top">PV</a></code>
                changes, the <code class="filename">PR</code> variable should be reset to "r0"
                (or "$(INC_PR).0" if you are using <code class="filename">INC_PR</code>).
            </p><p>
                Usually, version increases occur only to packages.
                However, if for some reason <code class="filename">PV</code> changes but does not
                increase, you can increase the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PE" target="_top">PE</a></code>
                variable (Package Epoch).
                The <code class="filename">PE</code> variable defaults to "0".
            </p><p>
                Version numbering strives to follow the
                <a class="ulink" href="http://www.debian.org/doc/debian-policy/ch-controlfields.html" target="_top">
                Debian Version Field Policy Guidelines</a>.
                These guidelines define how versions are compared and what "increasing" a version means.
            </p><p>
                There are two reasons for following the previously mentioned guidelines.
                First, to ensure that when a developer updates and rebuilds, they get all the changes to
                the repository and do not have to remember to rebuild any sections.
                Second, to ensure that target users are able to upgrade their
                devices using package manager commands such as <code class="filename">opkg upgrade</code>
                (or similar commands for dpkg/apt or rpm-based systems).
            </p><p>
                The goal is to ensure the Yocto Project has packages that can be upgraded in all cases.
            </p></div><div class="section" title="5.9.2. Handling a Package Name Alias"><div class="titlepage"><div><div><h3 class="title"><a id="usingpoky-configuring-DISTRO_PN_ALIAS"></a>5.9.2. Handling a Package Name Alias</h3></div></div></div><p>
                Sometimes a package name you are using might exist under an alias or as a similarly named
                package in a different distribution.
                The OpenEmbedded build system implements a <code class="filename">distro_check</code>
                task that automatically connects to major distributions
                and checks for these situations.
                If the package exists under a different name in a different distribution, you get a
                <code class="filename">distro_check</code> mismatch.
                You can resolve this problem by defining a per-distro recipe name alias using the
                <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-DISTRO_PN_ALIAS" target="_top">DISTRO_PN_ALIAS</a></code>
                variable.
            </p><p>
                Following is an example that shows how you specify the <code class="filename">DISTRO_PN_ALIAS</code>
                variable:
                </p><pre class="literallayout">
     DISTRO_PN_ALIAS_pn-PACKAGENAME = "distro1=package_name_alias1 \
                                       distro2=package_name_alias2 \
                                       distro3=package_name_alias3 \
                                       ..."
                </pre><p>
            </p><p>
                If you have more than one distribution alias, separate them with a space.
                Note that the build system currently automatically checks the
                Fedora, OpenSuSE, Debian, Ubuntu,
                and Mandriva distributions for source package recipes without having to specify them
                using the <code class="filename">DISTRO_PN_ALIAS</code> variable.
                For example, the following command generates a report that lists the Linux distributions
                that include the sources for each of the recipes.
                </p><pre class="literallayout">
     $ bitbake world -f -c distro_check
                </pre><p>
                The results are stored in the <code class="filename">build/tmp/log/distro_check-${DATETIME}.results</code>
                file found in the Source Directory.
            </p></div><div class="section" title="5.9.3. Handling Optional Module Packaging"><div class="titlepage"><div><div><h3 class="title"><a id="handling-optional-module-packaging"></a>5.9.3. Handling Optional Module Packaging</h3></div></div></div><p>
                Many pieces of software split functionality into optional
                modules (or plugins) and the plugins that are built
                might depend on configuration options.
                To avoid having to duplicate the logic that determines what
                modules are available in your recipe or to avoid having
                to package each module by hand, the OpenEmbedded build system
                provides functionality to handle module packaging dynamically.
            </p><p>
                To handle optional modual packaging, you need to do two things:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Ensure the module packaging is actually
                        done</p></li><li class="listitem"><p>Ensure that any dependencies on optional
                        modules from other recipes are satisfied by your recipe
                        </p></li></ul></div><p>
            </p><div class="section" title="5.9.3.1. Making Sure the Packaging is Done"><div class="titlepage"><div><div><h4 class="title"><a id="making-sure-the-packaging-is-done"></a>5.9.3.1. Making Sure the Packaging is Done</h4></div></div></div><p>
                    To ensure the module packaging actually gets done, you use
                    the <code class="filename">do_split_packages</code> function within
                    the <code class="filename">populate_packages</code> python function
                    in your recipe.
                    The <code class="filename">do_split_packages</code> function
                    searches for a pattern of files or directories under a
                    specified path and creates a package for each one it finds
                    by appending to the <code class="filename">PACKAGES</code> variable
                    and setting the appropriate values for
                    <code class="filename">FILES_packagename</code>,
                    <code class="filename">RDEPENDS_packagename</code>,
                    <code class="filename">DESCRIPTION_packagename</code>, and so forth.
                    Here is an example from the <code class="filename">lighttpd</code>
                    recipe:
                    </p><pre class="literallayout">
     python populate_packages_prepend () {
         lighttpd_libdir = d.expand('${libdir}')
         do_split_packages(d, lighttpd_libdir, '^mod_(.*)\.so$',
                          'lighttpd-module-%s', 'Lighttpd module for %s',
                           extra_depends='')
     }
                    </pre><p>
                    The previous example specifies a number of things in the
                    call to <code class="filename">do_split_packages</code>.
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A directory within the files installed
                            by your recipe through <code class="filename">do_install</code>
                            in which to search.</p></li><li class="listitem"><p>A regular expression to match module
                            files in that directory.
                            In the example, note the parentheses () that mark
                            the part of the expression from which the module
                            name should be derived.</p></li><li class="listitem"><p>A pattern to use for the package names.
                            </p></li><li class="listitem"><p>A description for each package.
                            </p></li><li class="listitem"><p>An empty string for
                            <code class="filename">extra_depends</code>, which disables
                            the default dependency on the main
                            <code class="filename">lighttpd</code> package.
                            Thus, if a file in <code class="filename">${libdir}</code>
                            called <code class="filename">mod_alias.so</code> is found,
                            a package called <code class="filename">lighttpd-module-alias</code>
                            is created for it and the <code class="filename">DESCRIPTION</code>
                            is set to "Lighttpd module for alias".</p></li></ul></div><p>
                </p><p>
                    Often, packaging modules is as simple as the previous
                    example.
                    However, more advanced options exist that you can employ
                    to <code class="filename">do_split_packages</code> to modify its
                    behavior.
                    And, if you need to, you can add more logic by specifying
                    a hook function that is called for each package.
                    It is also perfectly acceptable to call
                    <code class="filename">do_split_packages</code> multiple times if
                    you have more than one set of modules to package.
                </p><p>
                    For more examples that show how to use
                    <code class="filename">do_split_packages</code>, see the
                    <code class="filename">connman.inc</code> file in the
                    <code class="filename">meta/recipes-connectivity/connman/</code>
                    directory of the <code class="filename">poky</code> source repository.
                    You can also find examples in
                    <code class="filename">meta/classes/kernel.bbclass</code>.
                 </p><p>
                     Following is a reference that shows
                     <code class="filename">do_split_packages</code> mandatory and
                     optional arguments:
                     </p><pre class="literallayout">
     Mandatory arguments

     root
        The path in which to search
     file_regex
        Regular expression to match searched files.
        Use parentheses () to mark the part of this
        expression that should be used to derive the
        module name (to be substituted where %s is
        used in other function arguments as noted below)
     output_pattern
        Pattern to use for the package names. Must
        include %s.
     description
        Description to set for each package. Must
        include %s.

     Optional arguments

     postinst
        Postinstall script to use for all packages
        (as a string)
     recursive
        True to perform a recursive search - default
        False
     hook
        A hook function to be called for every match.
        The function will be called with the following
        arguments (in the order listed):

        f
           Full path to the file/directory match
        pkg
           The package name
        file_regex
           As above
        output_pattern
           As above
        modulename
           The module name derived using file_regex

     extra_depends
        Extra runtime dependencies (RDEPENDS) to be
        set for all packages. The default value of None
        causes a dependency on the main package
        (${PN}) - if you do not want this, pass empty
        string '' for this parameter.
     aux_files_pattern
        Extra item(s) to be added to FILES for each
        package. Can be a single string item or a list
        of strings for multiple items. Must include %s.
     postrm
        postrm script to use for all packages (as a
        string)
     allow_dirs
        True to allow directories to be matched -
        default False
     prepend
        If True, prepend created packages to PACKAGES
        instead of the default False which appends them
     match_path
        match file_regex on the whole relative path to
        the root rather than just the file name
     aux_files_pattern_verbatim
        Extra item(s) to be added to FILES for each
        package, using the actual derived module name
        rather than converting it to something legal
        for a package name. Can be a single string item
        or a list of strings for multiple items. Must
        include %s.
     allow_links
        True to allow symlinks to be matched - default
        False
                     </pre><p>
                 </p></div><div class="section" title="5.9.3.2. Satisfying Dependencies"><div class="titlepage"><div><div><h4 class="title"><a id="satisfying-dependencies"></a>5.9.3.2. Satisfying Dependencies</h4></div></div></div><p>
                    The second part for handling optional module packaging
                    is to ensure that any dependencies on optional modules
                    from other recipes are satisfied by your recipe.
                    You can be sure these dependencies are satisfied by
                    using the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PACKAGES_DYNAMIC" target="_top"><code class="filename">PACKAGES_DYNAMIC</code></a> variable.
                    Here is an example that continues with the
                    <code class="filename">lighttpd</code> recipe shown earlier:
                    </p><pre class="literallayout">
     PACKAGES_DYNAMIC = "lighttpd-module-.*"
                    </pre><p>
                    The name specified in the regular expression can of
                    course be anything.
                    In this example, it is <code class="filename">lighttpd-module-</code>
                    and is specified as the prefix to ensure that any
                    <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RDEPENDS" target="_top"><code class="filename">RDEPENDS</code></a>
                    and <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-RRECOMMENDS" target="_top"><code class="filename">RRECOMMENDS</code></a>
                    on a package name starting with the prefix are satisfied
                    during build time.
                    If you are using <code class="filename">do_split_packages</code>
                    as described in the previous section, the value you put in
                    <code class="filename">PACKAGES_DYNAMIC</code> should correspond to
                    the name pattern specified in the call to
                    <code class="filename">do_split_packages</code>.
                </p></div></div></div><div class="section" title="5.10. Building Software from an External Source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="building-software-from-an-external-source"></a>5.10. Building Software from an External Source</h2></div></div></div><p>
            By default, the OpenEmbedded build system does its work from within the
            <a class="link" href="#build-directory">Build Directory</a>.
            The build process involves fetching the source files, unpacking them, and then patching them
            if necessary before the build takes place.
        </p><p>
            Situations exist where you might want to build software from source files that are external to
            and thus outside of the <a class="link" href="#source-directory">Source Directory</a>.
            For example, suppose you have a project that includes a new BSP with a heavily customized
            kernel, a very minimal image, and some new user-space recipes.
            And, you want to minimize exposing the build system to the
            development team so that they can focus on their project and maintain everyone's workflow
            as much as possible.
            In this case, you want a kernel source directory on the development machine where the
            development occurs.
            You want the recipe's
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
            variable to point to the external directory and use it as is, not copy it.
        </p><p>
            To build from software that comes from an external source, all you need to do is
            change your recipe so that it inherits the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-classes-externalsrc" target="_top"><code class="filename">externalsrc.bbclass</code></a>
            class and then sets the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-S" target="_top"><code class="filename">S</code></a>
            variable to point to your external source code.
            Here are the statements to put in your recipe:
            </p><pre class="literallayout">
     inherit externalsrc
     S = "/some/path/to/your/package/source"
            </pre><p>
        </p><p>
            It is important to know that the <code class="filename">externalsrc.bbclass</code> assumes that the
            source directory <code class="filename">S</code> and the Build Directory
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-B" target="_top"><code class="filename">B</code></a>
            are different even though by default these directories are the same.
            This assumption is important because it supports building different variants of the recipe
            by using the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBCLASSEXTEND" target="_top"><code class="filename">BBCLASSEXTEND</code></a>
            variable.
            You could allow the Build Directory to be the same as the source directory but you would
            not be able to build more than one variant of the recipe.
            Consequently, if you are building multiple variants of the recipe, you need to establish a
            Build Directory that is different than the source directory.
        </p></div><div class="section" title="5.11. Excluding Recipes From the Build"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="excluding-recipes-from-the-build"></a>5.11. Excluding Recipes From the Build</h2></div></div></div><p>
            You might find that there are groups of recipes you want to filter
            out of the build process.
            For example, recipes you know you will never use or want should not
            be part of the build.
            Removing these recipes from parsing speeds up parts of the build.
        </p><p>
            It is possible to filter or mask out <code class="filename">.bb</code> and
            <code class="filename">.bbappend</code> files.
            You can do this by providing an expression with the
            <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-BBMASK" target="_top">BBMASK</a></code>
            variable.
            Here is an example:
            </p><pre class="literallayout">
     BBMASK = ".*/meta-mymachine/recipes-maybe/"
            </pre><p>
            Here, all <code class="filename">.bb</code> and <code class="filename">.bbappend</code> files
            in the directory that match the expression are ignored during the build
            process.
        </p></div><div class="section" title="5.12. Using an External SCM"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="platdev-appdev-srcrev"></a>5.12. Using an External SCM</h2></div></div></div><p>
            If you're working on a recipe that pulls from an external Source Code Manager (SCM), it
            is possible to have the OpenEmbedded build system notice new recipe changes added to the
            SCM and then build the resulting package that depends on the new recipes by using the latest
            versions.
            This only works for SCMs from which it is possible to get a sensible revision number for changes.
            Currently, you can do this with Apache Subversion (SVN), Git, and Bazaar (BZR) repositories.
        </p><p>
            To enable this behavior, simply add the following to the <code class="filename">local.conf</code>
            configuration file found in the
            <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/dev-manual/dev-manual.html#build-directory" target="_top">Build Directory</a>:
            </p><pre class="literallayout">
     SRCREV_pn-&lt;PN&gt; = "${AUTOREV}"
            </pre><p>
            where <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a>
            is the name of the recipe for which you want to enable automatic source
            revision updating.
        </p></div><div class="section" title="5.13. Debugging With the GNU Project Debugger (GDB) Remotely"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="platdev-gdb-remotedebug"></a>5.13. Debugging With the GNU Project Debugger (GDB) Remotely</h2></div></div></div><p>
            GDB allows you to examine running programs, which in turn helps you to understand and fix problems.
            It also allows you to perform post-mortem style analysis of program crashes.
            GDB is available as a package within the Yocto Project and by default is
            installed in SDK images.
            See the "<a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>" chapter
            in the Yocto Project Reference Manual for a description of these images.
            You can find information on GDB at <a class="ulink" href="http://sourceware.org/gdb/" target="_top">http://sourceware.org/gdb/</a>.
        </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3>
            For best results, install <code class="filename">-dbg</code> packages for the applications
            you are going to debug.
            Doing so makes available extra debug symbols that give you more meaningful output.
        </div><p>
            Sometimes, due to memory or disk space constraints, it is not possible
            to use GDB directly on the remote target to debug applications.
            These constraints arise because GDB needs to load the debugging information and the
            binaries of the process being debugged.
            Additionally, GDB needs to perform many computations to locate information such as function
            names, variable names and values, stack traces and so forth - even before starting the
            debugging process.
            These extra computations place more load on the target system and can alter the
            characteristics of the program being debugged.
        </p><p>
            To help get past the previously mentioned constraints, you can use Gdbserver.
            Gdbserver runs on the remote target and does not load any debugging information
            from the debugged process.
            Instead, a GDB instance processes the debugging information that is run on a
            remote computer - the host GDB.
            The host GDB then sends control commands to Gdbserver to make it stop or start the debugged
            program, as well as read or write memory regions of that debugged program.
            All the debugging information loaded and processed as well
            as all the heavy debugging is done by the host GDB.
            Offloading these processes gives the Gdbserver running on the target a chance to remain
            small and fast.
        </p><p>
            Because the host GDB is responsible for loading the debugging information and
            for doing the necessary processing to make actual debugging happen, the
            user has to make sure the host can access the unstripped binaries complete
            with their debugging information and also be sure the target is compiled with no optimizations.
            The host GDB must also have local access to all the libraries used by the
            debugged program.
            Because Gdbserver does not need any local debugging information, the binaries on
            the remote target can remain stripped.
            However, the binaries must also be compiled without optimization
            so they match the host's binaries.
        </p><p>
            To remain consistent with GDB documentation and terminology, the binary being debugged
            on the remote target machine is referred to as the "inferior" binary.
            For documentation on GDB see the
            <a class="ulink" href="http://sourceware.org/gdb/documentation/" target="_top">GDB site</a>.
        </p><div class="section" title="5.13.1. Launching Gdbserver on the Target"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-gdb-remotedebug-launch-gdbserver"></a>5.13.1. Launching Gdbserver on the Target</h3></div></div></div><p>
                First, make sure Gdbserver is installed on the target.
                If it is not, install the package <code class="filename">gdbserver</code>, which needs the
                <code class="filename">libthread-db1</code> package.
            </p><p>
                As an example, to launch Gdbserver on the target and make it ready to "debug" a
                program located at <code class="filename">/path/to/inferior</code>, connect
                to the target and launch:
                </p><pre class="literallayout">
     $ gdbserver localhost:2345 /path/to/inferior
                </pre><p>
                Gdbserver should now be listening on port 2345 for debugging
                commands coming from a remote GDB process that is running on the host computer.
                Communication between Gdbserver and the host GDB are done using TCP.
                To use other communication protocols, please refer to the
                <a class="ulink" href="http://www.gnu.org/software/gdb/" target="_top">Gdbserver documentation</a>.
            </p></div><div class="section" title="5.13.2. Launching GDB on the Host Computer"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-gdb-remotedebug-launch-gdb"></a>5.13.2. Launching GDB on the Host Computer</h3></div></div></div><p>
                Running GDB on the host computer takes a number of stages.
                This section describes those stages.
            </p><div class="section" title="5.13.2.1. Building the Cross-GDB Package"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-gdb-remotedebug-launch-gdb-buildcross"></a>5.13.2.1. Building the Cross-GDB Package</h4></div></div></div><p>
                    A suitable GDB cross-binary is required that runs on your host computer but
                    also knows about the the ABI of the remote target.
                    You can get this binary from the meta-toolchain.
                    Here is an example:
                    </p><pre class="literallayout">
     /usr/local/poky/eabi-glibc/arm/bin/arm-poky-linux-gnueabi-gdb
                    </pre><p>
                    where <code class="filename">arm</code> is the target architecture and
                    <code class="filename">linux-gnueabi</code> the target ABI.
                </p><p>
                    Alternatively, you can use BitBake to build the <code class="filename">gdb-cross</code> binary.
                    Here is an example:
                    </p><pre class="literallayout">
     $ bitbake gdb-cross
                    </pre><p>
                    Once the binary is built, you can find it here:
                    </p><pre class="literallayout">
     tmp/sysroots/&lt;host-arch&gt;/usr/bin/&lt;target-abi&gt;-gdb
                    </pre><p>
                </p></div><div class="section" title="5.13.2.2. Making the Inferior Binaries Available"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-gdb-remotedebug-launch-gdb-inferiorbins"></a>5.13.2.2. Making the Inferior Binaries Available</h4></div></div></div><p>
                    The inferior binary (complete with all debugging symbols), as well as any
                    libraries (and their debugging symbols) on which the inferior binary depends,
                    needs to be available.
                    There are a number of ways you can make these items available.
                </p><p>
                    Perhaps the easiest way is to have an SDK image that corresponds to the plain
                    image installed on the device.
                    In the case of <code class="filename">core-image-sato</code>,
                    <code class="filename">core-image-sato-sdk</code> would contain suitable symbols.
                    Because the SDK images already have the debugging symbols installed, it is just a
                    question of expanding the archive to some location and then informing GDB.
                </p><p>
                    Alternatively, the OpenEmbedded build system can build a custom directory of files
                    for a specific
                    debugging purpose by reusing its <code class="filename">tmp/rootfs</code> directory.
                    This directory contains the contents of the last built image.
                    This process assumes two things:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The image running on the target was the last image to
                        be built.</p></li><li class="listitem"><p>The package (<code class="filename">foo</code> in the following
                        example) that contains the inferior binary to be debugged has been built
                        without optimization and has debugging information available.</p></li></ul></div><p>
                </p><p>
                    The following steps show how to build the custom directory of files:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Install the package (<code class="filename">foo</code> in this case) to
                            <code class="filename">tmp/rootfs</code>:
                            </p><pre class="literallayout">
     $ tmp/sysroots/i686-linux/usr/bin/opkg-cl -f \
     tmp/work/&lt;target-abi&gt;/core-image-sato-1.0-r0/temp/opkg.conf -o \
     tmp/rootfs/ update
                            </pre></li><li class="listitem"><p>Install the debugging information:
                            </p><pre class="literallayout">
     $ tmp/sysroots/i686-linux/usr/bin/opkg-cl -f \
     tmp/work/&lt;target-abi&gt;/core-image-sato-1.0-r0/temp/opkg.conf \
     -o tmp/rootfs install foo

     $ tmp/sysroots/i686-linux/usr/bin/opkg-cl -f \
     tmp/work/&lt;target-abi&gt;/core-image-sato-1.0-r0/temp/opkg.conf \
     -o tmp/rootfs install foo-dbg
                            </pre></li></ol></div><p>
                </p></div><div class="section" title="5.13.2.3. Launch the Host GDB"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-gdb-remotedebug-launch-gdb-launchhost"></a>5.13.2.3. Launch the Host GDB</h4></div></div></div><p>
                    To launch the host GDB, you run the <code class="filename">cross-gdb</code> binary and provide
                    the inferior binary as part of the command line.
                    For example, the following command form continues with the example used in
                    the previous section.
                    This command form loads the <code class="filename">foo</code> binary
                    as well as the debugging information:
                    </p><pre class="literallayout">
     $ &lt;target-abi&gt;-gdb rootfs/usr/bin/foo
                    </pre><p>
                    Once the GDB prompt appears, you must instruct GDB to load all the libraries
                    of the inferior binary from <code class="filename">tmp/rootfs</code> as follows:
                    </p><pre class="literallayout">
     $ set solib-absolute-prefix /path/to/tmp/rootfs
                    </pre><p>
                    The pathname <code class="filename">/path/to/tmp/rootfs</code> must either be
                    the absolute path to <code class="filename">tmp/rootfs</code> or the location at which
                    binaries with debugging information reside.
                </p><p>
                    At this point you can have GDB connect to the Gdbserver that is running
                    on the remote target by using the following command form:
                    </p><pre class="literallayout">
     $ target remote remote-target-ip-address:2345
                    </pre><p>
                    The <code class="filename">remote-target-ip-address</code> is the IP address of the
                    remote target where the Gdbserver is running.
                    Port 2345 is the port on which the GDBSERVER is running.
                </p></div><div class="section" title="5.13.2.4. Using the Debugger"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-gdb-remotedebug-launch-gdb-using"></a>5.13.2.4. Using the Debugger</h4></div></div></div><p>
                    You can now proceed with debugging as normal - as if you were debugging
                    on the local machine.
                    For example, to instruct GDB to break in the "main" function and then
                    continue with execution of the inferior binary use the following commands
                    from within GDB:
                    </p><pre class="literallayout">
     (gdb) break main
     (gdb) continue
                    </pre><p>
                </p><p>
                    For more information about using GDB, see the project's online documentation at
                    <a class="ulink" href="http://sourceware.org/gdb/download/onlinedocs/" target="_top">http://sourceware.org/gdb/download/onlinedocs/</a>.
                </p></div></div></div><div class="section" title="5.14. Profiling with OProfile"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="platdev-oprofile"></a>5.14. Profiling with OProfile</h2></div></div></div><p>
            <a class="ulink" href="http://oprofile.sourceforge.net/" target="_top">OProfile</a> is a
            statistical profiler well suited for finding performance
            bottlenecks in both userspace software and in the kernel.
            This profiler provides answers to questions like "Which functions does my application spend
            the most time in when doing X?"
            Because the OpenEmbedded build system is well integrated with OProfile, it makes profiling
            applications on target hardware straightforward.
        </p><p>
            To use OProfile, you need an image that has OProfile installed.
            The easiest way to do this is with <code class="filename">tools-profile</code> in the
            <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-IMAGE_FEATURES" target="_top">IMAGE_FEATURES</a></code> variable.
            You also need debugging symbols to be available on the system where the analysis
            takes place.
            You can gain access to the symbols by using <code class="filename">dbg-pkgs</code> in the
            <code class="filename">IMAGE_FEATURES</code> variable or by
            installing the appropriate <code class="filename">-dbg</code> packages.
        </p><p>
            For successful call graph analysis, the binaries must preserve the frame
            pointer register and should also be compiled with the
            <code class="filename">-fno-omit-framepointer</code> flag.
            You can achieve this by setting the
            <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-SELECTED_OPTIMIZATION" target="_top">SELECTED_OPTIMIZATION</a></code>
            variable with the following options:
            </p><pre class="literallayout">
     -fexpensive-optimizations
     -fno-omit-framepointer
     -frename-registers
     -O2
            </pre><p>
            You can also achieve it by setting the
            <code class="filename"><a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-DEBUG_BUILD" target="_top">DEBUG_BUILD</a></code>
            variable to "1" in the <code class="filename">local.conf</code> configuration file.
            If you use the <code class="filename">DEBUG_BUILD</code> variable,
            you will also add extra debug information that can make the debug packages large.
        </p><div class="section" title="5.14.1. Profiling on the Target"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-oprofile-target"></a>5.14.1. Profiling on the Target</h3></div></div></div><p>
                Using OProfile you can perform all the profiling work on the target device.
                A simple OProfile session might look like the following:
            </p><p>
                </p><pre class="literallayout">
     # opcontrol --reset
     # opcontrol --start --separate=lib --no-vmlinux -c 5
              .
              .
        [do whatever is being profiled]
              .
              .
     # opcontrol --stop
     $ opreport -cl
                </pre><p>
            </p><p>
                In this example, the <code class="filename">reset</code> command clears any previously profiled data.
                The next command starts OProfile.
                The options used when starting the profiler separate dynamic library data
                within applications, disable kernel profiling, and enable callgraphing up to
                five levels deep.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    To profile the kernel, you would specify the
                    <code class="filename">--vmlinux=/path/to/vmlinux</code> option.
                    The <code class="filename">vmlinux</code> file is usually in the source directory in the
                    <code class="filename">/boot/</code> directory and must match the running kernel.
                </div><p>
            </p><p>
                After you perform your profiling tasks, the next command stops the profiler.
                After that, you can view results with the <code class="filename">opreport</code> command with options
                to see the separate library symbols and callgraph information.
            </p><p>
                Callgraphing logs information about time spent in functions and about a function's
                calling function (parent) and called functions (children).
                The higher the callgraphing depth, the more accurate the results.
                However, higher depths also increase the logging overhead.
                Consequently, you should take care when setting the callgraphing depth.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    On ARM, binaries need to have the frame pointer enabled for callgraphing to work.
                    To accomplish this use the <code class="filename">-fno-omit-framepointer</code> option
                    with <code class="filename">gcc</code>.
                </div><p>
            </p><p>
                For more information on using OProfile, see the OProfile
                online documentation at
                <a class="ulink" href="http://oprofile.sourceforge.net/docs/" target="_top">http://oprofile.sourceforge.net/docs/</a>.
            </p></div><div class="section" title="5.14.2. Using OProfileUI"><div class="titlepage"><div><div><h3 class="title"><a id="platdev-oprofile-oprofileui"></a>5.14.2. Using OProfileUI</h3></div></div></div><p>
                A graphical user interface for OProfile is also available.
                You can download and build this interface from the Yocto Project at
                <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/oprofileui/" target="_top">http://git.yoctoproject.org/cgit.cgi/oprofileui/</a>.
                If the "tools-profile" image feature is selected, all necessary binaries
                are installed onto the target device for OProfileUI interaction.
            </p><p>
                Even though the source directory usually includes all needed patches on the target device, you
                might find you need other OProfile patches for recent OProfileUI features.
                If so, see the <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi/oprofileui/tree/README" target="_top">
                OProfileUI README</a> for the most recent information.
            </p><div class="section" title="5.14.2.1. Online Mode"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-oprofile-oprofileui-online"></a>5.14.2.1. Online Mode</h4></div></div></div><p>
                    Using OProfile in online mode assumes a working network connection with the target
                    hardware.
                    With this connection, you just need to run "oprofile-server" on the device.
                    By default, OProfile listens on port 4224.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                        You can change the port using the <code class="filename">--port</code> command-line
                        option.
                    </div><p>
                </p><p>
                    The client program is called <code class="filename">oprofile-viewer</code> and its UI is relatively
                    straightforward.
                    You access key functionality through the buttons on the toolbar, which
                    are duplicated in the menus.
                    Here are the buttons:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Connect:</em></span> Connects to the remote host.
                            You can also supply the IP address or hostname.</p></li><li class="listitem"><p><span class="emphasis"><em>Disconnect:</em></span> Disconnects from the target.
                            </p></li><li class="listitem"><p><span class="emphasis"><em>Start:</em></span> Starts profiling on the device.
                            </p></li><li class="listitem"><p><span class="emphasis"><em>Stop:</em></span> Stops profiling on the device and
                            downloads the data to the local host.
                            Stopping the profiler generates the profile and displays it in the viewer.
                            </p></li><li class="listitem"><p><span class="emphasis"><em>Download:</em></span> Downloads the data from the
                            target and generates the profile, which appears in the viewer.</p></li><li class="listitem"><p><span class="emphasis"><em>Reset:</em></span> Resets the sample data on the device.
                            Resetting the data removes sample information collected from previous
                            sampling runs.
                            Be sure you reset the data if you do not want to include old sample information.
                            </p></li><li class="listitem"><p><span class="emphasis"><em>Save:</em></span> Saves the data downloaded from the
                            target to another directory for later examination.</p></li><li class="listitem"><p><span class="emphasis"><em>Open:</em></span> Loads previously saved data.
                            </p></li></ul></div><p>
                </p><p>
                    The client downloads the complete 'profile archive' from
                    the target to the host for processing.
                    This archive is a directory that contains the sample data, the object files,
                    and the debug information for the object files.
                    The archive is then converted using the <code class="filename">oparchconv</code> script, which is
                    included in this distribution.
                    The script uses <code class="filename">opimport</code> to convert the archive from
                    the target to something that can be processed on the host.
                </p><p>
                    Downloaded archives reside in the Build Directory in
                    <code class="filename">/tmp</code> and are cleared up when they are no longer in use.
                </p><p>
                    If you wish to perform kernel profiling, you need to be sure
                    a <code class="filename">vmlinux</code> file that matches the running kernel is available.
                    In the source directory, that file is usually located in
                    <code class="filename">/boot/vmlinux-KERNELVERSION</code>, where
                    <code class="filename">KERNEL-version</code> is the version of the kernel.
                    The OpenEmbedded build system generates separate <code class="filename">vmlinux</code>
                    packages for each kernel it builds.
                    Thus, it should just be a question of making sure a matching package is
                    installed (e.g. <code class="filename">opkg install kernel-vmlinux</code>.
                    The files are automatically installed into development and profiling images
                    alongside OProfile.
                    A configuration option exists within the OProfileUI settings page that you can use to
                    enter the location of the <code class="filename">vmlinux</code> file.
                </p><p>
                    Waiting for debug symbols to transfer from the device can be slow, and it
                    is not always necessary to actually have them on the device for OProfile use.
                    All that is needed is a copy of the filesystem with the debug symbols present
                    on the viewer system.
                    The "<a class="link" href="#platdev-gdb-remotedebug-launch-gdb" title="5.13.2. Launching GDB on the Host Computer">Launching GDB on the Host Computer</a>"
                    section covers how to create such a directory with
                    the source directory and how to use the OProfileUI Settings dialog to specify the location.
                    If you specify the directory, it will be used when the file checksums
                    match those on the system you are profiling.
                </p></div><div class="section" title="5.14.2.2. Offline Mode"><div class="titlepage"><div><div><h4 class="title"><a id="platdev-oprofile-oprofileui-offline"></a>5.14.2.2. Offline Mode</h4></div></div></div><p>
                    If network access to the target is unavailable, you can generate
                    an archive for processing in <code class="filename">oprofile-viewer</code> as follows:
                    </p><pre class="literallayout">
     # opcontrol --reset
     # opcontrol --start --separate=lib --no-vmlinux -c 5
            .
            .
     [do whatever is being profiled]
            .
            .
     # opcontrol --stop
     # oparchive -o my_archive
                    </pre><p>
                </p><p>
                    In the above example, <code class="filename">my_archive</code> is the name of the
                    archive directory where you would like the profile archive to be kept.
                    After the directory is created, you can copy it to another host and load it
                    using <code class="filename">oprofile-viewer</code> open functionality.
                    If necessary, the archive is converted.
                </p></div></div></div><div class="section" title="5.15. Maintaining Open Source License Compliance During Your Product's Lifecycle"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="maintaining-open-source-license-compliance-during-your-products-lifecycle"></a>5.15. Maintaining Open Source License Compliance During Your Product's Lifecycle</h2></div></div></div><p>
            One of the concerns for a development organization using open source
            software is how to maintain compliance with various open source
            licensing during the lifecycle of the product.
            While this section does not provide legal advice or
            comprehensively cover all scenarios, it does
            present methods that you can use to
            assist you in meeting the compliance requirements during a software
            release.
        </p><p>
            With hundreds of different open source licenses that the Yocto
            Project tracks, it is difficult to know the requirements of each
            and every license.
            However, we can begin to cover the requirements of the major FLOSS licenses, by
            assuming that there are three main areas of concern:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Source code must be provided.</p></li><li class="listitem"><p>License text for the software must be
                    provided.</p></li><li class="listitem"><p>Compilation scripts and modifications to the
                    source code must be provided.
                    </p></li></ul></div><p>
            There are other requirements beyond the scope of these
            three and the methods described in this section
            (e.g. the mechanism through which source code is distributed).
            As different organizations have different methods of complying with
            open source licensing, this section is not meant to imply that
            there is only one single way to meet your compliance obligations,
            but rather to describe one method of achieving compliance.
        </p><p>
            The remainder of this section describes methods supported to meet the
            previously mentioned three requirements.
            Once you take steps to meet these requirements,
            and prior to releasing images, sources, and the build system,
            you should audit all artifacts to ensure completeness.
            The Yocto Project generates a license manifest during
            image creation that is located
            in <code class="filename">${DEPLOY_DIR}/licenses/&lt;image_name-datestamp&gt;</code>
            to assist with any audits.
        </p><div class="section" title="5.15.1. Providing the Source Code"><div class="titlepage"><div><div><h3 class="title"><a id="providing-the-source-code"></a>5.15.1. Providing the Source Code</h3></div></div></div><p>
                Compliance activities should begin before you generate the
                final image.
                The first thing you should look at is the requirement that
                tops the list for most compliance groups - providing
                the source.
                The Yocto Project has a few ways of meeting this
                requirement.
            </p><p>
                One of the easiest ways to meet this requirement is
                to provide the entire
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-DL_DIR" target="_top"><code class="filename">DL_DIR</code></a>
                used by the build.
                This method, however, has a few issues.
                The most obvious is the size of the directory since it includes
                all sources used in the build and not just the source used in
                the released image.
                It will include toolchain source, and other artifacts which
                you would not generally release.
                But, the more serious issue for most companies is accidental
                release of proprietary software.
                The Yocto Project provides an archiver class to help avoid
                some of these concerns.
            </p><p>
                Before you employ <code class="filename">DL_DIR</code> or the
                archiver class, you need to decide how you choose to
                provide source.
                The source archiver class can generate tarballs and SRPMs
                and can create them with various levels of compliance in mind.
                One way of doing this (but certainly not the only way) is to
                release just the original source as a tarball.
                You can do this by adding the following to the
                <code class="filename">local.conf</code> file found in the
                <a class="link" href="#build-directory">Build Directory</a>:
                </p><pre class="literallayout">
     ARCHIVER_MODE ?= "original"
     ARCHIVER_CLASS = "${@'archive-${ARCHIVER_MODE}-source' if
     ARCHIVER_MODE != 'none' else ''}"
     INHERIT += "${ARCHIVER_CLASS}"
     SOURCE_ARCHIVE_PACKAGE_TYPE = "tar"
                </pre><p>
                During the creation of your image, all GPL
                or other copyleft licensed source
                is placed within subdirectories of
                <code class="filename">DEPLOY_DIR/sources</code> based on the
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/ref-manual/ref-manual.html#var-LICENSE" target="_top"><code class="filename">LICENSE</code></a>
                for each recipe.
                Releasing the entire directory enables you to comply with
                requirements concerning providing the unmodified source.
                It is important to note that the size of the directory can
                get large.
            </p><p>
                A way to help mitigate the size issue is to only release
                tarballs for licenses that require the release of
                source.
                Let's assume you are only concerned with GPL code as
                identified with the following:
                </p><pre class="literallayout">
     $ cd poky/build/tmp/deploy/sources
     $ mkdir ~/gpl_source_release
     $ for x in `ls|grep GPL`; do cp -R $x/* ~/gpl_source_release; done
                </pre><p>
                At this point, you could create a tarball from the
                <code class="filename">gpl_source_release</code> directory and
                provide that to the end user.
                This method would be a step toward achieving compliance
                with section 3a of GPLv2 and with section 6 of GPLv3.
            </p></div><div class="section" title="5.15.2. Providing License Text"><div class="titlepage"><div><div><h3 class="title"><a id="providing-license-text"></a>5.15.2. Providing License Text</h3></div></div></div><p>
                One requirement that is often overlooked is inclusion
                of license text.
                This requirement also needs to be dealt with prior to
                generating the final image.
                Some licenses require the license text to accompany
                the binary.
                You can achieve this by adding the following to your
                <code class="filename">local.conf</code> file:
                </p><pre class="literallayout">
     COPY_LIC_MANIFEST = "1"
     COPY_LIC_DIRS = "1"
                </pre><p>
                Adding these statements to the configuration file ensures
                that the licenses collected during package generation
                are included on your image.
                As the source archiver has already archived the original
                unmodified source which would contain the license files,
                you would have already met the requirements for inclusion
                of the license information with source as defined by the GPL
                and other open source licenses.
            </p></div><div class="section" title="5.15.3. Providing Compilation Scripts and Source Code Modifications"><div class="titlepage"><div><div><h3 class="title"><a id="providing-compilation-scripts-and-source-code-modifications"></a>5.15.3. Providing Compilation Scripts and Source Code Modifications</h3></div></div></div><p>
                At this point, we have addressed all we need to address
                prior to generating the image.
                The next two requirements are addressed during the final
                packaging of the release.
            </p><p>
                By releasing the version of the OpenEmbedded build system
                and the layers used during the build, you will be providing both
                compilation scripts and the source code modifications in one
                step.
            </p><p>
                If the deployment team has a
                <a class="ulink" href="http://www.yoctoproject.org/docs/1.4/bsp-guide/bsp-guide.html#bsp-layers" target="_top">BSP layer</a>
                and a distro layer, and those those layers are used to patch,
                compile, package, or modify (in any way) any open source
                software included in your released images, you
                may be required to to release those layers under section 3 of
                GPLv2 or section 1 of GPLv3.
                One way of doing that is with a clean
                checkout of the version of the Yocto Project and layers used
                during your build.
                Here is an example:
                </p><pre class="literallayout">
     # We built using the tbd branch of the poky repo
     $ git clone -b tbd git://git.yoctoproject.org/poky
     $ cd poky
     # We built using the release_branch for our layers
     $ git clone -b release_branch git://git.mycompany.com/meta-my-bsp-layer
     $ git clone -b release_branch git://git.mycompany.com/meta-my-software-layer
     # clean up the .git repos
     $ find . -name ".git" -type d -exec rm -rf {} \;
                </pre><p>
                One thing a development organization might want to consider
                for end-user convenience is to modify
                <code class="filename">meta-yocto/conf/bblayers.conf.sample</code> to
                ensure that when the end user utilizes the released build
                system to build an image, the development organization's
                layers are included in the <code class="filename">bblayers.conf</code>
                file automatically:
                </p><pre class="literallayout">
     # LAYER_CONF_VERSION is increased each time build/conf/bblayers.conf
     # changes incompatibly
     LCONF_VERSION = "6"

     BBPATH = "${TOPDIR}"
     BBFILES ?= ""

     BBLAYERS ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       $HOME/poky/meta-yocto-bsp \
       $HOME/poky/meta-mylayer \
       "

     BBLAYERS_NON_REMOVABLE ?= " \
       $HOME/poky/meta \
       $HOME/poky/meta-yocto \
       "
                </pre><p>
                Creating and providing an archive of the metadata layers
                (recipes, configuration files, and so forth)
                enables you to meet your
                requirements to include the scripts to control compilation
                as well as any modifications to the original source.
            </p></div></div></div>

</div></body></html>
