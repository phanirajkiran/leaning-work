路径:
LOG_DIR=/var/log
if [ `pwd` != "$LOG_DIR" ]  # or   if [ "$PWD" != "$LOG_DIR" ]
# Far more efficient is:
#
# cd /var/log || {
#   echo "Cannot change to necessary directory." >&2
#   exit $E_XCD;
# }

bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh


bash$ echo "$(ls -l)"
total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh
 
 长度
 ${var#Pattern} Remove from $var the shortest part of $Pattern that matches the front end of $var.
 
 
截断
${var##Pattern} Remove from $var the longest part of $Pattern that matches the front end of $var.
echo ${#stringZ} 


stringZ=abcABC123ABCabc
#       |----|          shortest
#       |----------|    longest

echo ${stringZ#a*C}      # 123ABCabc
# Strip out shortest match between 'a' and 'C'.

echo ${stringZ##a*C}     # abc
# Strip out longest match between 'a' and 'C'.

lyang0@lyang0-OptiPlex-755:~/WORK/git2$ a="x~back end~20120801.TXT 2KB"
lyang0@lyang0-OptiPlex-755:~/WORK/git2$ echo ${a% *}
x~back end~20120801.TXT
lyang0@lyang0-OptiPlex-755:~/WORK/git2$ echo ${a##* }
2KB

lyang0@lyang0-OptiPlex-755:~/WORK/git2$ a="sda36"
lyang0@lyang0-OptiPlex-755:~/WORK/git2$ echo ${a##sda}
36

while read -r line; do
  file=${line% *}
  size=${line##* }
  array+=( "$file" )
  printf '%s' "$file"
  ...
done


 echo "Length of var01 = ${#var01}"
 For an array, ${#array[*]} and ${#array[@]} give the number of elements in the array.
 echo "${PWD##*/}" PWD钱不用${}
 
 替换
 ${var/Pattern/Replacement}
First match of Pattern, within var replaced with Replacement.

If Replacement is omitted, then the first match of Pattern is replaced by nothing, that is, deleted.
c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # Substitute "23" for "BB".



echo '$hello'  # $hello
hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
if [ -z "$unassigned" ]
then
  echo "\$unassigned is NULL."
fi     # $unassigned is NULL.
echo "The value of \"a\" is now $a."

bash$ echo -e x\ty
xty
bash$ echo -e "x\ty"
x       y

===================================================
算术:
http://tldp.org/LDP/abs/html/arithexp.html
# Assignment using 'let'
let a=16+5
let "a += 1"
let "index = $index + 1"

((a += 1))             # let "a+=1"
a=$(($a+1))

z=$(($z+3))
z=$((z+3))                                  #  Also correct
  (( n += 1 ))                              # Increment.
a=`expr 5 % 3`

a=`ls -l`
R=$(cat /etc/redhat-release)
arch=$(uname -m)

if [ -n "${10}" ]  # Parameters > $9 must be enclosed in {brackets}.
args=$#           # Number of args passed.

var="'(]\\{}\$\""
echo $var        # '(]\{}$"
IFS='\'
echo $var        # '(] {}$"     \ converted to space. Why?
echo "$var"      # '(]\{}$"



流控:
case `basename $0` in    # Or:    case ${0##*/} in
    "wh"       ) whois $1@whois.tucows.com;;
    "wh-ripe"  ) whois $1@whois.ripe.net;;
    "wh-apnic" ) whois $1@whois.apnic.net;;
    "wh-cw"    ) whois $1@whois.cw.net;;
    *          ) echo "Usage: `basename $0` [domain-name]";;
esac 

case "$variable" in 
 
 
  case "$1" in
    -d|--debug)

case $( arch ) in   # $( arch ) returns machine architecture.
                    # Equivalent to 'uname -m' ...
  i386 ) echo "80386-based machine";;
  i486 ) echo "80486-based machine";;
  i586 ) echo "Pentium-based machine";;
  i686 ) echo "Pentium2+-based machine";;
  *    ) echo "Other type of machine";;
esac

exit 0
==========================================
List="one two three"
for a in $List     # Splits the variable in parts at whitespace.
do
  echo "$a"
done

NUMBERS="9 7 3 8 37.53"

for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53


for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"

for file in *



for file in $( find $directory -type f -name '*' | sort )


generate_list ()
{
  echo "one two three"
}

for word in $(generate_list)  # Let "word" grab output of function.
do
  echo "$word"
done

for a in `seq 10`
for a in {1..10}

LIMIT=10
for ((a=1; a <= LIMIT ; a++))  # Double parentheses, and naked "LIMIT"

for file in [jx]*

for name in $(awk 'BEGIN{FS=":"}{print $1}' < "$PASSWORD_FILE" )
===============================================================
while [ "$var0" -lt "$LIMIT" ]

while read line   # As long as there is another line to read ...
do
  ...
done <"$datafile"

while true

while :; do cat /proc/irq/*/smp_affinity ; sleep 10;done
============================================================================================================
let "num = (( 200 || 11 ))"
echo $num   # 1

=========================
if [ $xyz ]   # Tests if $xyz is null, but...
              # it's only an uninitialized variable.
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
  
if [ -x "$filename" ]; then

if [[ -e $file ]]
Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts. For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct.


The "if COMMAND" construct returns the exit status of COMMAND.
if cd "$dir" 2>/dev/null; then 

var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

fi            # Uninitialized variable is false.

# (( ... )) also useful in an if-then test.

var1=5
var2=4

if (( var1 > var2 ))
then #^      ^      Note: Not $var1, $var2. Why?
  echo "$var1 is greater than $var2"
fi     # 5 is greater than 4

exit 0

a=3

if [ "$a" -gt 0 ]
then
  if [ "$a" -lt 5 ]
  then
    echo "The value of \"a\" lies somewhere between 0 and 5."
  fi
fi

# Same result as:

if [ "$a" -gt 0 ] && [ "$a" -lt 5 ]
then
  echo "The value of \"a\" lies somewhere between 0 and 5."
fi

 if [[ "$inner" -eq 7 && "$outer" = "III" ]]

文件判断

http://tldp.org/LDP/abs/html/fto.html

比较判断

http://tldp.org/LDP/abs/html/comparison-ops.html
http://tldp.org/LDP/abs/html/opprecedence.html

====================================================================================================================
数组http://tldp.org/LDP/abs/html/arrays.html#EX66
area2=( zero one two three four )

echo -n "area2[0] = "
echo ${area2[0]}
area3=([17]=seventeen [24]=twenty-four)
echo ${area3[24]}

# Doing it with a "for" loop instead:
#   for i in "${colors[@]}"
#   do
#     echo "$i"
#   done
# (Thanks, S.C.)

=========================
http://stackoverflow.com/questions/229551/string-contains-in-bash
http://stackoverflow.com/questions/2829613/how-do-you-tell-if-a-string-contains-another-string-in-unix-shell-scripting


[ $? -eq 0 ] && echo "pass" || echo "fail"

Arithmetic Expansion

z=$(($z+3))
z=$((z+3)) 
let z=z+3

grep regex

lyang0@lyang0-OptiPlex-755:~/del$ echo a111b | grep -E 'a1+b' (=egrep)
a111b
lyang0@lyang0-OptiPlex-755:~/del$ echo a111b | grep 'a1\+b'
a111b

lyang0@lyang0-OptiPlex-755:~/del$ echo "read" |egrep 're(a|e)d' 
read
lyang0@lyang0-OptiPlex-755:~/del$ echo "read" |egrep 're[ae]d' 
read
lyang0@lyang0-OptiPlex-755:~/del$ echo "reed" |egrep 're[ae]d' 
reed

#Globbing
bash$ ls -l [ab]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1

bash$ ls -l [a-c]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1

bash$ ls -l {b*,c*,*est*}
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt

for file in [jx]*

if [[ $mail =~ "^From " ]]   # Match "From" field in message.

#Here documents are a special case of redirected code blocks. That being the case, it should be possible to feed the output of a here document into the stdin for a while loop.
#
#
#

function doesOutput()
 # Could be an external command too, of course.
 # Here we show you can use a function as well.
{
  ls -al *.jpg | awk '{print $5,$9}'
}


nr=0          #  We want the while loop to be able to manipulate these and
totalSize=0   #+ to be able to see the changes after the 'while' finished.

while read fileSize fileName ; do
  echo "$fileName is $fileSize bytes"
  let nr++
  totalSize=$((totalSize+fileSize))   # Or: "let totalSize+=fileSize"
done<<EOF
$(doesOutput)
EOF

while [ 1 ]   # Endless loop.

# Gives difference in command output
lyang0@lyang0-OptiPlex-755:~/del$ diff -u <(ls) <(ls -lrt)

#read
while read  des what mask iface; do
  echo $des $what $mask $iface
done < <(route -n) 

[ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")



#  Cleans up the temp file if script interrupted by control-c.
trap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT

# trap '' SIGNAL (two adjacent apostrophes) disables SIGNAL for the remainder of the script. trap SIGNAL restores the functioning of SIGNAL once more. This is useful to protect a critical portion of a script from an undesirable interrupt.
 

	trap '' 2  # Signal 2 is Control-C, now disabled.
	command
	command
	command
	trap 2     # Reenables Control-C

###cat
###
##
cat <<End-of-message
-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------
End-of-message

#  Replacing line 7, above, with
#+   cat > $Newfile <<End-of-message

#set
set -- a b
echo $1
echo $2


find /path/to/base -type d | while read LINE
do
        set -- $(ls -S "$LINE"/*.gz)
        [ "$#" -eq 2 ] || continue # Ignore folders that don't have 2 files

        echo "Keeping $1"
        echo rm "$2"
done

#ls -S sorts by file size. The largest one comes first.

shopt -s extglob #open
shopt -u extglob #close
rm *@(jpg|png) #delete the end with jpg or png

ls -l !(*.*)
ls -l -d !(*.*)


