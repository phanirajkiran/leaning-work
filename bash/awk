http://www.gnu.org/software/gawk/manual/html_node/String-Functions.html
http://www.vectorsite.net/tsawk.html great
linux awk 内置变量使用介绍
http://www.cnblogs.com/chengmo/archive/2010/10/06/1844818.html
属性 	说明
$0 	当前记录（作为单个变量） 
---->(   $0                一字符串， 其内容为目前awk 所读入的数据行。)
$1~$n 	当前记录的第n个字段，字段间由FS分隔
FS 	输入字段分隔符 默认是空格
NF 	当前记录中的字段个数，就是有多少列
NR 	已经读出的记录数，就是行号，从1开始
RS 	输入的记录他隔符默 认为换行符
OFS 	输出字段分隔符 默认也是空格
ORS 	输出的记录分隔符，默认为换行符
ARGC 	命令行参数个数
ARGV 	命令行参数数组
FILENAME 	当前输入文件的名字
IGNORECASE 	如果为真，则进行忽略大小写的匹配
ARGIND 	当前被处理文件的ARGV标志符
CONVFMT 	数字转换格式 %.6g
ENVIRON 	UNIX环境变量
ERRNO 	UNIX系统错误消息
FIELDWIDTHS 	输入字段宽度的空白分隔字符串
FNR 	当前记录数
OFMT 	数字的输出格式 %.6g
RSTART 	被匹配函数匹配的字符串首
RLENGTH 	被匹配函数匹配的字符串长度
SUBSEP 	\034


cat /opt/storage.sql | grep INSERT | awk -F'VALUES' '{print $2}'|awk -F'),' '{ i = 1; while ( i <= NF ) { print $i");" i++}}'| awk -F';' '{print $1}' | awk '{print $1}' 输出格式化

cat /var/log/kern.log|awk -F"=|," '/microcode/ && /CPU/{print $2}' |uniq

cat /buildarea1/lyang0/x86_guest.2/build/linux-windriver-3.4-r0/linux-x86-64-kvm-guest-standard-build/.config |grep -E "CONFIG_KVM=y|CONFIG_KVM=m"


2:system:
tail -f access_log |awk '/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }'

3:通过在awk内使用管道,可以把shell命令的输出传送给awk 
awk 'BEGIN{"date"|getline var;split(var,a);print a[4]}' 
sudo ethtool eth1 |awk '/Speed/{split($2,T,"Mb/s"); print T[1]}'

4:split:
[lyang0@pek-lpgbuild7 fsl_p4080]$ grep 'BOOTIMAGE_RAM0SIZE=' /lpg-build/cdc/fast_prod/wrlinux4.3/dvd_install/lx23h_10fa/wrlinux-4/layers/bsps/ -r |awk -F ':' '{split($1,T,"/");split($2,I,"=");print T[14] "=" I[3]}'
cav_octeon_cn56xx=200000
cav_octeon_cn58xx=200000
cav_octeon_cn63xx=200000
fsl_mpc8536e=18431
fsl_p4080=16383
fsl_p50x0=25600
ti_omap3530evm=16383
ti_sitara_am37xx=16383
wrs_sbcp4080=16383
cav_octeon_cn68xx=32768
fsl_p204x=16383
fsl_p3041=16383
cav_octeon2=32768


The split() function splits strings into pieces in a manner similar to the way input lines are split into fields. For example:

          split("cul-de-sac", a, "-", seps)

splits the string ‘cul-de-sac’ into three fields using ‘-’ as the separator. It sets the contents of the array a as follows:

          a[1] = "cul"
          a[2] = "de"
          a[3] = "sac"



4:
head -10 config.log |sed -n '/board/{s/.*board=//;s/ --enable-kernel.*$//p}'
head -10 config.log |awk -F'--enable-board=| --enable-kernel' '/board/{print $2}'
ifconfig |awk -F'inet addr:|  Bcast:' '/inet addr.*Bcast:/{print $2}'


5:getline
     ---  getline               Set $0 from next input record; set NF, NR, FNR.
     ---  getline var           Set var from next input record; set NR, FNR.

root@x86-64-kvm-guest:/autotest/client/tests/kvm# ifconfig |awk '/virbr0/{getline;split($2,T,":");print T[2];}'
128.224.165.205

ifconfig | awk '/^eth/{s=$1;getline;getline;print s,$1,$2}'


5: || and &&


TYPE=$(fdisk -l | grep $k | awk '{ if ($2 == "*") print $7;else print $6 }')

6 ;
cat xx |awk 'BEGIN {max = 0}/sda/ {if ($3-$2>max) max=$3-$2 fi;print $3-$2;print $1}'


7:str 对字符进行操作
echo "/dev/sda3" |awk -F/ '{print substr($3,4)}'

要截取的内容2：
2007-08-04 04:45:03.084 - SuccessfulTradeResult(status: 1, currencyPair: 'USDJPY', tradeId: '17389681', clientReference: '20070803COVR00013176', tradeDateTime: '2007-08-03T19:45:02', dealerUserId: 'PANTARHEI.API1', clientName: 'PANTA RHEI SECURITIES CO LTD ', clientId: 'EU0271383', counterpartyName: 'DB', buySell: 'S', nearLeftAmount: 1810000.0, nearRightAmount: 2.138696E8, nearRate: 118.16, nearValueDate: '2007-08-07')


操作指令：
 grep -v 'errorMessage' ./GWDBCpTradeResponse.20070803 | awk -F',' '{printsubstr($4,20)","substr($3,12,8)","substr($2,17,6)","substr($5,18,19)","substr($9,21,2)","substr($10,12,1)","substr($11,18)","substr($12,19)","substr($13,12)","substr($14,18,10)}' | tr -d "'"
 
结果:20070803COVR00013176,17389681,USDJPY,2007-08-3T19:45:02,DB,S,1810000.0,2.138696E8,118.16,2007-08

解释：
substr($4,20)     --->  表示是从第4个字段里的第20个字符开始，一直到设定的分隔符","结束.

substr($3,12,8)  --->  表示是从第3个字段里的第12个字符开始，截取8个字符结束.

substr($3,6)     --->  表示是从第3个字段里的第6个字符开始，一直到设定的分隔.

8:if($0~/A/)


9:
   当getline左右有重定向符|或<时，getline作用于定向输入文件，由于该文件是刚打开，awk并没有读入一行数据，而getline读入了一行数据，那么getline返回的是该文件的第一行，而不是隔行。
root@myfreelinux pub]# awk ‘BEGIN{“cat kecheng.dat”|getline var;print var;}’
[root@myfreelinux pub]# awk ‘BEGIN{“cat kecheng.dat”|getline;print $0;}’
[root@myfreelinux pub]# awk ‘BEGIN{getline var<”kecheng.dat”;print var;}’
[root@myfreelinux pub]# awk ‘BEGIN{getline <”kecheng.dat”;print $0;}’

10 gsub替换

{ gsub(/Britain/, "United Kingdom"); print }

replaces all occurrences of the string ‘Britain’ with ‘United Kingdom’ for all input records. 


11)sub
This function is peculiar because target is not simply used to compute a value, and not just any expression will do—it must be a variable, field, or array element so that sub() can store a modified value there. If this argument is omitted, then the default is to use and alter $0.2 For example:

          str = "water, water, everywhere"
          sub(/at/, "ith", str)

sets str to ‘wither, water, everywhere’, by replacing the leftmost longest occurrence of ‘at’ with ‘ith’.

If the special character ‘&’ appears in replacement, it stands for the precise substring that was matched by regexp. (If the regexp can match more than one string, then this precise substring may vary.) For example:

          { sub(/candidate/, "& and his wife"); print }

12)  
$ awk '$1 ~ /foo/ { print $0 }' BBS-list
awk '/foo/ { print $1, $NF }' BBS-list


     LC_ALL=C ls -l | awk '$6 == "Nov" { sum += $5 }
                           END { print sum }'

13:sum
This command prints the total number of bytes in all the files in the current directory that were last modified in November (of any year). The ‘ls -l’ part of this example is a system command that gives you a listing of the files in a directory, including each file's size and the date the file was last modified. Its output looks like this:

     -rw-r--r--  1 arnold   user   1933 Nov  7 13:05 Makefile
     -rw-r--r--  1 arnold   user  10809 Nov  7 13:03 awk.h
     -rw-r--r--  1 arnold   user    983 Apr 13 12:14 awk.tab.h
     -rw-r--r--  1 arnold   user  31869 Jun 15 12:20 awkgram.y
     -rw-r--r--  1 arnold   user  22414 Nov  7 13:03 awk1.c
     -rw-r--r--  1 arnold   user  37455 Nov  7 13:03 awk2.c
     -rw-r--r--  1 arnold   user  27511 Dec  9 13:07 awk3.c
     -rw-r--r--  1 arnold   user   7989 Nov  7 13:03 awk4.c
     
     
14:倒数的方法
Disk /dev/sda: 1000.2 GB, 1000204886016 bytes
255 heads, 63 sectors/track, 121601 cylinders, total 1953525168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x85bda12f

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           63    62926604    31463271   83  Linux
/dev/sda2        62926605    83907494    10490445   83  zz
/dev/sda3        83907495  1953520064   934806285   83  Linux

lyang0@lyang0-OptiPlex-755:~/test$ cat zz |awk '/^\// && !/Linux/{if ($(NF-3)-$(NF-4)>max) max=$(NF-3)-$(NF-4);p=$1} END {print p,"="max}'
/dev/sda2 =20980889

awk 'BEGIN {m=0} /^\// { m=($3-$2>m)?$3-$2:m} END {print m}' BEGIN {m=0} can be removed 


lyang0@lyang0-OptiPlex-755:~/test$ cat yy
   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           63    62926604    31463271   83  Linux
/dev/sda2        62926605    83907494    10490445   83  Windows
/dev/sda3   T T     83907495  1953520064   934806285   83  Linux fat 32

lyang0@lyang0-OptiPlex-755:~/test$ cat yy |awk '{for (i=1;i<=NF;i++)if($i=="83")print $(i-1)}'
31463271
10490445
934806285

     

